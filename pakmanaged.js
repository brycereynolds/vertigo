var global = Function("return this;")();
/*!
  * Ender: open module JavaScript framework (client-lib)
  * copyright Dustin Diaz & Jacob Thornton 2011 (@ded @fat)
  * http://ender.no.de
  * License MIT
  */
!function (context) {

  // a global object for node.js module compatiblity
  // ============================================

  context['global'] = context

  // Implements simple module system
  // losely based on CommonJS Modules spec v1.1.1
  // ============================================

  var modules = {}
    , old = context.$

  function require (identifier) {
    // modules can be required from ender's build system, or found on the window
    var module = modules[identifier] || window[identifier]
    if (!module) throw new Error("Requested module '" + identifier + "' has not been defined.")
    return module
  }

  function provide (name, what) {
    return (modules[name] = what)
  }

  context['provide'] = provide
  context['require'] = require

  function aug(o, o2) {
    for (var k in o2) k != 'noConflict' && k != '_VERSION' && (o[k] = o2[k])
    return o
  }

  function boosh(s, r, els) {
    // string || node || nodelist || window
    if (typeof s == 'string' || s.nodeName || (s.length && 'item' in s) || s == window) {
      els = ender._select(s, r)
      els.selector = s
    } else els = isFinite(s.length) ? s : [s]
    return aug(els, boosh)
  }

  function ender(s, r) {
    return boosh(s, r)
  }

  aug(ender, {
      _VERSION: '0.3.6'
    , fn: boosh // for easy compat to jQuery plugins
    , ender: function (o, chain) {
        aug(chain ? boosh : ender, o)
      }
    , _select: function (s, r) {
        return (r || document).querySelectorAll(s)
      }
  })

  aug(boosh, {
    forEach: function (fn, scope, i) {
      // opt out of native forEach so we can intentionally call our own scope
      // defaulting to the current item and be able to return self
      for (i = 0, l = this.length; i < l; ++i) i in this && fn.call(scope || this[i], this[i], i, this)
      // return self for chaining
      return this
    },
    $: ender // handy reference to self
  })

  ender.noConflict = function () {
    context.$ = old
    return this
  }

  if (typeof module !== 'undefined' && module.exports) module.exports = ender
  // use subscript notation as extern for Closure compilation
  context['ender'] = context['$'] = context['ender'] || ender

}(this);
// pakmanager:kind-of
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var toString = Object.prototype.toString;
    
    /**
     * Get the native `typeof` a value.
     *
     * @param  {*} `val`
     * @return {*} Native javascript type
     */
    
    module.exports = function kindOf(val) {
      // primitivies
      if (typeof val === 'undefined') {
        return 'undefined';
      }
      if (val === null) {
        return 'null';
      }
      if (val === true || val === false || val instanceof Boolean) {
        return 'boolean';
      }
      if (typeof val === 'string' || val instanceof String) {
        return 'string'
      }
      if (typeof val === 'number' || val instanceof Number) {
        return 'number'
      }
    
      // functions
      if (typeof val === 'function' || val instanceof Function) {
        return 'function'
      }
    
      // array
      if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
        return 'array';
      }
    
      // check for instances of RegExp and Date before calling `toString`
      if (val instanceof RegExp) {
        return 'regexp';
      }
      if (val instanceof Date) {
        return 'date';
      }
    
      // other objects
      var type = toString.call(val);
    
      if (type === '[object RegExp]') {
        return 'regexp';
      }
      if (type === '[object Date]') {
        return 'date';
      }
      if (type === '[object Arguments]') {
        return 'arguments';
      }
    
      // buffer
      if (typeof Buffer !== 'undefined' && Buffer.isBuffer(val)) {
        return 'buffer';
      }
    
      // es6: Map, WeakMap, Set, WeakSet
      if (type === '[object Set]') {
        return 'set';
      }
      if (type === '[object WeakSet]') {
        return 'weakset';
      }
      if (type === '[object Map]') {
        return 'map';
      }
      if (type === '[object WeakMap]') {
        return 'weakmap';
      }
      if (type === '[object Symbol]') {
        return 'symbol';
      }
    
      // must be a plain object
      return 'object';
    };
    
  provide("kind-of", module.exports);
}(global));

// pakmanager:longest
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * longest <https://github.com/jonschlinkert/longest>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    module.exports = function(arr) {
      if (!arr) {
        return null;
      }
    
      var len = arr.length;
      if (!len) {
        return null;
      }
    
      var c = 0;
      var i = 0;
      var ele;
      var elen;
      var res;
    
      for (; i < len; i++) {
        ele = arr[i].toString();
        elen = ele.length;
    
        if (elen > c) {
          res = ele;
          c = elen;
        }
      }
    
      return res;
    };
    
  provide("longest", module.exports);
}(global));

// pakmanager:repeat-string
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * repeat-string <https://github.com/jonschlinkert/repeat-string>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    /**
     * Expose `repeat`
     */
    
    module.exports = repeat;
    
    /**
     * Repeat the given `string` the specified `number`
     * of times.
     *
     * **Example:**
     *
     * ```js
     * var repeat =  require('repeat-string');
     * repeat('A', 5);
     * //=> AAAAA
     * ```
     *
     * @param {String} `string` The string to repeat
     * @param {Number} `number` The number of times to repeat the string
     * @return {String} Repeated string
     * @api public
     */
    
    function repeat(str, num) {
      if (typeof str !== 'string') {
        throw new TypeError('repeat-string expects a string.');
      }
    
      if (num === 1) return str;
      if (num === 2) return str + str;
    
      var max = str.length * num;
      if (cache !== str || typeof cache === 'undefined') {
        cache = str;
        res = '';
      }
    
      while (max > res.length && num > 0) {
        if (num & 1) {
          res += str;
        }
    
        num >>= 1;
        if (!num) break;
        str += str;
      }
    
      return res.substr(0, max);
    }
    
    /**
     * Results cache
     */
    
    var res = '';
    var cache;
    
  provide("repeat-string", module.exports);
}(global));

// pakmanager:align-text
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * align-text <https://github.com/jonschlinkert/align-text>
     *
     * Copyright (c) 2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var typeOf = require('kind-of');
    var repeat = require('repeat-string');
    var longest = require('longest');
    
    module.exports = function alignText(val, fn) {
      var lines, type = typeOf(val);
    
      if (type === 'array') {
        lines = val;
      } else if (type === 'string') {
        lines = val.split(/(?:\r\n|\n)/);
      } else {
        throw new TypeError('align-text expects a string or array.');
      }
    
      var fnType = typeOf(fn);
      var len = lines.length;
      var max = longest(lines);
      var res = [], i = 0;
    
      while (len--) {
        var line = String(lines[i++]);
        var diff;
    
        if (fnType === 'function') {
          diff = fn(line.length, max.length, line, lines, i);
        } else if (fnType === 'number') {
          diff = fn;
        } else {
          diff = max.length - line.length;
        }
    
        if (typeOf(diff) === 'number') {
          res.push(repeat(' ', diff) + line);
        } else if (typeOf(diff) === 'object') {
          var result = repeat(diff.character || ' ', diff.indent || 0);
          res.push((diff.prefix || '') + result + line);
        }
      }
    
      if (type === 'array') return res;
      return res.join('\n');
    };
    
  provide("align-text", module.exports);
}(global));

// pakmanager:hoek/lib/escape
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Declare internals
    
    var internals = {};
    
    
    exports.escapeJavaScript = function (input) {
    
        if (!input) {
            return '';
        }
    
        var escaped = '';
    
        for (var i = 0, il = input.length; i < il; ++i) {
    
            var charCode = input.charCodeAt(i);
    
            if (internals.isSafe(charCode)) {
                escaped += input[i];
            }
            else {
                escaped += internals.escapeJavaScriptChar(charCode);
            }
        }
    
        return escaped;
    };
    
    
    exports.escapeHtml = function (input) {
    
        if (!input) {
            return '';
        }
    
        var escaped = '';
    
        for (var i = 0, il = input.length; i < il; ++i) {
    
            var charCode = input.charCodeAt(i);
    
            if (internals.isSafe(charCode)) {
                escaped += input[i];
            }
            else {
                escaped += internals.escapeHtmlChar(charCode);
            }
        }
    
        return escaped;
    };
    
    
    internals.escapeJavaScriptChar = function (charCode) {
    
        if (charCode >= 256) {
            return '\\u' + internals.padLeft('' + charCode, 4);
        }
    
        var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
        return '\\x' + internals.padLeft(hexValue, 2);
    };
    
    
    internals.escapeHtmlChar = function (charCode) {
    
        var namedEscape = internals.namedHtml[charCode];
        if (typeof namedEscape !== 'undefined') {
            return namedEscape;
        }
    
        if (charCode >= 256) {
            return '&#' + charCode + ';';
        }
    
        var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
        return '&#x' + internals.padLeft(hexValue, 2) + ';';
    };
    
    
    internals.padLeft = function (str, len) {
    
        while (str.length < len) {
            str = '0' + str;
        }
    
        return str;
    };
    
    
    internals.isSafe = function (charCode) {
    
        return (typeof internals.safeCharCodes[charCode] !== 'undefined');
    };
    
    
    internals.namedHtml = {
        '38': '&amp;',
        '60': '&lt;',
        '62': '&gt;',
        '34': '&quot;',
        '160': '&nbsp;',
        '162': '&cent;',
        '163': '&pound;',
        '164': '&curren;',
        '169': '&copy;',
        '174': '&reg;'
    };
    
    
    internals.safeCharCodes = (function () {
    
        var safe = {};
    
        for (var i = 32; i < 123; ++i) {
    
            if ((i >= 97) ||                    // a-z
                (i >= 65 && i <= 90) ||         // A-Z
                (i >= 48 && i <= 57) ||         // 0-9
                i === 32 ||                     // space
                i === 46 ||                     // .
                i === 44 ||                     // ,
                i === 45 ||                     // -
                i === 58 ||                     // :
                i === 95) {                     // _
    
                safe[i] = null;
            }
        }
    
        return safe;
    }());
    
  provide("hoek/lib/escape", module.exports);
}(global));

// pakmanager:hoek/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Crypto = require('crypto');
    var Path = require('path');
    var Util = require('util');
    var Escape =  require('hoek/lib/escape');
    
    
    // Declare internals
    
    var internals = {};
    
    
    // Clone object or array
    
    exports.clone = function (obj, seen) {
    
        if (typeof obj !== 'object' ||
            obj === null) {
    
            return obj;
        }
    
        seen = seen || { orig: [], copy: [] };
    
        var lookup = seen.orig.indexOf(obj);
        if (lookup !== -1) {
            return seen.copy[lookup];
        }
    
        var newObj;
        var cloneDeep = false;
    
        if (!Array.isArray(obj)) {
            if (Buffer.isBuffer(obj)) {
                newObj = new Buffer(obj);
            }
            else if (obj instanceof Date) {
                newObj = new Date(obj.getTime());
            }
            else if (obj instanceof RegExp) {
                newObj = new RegExp(obj);
            }
            else {
                var proto = Object.getPrototypeOf(obj);
                if (proto &&
                    proto.isImmutable) {
    
                    newObj = obj;
                }
                else {
                    newObj = Object.create(proto);
                    cloneDeep = true;
                }
            }
        }
        else {
            newObj = [];
            cloneDeep = true;
        }
    
        seen.orig.push(obj);
        seen.copy.push(newObj);
    
        if (cloneDeep) {
            var keys = Object.getOwnPropertyNames(obj);
            for (var i = 0, il = keys.length; i < il; ++i) {
                var key = keys[i];
                var descriptor = Object.getOwnPropertyDescriptor(obj, key);
                if (descriptor.get ||
                    descriptor.set) {
    
                    Object.defineProperty(newObj, key, descriptor);
                }
                else {
                    newObj[key] = exports.clone(obj[key], seen);
                }
            }
        }
    
        return newObj;
    };
    
    
    // Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied
    /*eslint-disable */
    exports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {
    /*eslint-enable */
        exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');
        exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');
    
        if (!source) {
            return target;
        }
    
        if (Array.isArray(source)) {
            exports.assert(Array.isArray(target), 'Cannot merge array onto an object');
            if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true
                target.length = 0;                                                          // Must not change target assignment
            }
    
            for (var i = 0, il = source.length; i < il; ++i) {
                target.push(exports.clone(source[i]));
            }
    
            return target;
        }
    
        var keys = Object.keys(source);
        for (var k = 0, kl = keys.length; k < kl; ++k) {
            var key = keys[k];
            var value = source[key];
            if (value &&
                typeof value === 'object') {
    
                if (!target[key] ||
                    typeof target[key] !== 'object' ||
                    (Array.isArray(target[key]) ^ Array.isArray(value)) ||
                    value instanceof Date ||
                    Buffer.isBuffer(value) ||
                    value instanceof RegExp) {
    
                    target[key] = exports.clone(value);
                }
                else {
                    exports.merge(target[key], value, isNullOverride, isMergeArrays);
                }
            }
            else {
                if (value !== null &&
                    value !== undefined) {                              // Explicit to preserve empty strings
    
                    target[key] = value;
                }
                else if (isNullOverride !== false) {                    // Defaults to true
                    target[key] = value;
                }
            }
        }
    
        return target;
    };
    
    
    // Apply options to a copy of the defaults
    
    exports.applyToDefaults = function (defaults, options, isNullOverride) {
    
        exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
        exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');
    
        if (!options) {                                                 // If no options, return null
            return null;
        }
    
        var copy = exports.clone(defaults);
    
        if (options === true) {                                         // If options is set to true, use defaults
            return copy;
        }
    
        return exports.merge(copy, options, isNullOverride === true, false);
    };
    
    
    // Clone an object except for the listed keys which are shallow copied
    
    exports.cloneWithShallow = function (source, keys) {
    
        if (!source ||
            typeof source !== 'object') {
    
            return source;
        }
    
        var storage = internals.store(source, keys);    // Move shallow copy items to storage
        var copy = exports.clone(source);               // Deep copy the rest
        internals.restore(copy, source, storage);       // Shallow copy the stored items and restore
        return copy;
    };
    
    
    internals.store = function (source, keys) {
    
        var storage = {};
        for (var i = 0, il = keys.length; i < il; ++i) {
            var key = keys[i];
            var value = exports.reach(source, key);
            if (value !== undefined) {
                storage[key] = value;
                internals.reachSet(source, key, undefined);
            }
        }
    
        return storage;
    };
    
    
    internals.restore = function (copy, source, storage) {
    
        var keys = Object.keys(storage);
        for (var i = 0, il = keys.length; i < il; ++i) {
            var key = keys[i];
            internals.reachSet(copy, key, storage[key]);
            internals.reachSet(source, key, storage[key]);
        }
    };
    
    
    internals.reachSet = function (obj, key, value) {
    
        var path = key.split('.');
        var ref = obj;
        for (var i = 0, il = path.length; i < il; ++i) {
            var segment = path[i];
            if (i + 1 === il) {
                ref[segment] = value;
            }
    
            ref = ref[segment];
        }
    };
    
    
    // Apply options to defaults except for the listed keys which are shallow copied from option without merging
    
    exports.applyToDefaultsWithShallow = function (defaults, options, keys) {
    
        exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
        exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');
        exports.assert(keys && Array.isArray(keys), 'Invalid keys');
    
        if (!options) {                                                 // If no options, return null
            return null;
        }
    
        var copy = exports.cloneWithShallow(defaults, keys);
    
        if (options === true) {                                         // If options is set to true, use defaults
            return copy;
        }
    
        var storage = internals.store(options, keys);   // Move shallow copy items to storage
        exports.merge(copy, options, false, false);     // Deep copy the rest
        internals.restore(copy, options, storage);      // Shallow copy the stored items and restore
        return copy;
    };
    
    
    // Deep object or array comparison
    
    exports.deepEqual = function (obj, ref, options, seen) {
    
        options = options || { prototype: true };
    
        var type = typeof obj;
    
        if (type !== typeof ref) {
            return false;
        }
    
        if (type !== 'object' ||
            obj === null ||
            ref === null) {
    
            if (obj === ref) {                                                      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql
                return obj !== 0 || 1 / obj === 1 / ref;        // -0 / +0
            }
    
            return obj !== obj && ref !== ref;                  // NaN
        }
    
        seen = seen || [];
        if (seen.indexOf(obj) !== -1) {
            return true;                            // If previous comparison failed, it would have stopped execution
        }
    
        seen.push(obj);
    
        if (Array.isArray(obj)) {
            if (!Array.isArray(ref)) {
                return false;
            }
    
            if (!options.part && obj.length !== ref.length) {
                return false;
            }
    
            for (var i = 0, il = obj.length; i < il; ++i) {
                if (options.part) {
                    var found = false;
                    for (var r = 0, rl = ref.length; r < rl; ++r) {
                        if (exports.deepEqual(obj[i], ref[r], options, seen)) {
                            found = true;
                            break;
                        }
                    }
    
                    return found;
                }
    
                if (!exports.deepEqual(obj[i], ref[i], options, seen)) {
                    return false;
                }
            }
    
            return true;
        }
    
        if (Buffer.isBuffer(obj)) {
            if (!Buffer.isBuffer(ref)) {
                return false;
            }
    
            if (obj.length !== ref.length) {
                return false;
            }
    
            for (var j = 0, jl = obj.length; j < jl; ++j) {
                if (obj[j] !== ref[j]) {
                    return false;
                }
            }
    
            return true;
        }
    
        if (obj instanceof Date) {
            return (ref instanceof Date && obj.getTime() === ref.getTime());
        }
    
        if (obj instanceof RegExp) {
            return (ref instanceof RegExp && obj.toString() === ref.toString());
        }
    
        if (options.prototype) {
            if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
                return false;
            }
        }
    
        var keys = Object.getOwnPropertyNames(obj);
    
        if (!options.part && keys.length !== Object.getOwnPropertyNames(ref).length) {
            return false;
        }
    
        for (var k = 0, kl = keys.length; k < kl; ++k) {
            var key = keys[k];
            var descriptor = Object.getOwnPropertyDescriptor(obj, key);
            if (descriptor.get) {
                if (!exports.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), options, seen)) {
                    return false;
                }
            }
            else if (!exports.deepEqual(obj[key], ref[key], options, seen)) {
                return false;
            }
        }
    
        return true;
    };
    
    
    // Remove duplicate items from array
    
    exports.unique = function (array, key) {
    
        var index = {};
        var result = [];
    
        for (var i = 0, il = array.length; i < il; ++i) {
            var id = (key ? array[i][key] : array[i]);
            if (index[id] !== true) {
    
                result.push(array[i]);
                index[id] = true;
            }
        }
    
        return result;
    };
    
    
    // Convert array into object
    
    exports.mapToObject = function (array, key) {
    
        if (!array) {
            return null;
        }
    
        var obj = {};
        for (var i = 0, il = array.length; i < il; ++i) {
            if (key) {
                if (array[i][key]) {
                    obj[array[i][key]] = true;
                }
            }
            else {
                obj[array[i]] = true;
            }
        }
    
        return obj;
    };
    
    
    // Find the common unique items in two arrays
    
    exports.intersect = function (array1, array2, justFirst) {
    
        if (!array1 || !array2) {
            return [];
        }
    
        var common = [];
        var hash = (Array.isArray(array1) ? exports.mapToObject(array1) : array1);
        var found = {};
        for (var i = 0, il = array2.length; i < il; ++i) {
            if (hash[array2[i]] && !found[array2[i]]) {
                if (justFirst) {
                    return array2[i];
                }
    
                common.push(array2[i]);
                found[array2[i]] = true;
            }
        }
    
        return (justFirst ? null : common);
    };
    
    
    // Test if the reference contains the values
    
    exports.contain = function (ref, values, options) {
    
        /*
            string -> string(s)
            array -> item(s)
            object -> key(s)
            object -> object (key:value)
        */
    
        var valuePairs = null;
        if (typeof ref === 'object' &&
            typeof values === 'object' &&
            !Array.isArray(ref) &&
            !Array.isArray(values)) {
    
            valuePairs = values;
            values = Object.keys(values);
        }
        else {
            values = [].concat(values);
        }
    
        options = options || {};            // deep, once, only, part
    
        exports.assert(arguments.length >= 2, 'Insufficient arguments');
        exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');
        exports.assert(values.length, 'Values array cannot be empty');
    
        var compare, compareFlags;
        if (options.deep) {
            compare = exports.deepEqual;
    
            var hasOnly = options.hasOwnProperty('only'), hasPart = options.hasOwnProperty('part');
    
            compareFlags = {
                prototype: hasOnly ? options.only : hasPart ? !options.part : false,
                part: hasOnly ? !options.only : hasPart ? options.part : true
            };
        }
        else {
            compare = function (a, b) {
    
                return a === b;
            };
        }
    
        var misses = false;
        var matches = new Array(values.length);
        for (var i = 0, il = matches.length; i < il; ++i) {
            matches[i] = 0;
        }
    
        if (typeof ref === 'string') {
            var pattern = '(';
            for (i = 0, il = values.length; i < il; ++i) {
                var value = values[i];
                exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');
                pattern += (i ? '|' : '') + exports.escapeRegex(value);
            }
    
            var regex = new RegExp(pattern + ')', 'g');
            var leftovers = ref.replace(regex, function ($0, $1) {
    
                var index = values.indexOf($1);
                ++matches[index];
                return '';          // Remove from string
            });
    
            misses = !!leftovers;
        }
        else if (Array.isArray(ref)) {
            for (i = 0, il = ref.length; i < il; ++i) {
                for (var j = 0, jl = values.length, matched = false; j < jl && matched === false; ++j) {
                    matched = compare(values[j], ref[i], compareFlags) && j;
                }
    
                if (matched !== false) {
                    ++matches[matched];
                }
                else {
                    misses = true;
                }
            }
        }
        else {
            var keys = Object.keys(ref);
            for (i = 0, il = keys.length; i < il; ++i) {
                var key = keys[i];
                var pos = values.indexOf(key);
                if (pos !== -1) {
                    if (valuePairs &&
                        !compare(valuePairs[key], ref[key], compareFlags)) {
    
                        return false;
                    }
    
                    ++matches[pos];
                }
                else {
                    misses = true;
                }
            }
        }
    
        var result = false;
        for (i = 0, il = matches.length; i < il; ++i) {
            result = result || !!matches[i];
            if ((options.once && matches[i] > 1) ||
                (!options.part && !matches[i])) {
    
                return false;
            }
        }
    
        if (options.only &&
            misses) {
    
            return false;
        }
    
        return result;
    };
    
    
    // Flatten array
    
    exports.flatten = function (array, target) {
    
        var result = target || [];
    
        for (var i = 0, il = array.length; i < il; ++i) {
            if (Array.isArray(array[i])) {
                exports.flatten(array[i], result);
            }
            else {
                result.push(array[i]);
            }
        }
    
        return result;
    };
    
    
    // Convert an object key chain string ('a.b.c') to reference (object[a][b][c])
    
    exports.reach = function (obj, chain, options) {
    
        options = options || {};
        if (typeof options === 'string') {
            options = { separator: options };
        }
    
        var path = chain.split(options.separator || '.');
        var ref = obj;
        for (var i = 0, il = path.length; i < il; ++i) {
            var key = path[i];
            if (key[0] === '-' && Array.isArray(ref)) {
                key = key.slice(1, key.length);
                key = ref.length - key;
            }
    
            if (!ref ||
                !ref.hasOwnProperty(key) ||
                (typeof ref !== 'object' && options.functions === false)) {         // Only object and function can have properties
    
                exports.assert(!options.strict || i + 1 === il, 'Missing segment', key, 'in reach path ', chain);
                exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);
                ref = options.default;
                break;
            }
    
            ref = ref[key];
        }
    
        return ref;
    };
    
    
    exports.reachTemplate = function (obj, template, options) {
    
        return template.replace(/{([^}]+)}/g, function ($0, chain) {
    
            var value = exports.reach(obj, chain, options);
            return (value === undefined || value === null ? '' : value);
        });
    };
    
    
    exports.formatStack = function (stack) {
    
        var trace = [];
        for (var i = 0, il = stack.length; i < il; ++i) {
            var item = stack[i];
            trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
        }
    
        return trace;
    };
    
    
    exports.formatTrace = function (trace) {
    
        var display = [];
    
        for (var i = 0, il = trace.length; i < il; ++i) {
            var row = trace[i];
            display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');
        }
    
        return display;
    };
    
    
    exports.callStack = function (slice) {
    
        // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
    
        var v8 = Error.prepareStackTrace;
        Error.prepareStackTrace = function (err, stack) {
    
            return stack;
        };
    
        var capture = {};
        Error.captureStackTrace(capture, arguments.callee);     /*eslint no-caller:0 */
        var stack = capture.stack;
    
        Error.prepareStackTrace = v8;
    
        var trace = exports.formatStack(stack);
    
        if (slice) {
            return trace.slice(slice);
        }
    
        return trace;
    };
    
    
    exports.displayStack = function (slice) {
    
        var trace = exports.callStack(slice === undefined ? 1 : slice + 1);
    
        return exports.formatTrace(trace);
    };
    
    
    exports.abortThrow = false;
    
    
    exports.abort = function (message, hideStack) {
    
        if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {
            throw new Error(message || 'Unknown error');
        }
    
        var stack = '';
        if (!hideStack) {
            stack = exports.displayStack(1).join('\n\t');
        }
        console.log('ABORT: ' + message + '\n\t' + stack);
        process.exit(1);
    };
    
    
    exports.assert = function (condition /*, msg1, msg2, msg3 */) {
    
        if (condition) {
            return;
        }
    
        if (arguments.length === 2 && arguments[1] instanceof Error) {
            throw arguments[1];
        }
    
        var msgs = [];
        for (var i = 1, il = arguments.length; i < il; ++i) {
            if (arguments[i] !== '') {
                msgs.push(arguments[i]);            // Avoids Array.slice arguments leak, allowing for V8 optimizations
            }
        }
    
        msgs = msgs.map(function (msg) {
    
            return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : exports.stringify(msg);
        });
        throw new Error(msgs.join(' ') || 'Unknown error');
    };
    
    
    exports.Timer = function () {
    
        this.ts = 0;
        this.reset();
    };
    
    
    exports.Timer.prototype.reset = function () {
    
        this.ts = Date.now();
    };
    
    
    exports.Timer.prototype.elapsed = function () {
    
        return Date.now() - this.ts;
    };
    
    
    exports.Bench = function () {
    
        this.ts = 0;
        this.reset();
    };
    
    
    exports.Bench.prototype.reset = function () {
    
        this.ts = exports.Bench.now();
    };
    
    
    exports.Bench.prototype.elapsed = function () {
    
        return exports.Bench.now() - this.ts;
    };
    
    
    exports.Bench.now = function () {
    
        var ts = process.hrtime();
        return (ts[0] * 1e3) + (ts[1] / 1e6);
    };
    
    
    // Escape string for Regex construction
    
    exports.escapeRegex = function (string) {
    
        // Escape ^$.*+-?=!:|\/()[]{},
        return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
    };
    
    
    // Base64url (RFC 4648) encode
    
    exports.base64urlEncode = function (value, encoding) {
    
        var buf = (Buffer.isBuffer(value) ? value : new Buffer(value, encoding || 'binary'));
        return buf.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
    };
    
    
    // Base64url (RFC 4648) decode
    
    exports.base64urlDecode = function (value, encoding) {
    
        if (value &&
            !/^[\w\-]*$/.test(value)) {
    
            return new Error('Invalid character');
        }
    
        try {
            var buf = new Buffer(value, 'base64');
            return (encoding === 'buffer' ? buf : buf.toString(encoding || 'binary'));
        }
        catch (err) {
            return err;
        }
    };
    
    
    // Escape attribute value for use in HTTP header
    
    exports.escapeHeaderAttribute = function (attribute) {
    
        // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "
    
        exports.assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');
    
        return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
    };
    
    
    exports.escapeHtml = function (string) {
    
        return Escape.escapeHtml(string);
    };
    
    
    exports.escapeJavaScript = function (string) {
    
        return Escape.escapeJavaScript(string);
    };
    
    
    exports.nextTick = function (callback) {
    
        return function () {
    
            var args = arguments;
            process.nextTick(function () {
    
                callback.apply(null, args);
            });
        };
    };
    
    
    exports.once = function (method) {
    
        if (method._hoekOnce) {
            return method;
        }
    
        var once = false;
        var wrapped = function () {
    
            if (!once) {
                once = true;
                method.apply(null, arguments);
            }
        };
    
        wrapped._hoekOnce = true;
    
        return wrapped;
    };
    
    
    exports.isAbsolutePath = function (path, platform) {
    
        if (!path) {
            return false;
        }
    
        if (Path.isAbsolute) {                      // node >= 0.11
            return Path.isAbsolute(path);
        }
    
        platform = platform || process.platform;
    
        // Unix
    
        if (platform !== 'win32') {
            return path[0] === '/';
        }
    
        // Windows
    
        return !!/^(?:[a-zA-Z]:[\\\/])|(?:[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/])/.test(path);        // C:\ or \\something\something
    };
    
    
    exports.isInteger = function (value) {
    
        return (typeof value === 'number' &&
                parseFloat(value) === parseInt(value, 10) &&
                !isNaN(value));
    };
    
    
    exports.ignore = function () { };
    
    
    exports.inherits = Util.inherits;
    
    
    exports.format = Util.format;
    
    
    exports.transform = function (source, transform, options) {
    
        exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source object: must be null, undefined, or an object');
    
        var result = {};
        var keys = Object.keys(transform);
    
        for (var k = 0, kl = keys.length; k < kl; ++k) {
            var key = keys[k];
            var path = key.split('.');
            var sourcePath = transform[key];
    
            exports.assert(typeof sourcePath === 'string', 'All mappings must be "." delineated strings');
    
            var segment;
            var res = result;
    
            while (path.length > 1) {
                segment = path.shift();
                if (!res[segment]) {
                    res[segment] = {};
                }
                res = res[segment];
            }
            segment = path.shift();
            res[segment] = exports.reach(source, sourcePath, options);
        }
    
        return result;
    };
    
    
    exports.uniqueFilename = function (path, extension) {
    
        if (extension) {
            extension = extension[0] !== '.' ? '.' + extension : extension;
        }
        else {
            extension = '';
        }
    
        path = Path.resolve(path);
        var name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;
        return Path.join(path, name);
    };
    
    
    exports.stringify = function () {
    
        try {
            return JSON.stringify.apply(null, arguments);
        }
        catch (err) {
            return '[Cannot display object: ' + err.message + ']';
        }
    };
    
    
    exports.shallow = function (source) {
    
        var target = {};
        var keys = Object.keys(source);
        for (var i = 0, il = keys.length; i < il; ++i) {
            var key = keys[i];
            target[key] = source[key];
        }
    
        return target;
    };
    
  provide("hoek/lib", module.exports);
}(global));

// pakmanager:hoek
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('hoek/lib');
    
  provide("hoek", module.exports);
}(global));

// pakmanager:center-align
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * center-align <https://github.com/jonschlinkert/center-align>
     *
     * Copycenter (c) 2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var align = require('align-text');
    
    module.exports = function centerAlign(val) {
      return align(val, function (len, longest) {
        return Math.floor((longest - len) / 2);
      });
    };
    
  provide("center-align", module.exports);
}(global));

// pakmanager:right-align
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * right-align <https://github.com/jonschlinkert/right-align>
     *
     * Copyright (c) 2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var align = require('align-text');
    
    module.exports = function rightAlign(val) {
      return align(val, function (len, longest) {
        return longest - len;
      });
    };
    
  provide("right-align", module.exports);
}(global));

// pakmanager:wordwrap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var wordwrap = module.exports = function (start, stop, params) {
        if (typeof start === 'object') {
            params = start;
            start = params.start;
            stop = params.stop;
        }
        
        if (typeof stop === 'object') {
            params = stop;
            start = start || params.start;
            stop = undefined;
        }
        
        if (!stop) {
            stop = start;
            start = 0;
        }
        
        if (!params) params = {};
        var mode = params.mode || 'soft';
        var re = mode === 'hard' ? /\b/ : /(\S+\s+)/;
        
        return function (text) {
            var chunks = text.toString()
                .split(re)
                .reduce(function (acc, x) {
                    if (mode === 'hard') {
                        for (var i = 0; i < x.length; i += stop - start) {
                            acc.push(x.slice(i, i + stop - start));
                        }
                    }
                    else acc.push(x)
                    return acc;
                }, [])
            ;
            
            return chunks.reduce(function (lines, rawChunk) {
                if (rawChunk === '') return lines;
                
                var chunk = rawChunk.replace(/\t/g, '    ');
                
                var i = lines.length - 1;
                if (lines[i].length + chunk.length > stop) {
                    lines[i] = lines[i].replace(/\s+$/, '');
                    
                    chunk.split(/\n/).forEach(function (c) {
                        lines.push(
                            new Array(start + 1).join(' ')
                            + c.replace(/^\s+/, '')
                        );
                    });
                }
                else if (chunk.match(/\n/)) {
                    var xs = chunk.split(/\n/);
                    lines[i] += xs.shift();
                    xs.forEach(function (c) {
                        lines.push(
                            new Array(start + 1).join(' ')
                            + c.replace(/^\s+/, '')
                        );
                    });
                }
                else {
                    lines[i] += chunk;
                }
                
                return lines;
            }, [ new Array(start + 1).join(' ') ]).join('\n');
        };
    };
    
    wordwrap.soft = wordwrap;
    
    wordwrap.hard = function (start, stop) {
        return wordwrap(start, stop, { mode : 'hard' });
    };
    
  provide("wordwrap", module.exports);
}(global));

// pakmanager:boom
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Http = require('http');
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.wrap = function (error, statusCode, message) {
    
        Hoek.assert(error instanceof Error, 'Cannot wrap non-Error object');
        return (error.isBoom ? error : internals.initialize(error, statusCode || 500, message));
    };
    
    
    exports.create = function (statusCode, message, data) {
    
        var error = new Error(message ? message : undefined);       // Avoids settings null message
        error.data = data || null;
        internals.initialize(error, statusCode);
        return error;
    };
    
    
    internals.initialize = function (error, statusCode, message) {
    
        var numberCode = parseInt(statusCode, 10);
        Hoek.assert(!isNaN(numberCode) && numberCode >= 400, 'First argument must be a number (400+):', statusCode);
    
        error.isBoom = true;
        error.isServer = numberCode >= 500;
    
        if (!error.hasOwnProperty('data')) {
            error.data = null;
        }
    
        error.output = {
            statusCode: numberCode,
            payload: {},
            headers: {}
        };
    
        error.reformat = internals.reformat;
        error.reformat();
    
        if (!message &&
            !error.message) {
    
            message = error.output.payload.error;
        }
    
        if (message) {
            error.message = (message + (error.message ? ': ' + error.message : ''));
        }
    
        return error;
    };
    
    
    internals.reformat = function () {
    
        this.output.payload.statusCode = this.output.statusCode;
        this.output.payload.error = Http.STATUS_CODES[this.output.statusCode] || 'Unknown';
    
        if (this.output.statusCode === 500) {
            this.output.payload.message = 'An internal server error occurred';              // Hide actual error from user
        }
        else if (this.message) {
            this.output.payload.message = this.message;
        }
    };
    
    
    // 4xx Client Errors
    
    exports.badRequest = function (message, data) {
    
        return exports.create(400, message, data);
    };
    
    
    exports.unauthorized = function (message, scheme, attributes) {          // Or function (message, wwwAuthenticate[])
    
        var err = exports.create(401, message);
    
        if (!scheme) {
            return err;
        }
    
        var wwwAuthenticate = '';
        var i = 0;
        var il = 0;
    
        if (typeof scheme === 'string') {
    
            // function (message, scheme, attributes)
    
            wwwAuthenticate = scheme;
    
            if (attributes || message) {
                err.output.payload.attributes = {};
            }
    
            if (attributes) {
                var names = Object.keys(attributes);
                for (i = 0, il = names.length; i < il; ++i) {
                    var name = names[i];
                    if (i) {
                        wwwAuthenticate += ',';
                    }
    
                    var value = attributes[name];
                    if (value === null ||
                        value === undefined) {              // Value can be zero
    
                        value = '';
                    }
                    wwwAuthenticate += ' ' + name + '="' + Hoek.escapeHeaderAttribute(value.toString()) + '"';
                    err.output.payload.attributes[name] = value;
                }
            }
    
            if (message) {
                if (attributes) {
                    wwwAuthenticate += ',';
                }
                wwwAuthenticate += ' error="' + Hoek.escapeHeaderAttribute(message) + '"';
                err.output.payload.attributes.error = message;
            }
            else {
                err.isMissing = true;
            }
        }
        else {
    
            // function (message, wwwAuthenticate[])
    
            var wwwArray = scheme;
            for (i = 0, il = wwwArray.length; i < il; ++i) {
                if (i) {
                    wwwAuthenticate += ', ';
                }
    
                wwwAuthenticate += wwwArray[i];
            }
        }
    
        err.output.headers['WWW-Authenticate'] = wwwAuthenticate;
    
        return err;
    };
    
    
    exports.forbidden = function (message, data) {
    
        return exports.create(403, message, data);
    };
    
    
    exports.notFound = function (message, data) {
    
        return exports.create(404, message, data);
    };
    
    
    exports.methodNotAllowed = function (message, data) {
    
        return exports.create(405, message, data);
    };
    
    
    exports.notAcceptable = function (message, data) {
    
        return exports.create(406, message, data);
    };
    
    
    exports.proxyAuthRequired = function (message, data) {
    
        return exports.create(407, message, data);
    };
    
    
    exports.clientTimeout = function (message, data) {
    
        return exports.create(408, message, data);
    };
    
    
    exports.conflict = function (message, data) {
    
        return exports.create(409, message, data);
    };
    
    
    exports.resourceGone = function (message, data) {
    
        return exports.create(410, message, data);
    };
    
    
    exports.lengthRequired = function (message, data) {
    
        return exports.create(411, message, data);
    };
    
    
    exports.preconditionFailed = function (message, data) {
    
        return exports.create(412, message, data);
    };
    
    
    exports.entityTooLarge = function (message, data) {
    
        return exports.create(413, message, data);
    };
    
    
    exports.uriTooLong = function (message, data) {
    
        return exports.create(414, message, data);
    };
    
    
    exports.unsupportedMediaType = function (message, data) {
    
        return exports.create(415, message, data);
    };
    
    
    exports.rangeNotSatisfiable = function (message, data) {
    
        return exports.create(416, message, data);
    };
    
    
    exports.expectationFailed = function (message, data) {
    
        return exports.create(417, message, data);
    };
    
    exports.badData = function (message, data) {
    
        return exports.create(422, message, data);
    };
    
    
    exports.tooManyRequests = function (message, data) {
    
        return exports.create(429, message, data);
    };
    
    
    // 5xx Server Errors
    
    exports.internal = function (message, data, statusCode) {
    
        var error = (data instanceof Error ? exports.wrap(data, statusCode, message) : exports.create(statusCode || 500, message));
    
        if (data instanceof Error === false) {
            error.data = data;
        }
    
        return error;
    };
    
    
    exports.notImplemented = function (message, data) {
    
        return exports.internal(message, data, 501);
    };
    
    
    exports.badGateway = function (message, data) {
    
        return exports.internal(message, data, 502);
    };
    
    
    exports.serverTimeout = function (message, data) {
    
        return exports.internal(message, data, 503);
    };
    
    
    exports.gatewayTimeout = function (message, data) {
    
        return exports.internal(message, data, 504);
    };
    
    
    exports.badImplementation = function (message, data) {
    
        var err = exports.internal(message, data, 500);
        err.isDeveloperError = true;
        return err;
    };
    
  provide("boom", module.exports);
}(global));

// pakmanager:vise/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports = module.exports = internals.Vise = function (chunks) {
    
        this.length = 0;
        this._chunks = [];
        this._offset = 0;
    
        if (chunks) {
            chunks = [].concat(chunks);
            for (var i = 0, il = chunks.length; i < il; ++i) {
                this.push(chunks[i]);
            }
        }
    };
    
    
    internals.Vise.prototype.push = function (chunk) {
    
        Hoek.assert(Buffer.isBuffer(chunk), 'Chunk must be a buffer');
    
        var item = {
            data: chunk,
            length: chunk.length,
            offset: this.length + this._offset,
            index: this._chunks.length
        };
    
        this._chunks.push(item);
        this.length += chunk.length;
    };
    
    
    internals.Vise.prototype.shift = function (length) {
    
        if (!length) {
            return [];
        }
    
        var prevOffset = this._offset;
        var item = this._chunkAt(length);
    
        var dropTo = this._chunks.length;
        this._offset = 0;
    
        if (item) {
            dropTo = item.chunk.index;
            this._offset = item.offset;
        }
    
        // Drop lower chunks
    
        var chunks = [];
        for (var i = 0; i < dropTo; ++i) {
            var chunk = this._chunks.shift();
            if (i === 0 &&
                prevOffset) {
    
                chunks.push(chunk.data.slice(prevOffset));
            }
            else {
                chunks.push(chunk.data);
            }
        }
    
        if (this._offset) {
            chunks.push(item.chunk.data.slice(dropTo ? 0 : prevOffset, this._offset));
        }
    
        // Recalculate existing chunks
    
        this.length = 0;
        for (var j = 0, jl = this._chunks.length; j < jl; ++j) {
            var chunk = this._chunks[j];
            chunk.offset = this.length,
            chunk.index = j;
    
            this.length += chunk.length;
        }
    
        this.length -= this._offset;
    
        return chunks;
    };
    
    
    internals.Vise.prototype.at = internals.Vise.prototype.readUInt8 = function (pos) {
    
        var item = this._chunkAt(pos);
        return item ? item.chunk.data[item.offset] : undefined;
    };
    
    
    internals.Vise.prototype._chunkAt = function (pos) {
    
        if (pos < 0) {
            return null;
        }
    
        pos = pos + this._offset;
    
        for (var i = 0, il = this._chunks.length; i < il; ++i) {
            var chunk = this._chunks[i];
            var offset = pos - chunk.offset;
            if (offset < chunk.length) {
                return { chunk: chunk, offset: offset };
            }
        }
    
        return null;
    };
    
    
    internals.Vise.prototype.chunks = function () {
    
        var chunks = [];
    
        for (var i = 0, il = this._chunks.length; i < il; ++i) {
            var chunk = this._chunks[i];
            if (i === 0 &&
                this._offset) {
    
                chunks.push(chunk.data.slice(this._offset));
            }
            else {
                chunks.push(chunk.data);
            }
        }
    
        return chunks;
    };
    
    
    internals.Vise.prototype.startsWith = function (value, pos, length) {
    
        pos = pos || 0;
    
        length = length ? Math.min(value.length, length) : value.length;
        if (pos + length > this.length) {                                   // Not enough length to fit value
            return false;
        }
    
        var start = this._chunkAt(pos);
        if (!start) {
            return false;
        }
    
        for (var k = start.chunk.index, kl = this._chunks.length, j = 0; k < kl && j < length; ++k) {
            var chunk = this._chunks[k];
    
            var offset = (k === start.chunk.index ? start.offset : 0);
            for (var i = offset, il = chunk.length; i < il && j < length; ++i, ++j) {
                if (chunk.data[i] !== value[j]) {
                    return false;
                }
            }
        }
    
        return true;
    };
  provide("vise/lib", module.exports);
}(global));

// pakmanager:vise
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('vise/lib');
  provide("vise", module.exports);
}(global));

// pakmanager:amdefine
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /** vim: et:ts=4:sw=4:sts=4
     * @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
     * Available via the MIT or new BSD license.
     * see: http://github.com/jrburke/amdefine for details
     */
    
    /*jslint node: true */
    /*global module, process */
    'use strict';
    
    /**
     * Creates a define for node.
     * @param {Object} module the "module" object that is defined by Node for the
     * current module.
     * @param {Function} [requireFn]. Node's require function for the current module.
     * It only needs to be passed in Node versions before 0.5, when module.require
     * did not exist.
     * @returns {Function} a define function that is usable for the current node
     * module.
     */
    function amdefine(module, requireFn) {
        'use strict';
        var defineCache = {},
            loaderCache = {},
            alreadyCalled = false,
            path = require('path'),
            makeRequire, stringRequire;
    
        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; ary[i]; i+= 1) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                        //End of the line. Keep at least one non-dot
                        //path segment at the front so it can be mapped
                        //correctly to disk. Otherwise, there is likely
                        //no path mapping for a path starting with '..'.
                        //This can still fail, but catches the most reasonable
                        //uses of ..
                        break;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }
    
        function normalize(name, baseName) {
            var baseParts;
    
            //Adjust any relative paths.
            if (name && name.charAt(0) === '.') {
                //If have a base name, try to normalize against it,
                //otherwise, assume it is a top-level require that will
                //be relative to baseUrl in the end.
                if (baseName) {
                    baseParts = baseName.split('/');
                    baseParts = baseParts.slice(0, baseParts.length - 1);
                    baseParts = baseParts.concat(name.split('/'));
                    trimDots(baseParts);
                    name = baseParts.join('/');
                }
            }
    
            return name;
        }
    
        /**
         * Create the normalize() function passed to a loader plugin's
         * normalize method.
         */
        function makeNormalize(relName) {
            return function (name) {
                return normalize(name, relName);
            };
        }
    
        function makeLoad(id) {
            function load(value) {
                loaderCache[id] = value;
            }
    
            load.fromText = function (id, text) {
                //This one is difficult because the text can/probably uses
                //define, and any relative paths and requires should be relative
                //to that id was it would be found on disk. But this would require
                //bootstrapping a module/require fairly deeply from node core.
                //Not sure how best to go about that yet.
                throw new Error('amdefine does not implement load.fromText');
            };
    
            return load;
        }
    
        makeRequire = function (systemRequire, exports, module, relId) {
            function amdRequire(deps, callback) {
                if (typeof deps === 'string') {
                    //Synchronous, single module require('')
                    return stringRequire(systemRequire, exports, module, deps, relId);
                } else {
                    //Array of dependencies with a callback.
    
                    //Convert the dependencies to modules.
                    deps = deps.map(function (depName) {
                        return stringRequire(systemRequire, exports, module, depName, relId);
                    });
    
                    //Wait for next tick to call back the require call.
                    if (callback) {
                        process.nextTick(function () {
                            callback.apply(null, deps);
                        });
                    }
                }
            }
    
            amdRequire.toUrl = function (filePath) {
                if (filePath.indexOf('.') === 0) {
                    return normalize(filePath, path.dirname(module.filename));
                } else {
                    return filePath;
                }
            };
    
            return amdRequire;
        };
    
        //Favor explicit value, passed in if the module wants to support Node 0.4.
        requireFn = requireFn || function req() {
            return module.require.apply(module, arguments);
        };
    
        function runFactory(id, deps, factory) {
            var r, e, m, result;
    
            if (id) {
                e = loaderCache[id] = {};
                m = {
                    id: id,
                    uri: __filename,
                    exports: e
                };
                r = makeRequire(requireFn, e, m, id);
            } else {
                //Only support one define call per file
                if (alreadyCalled) {
                    throw new Error('amdefine with no module ID cannot be called more than once per file.');
                }
                alreadyCalled = true;
    
                //Use the real variables from node
                //Use module.exports for exports, since
                //the exports in here is amdefine exports.
                e = module.exports;
                m = module;
                r = makeRequire(requireFn, e, m, module.id);
            }
    
            //If there are dependencies, they are strings, so need
            //to convert them to dependency values.
            if (deps) {
                deps = deps.map(function (depName) {
                    return r(depName);
                });
            }
    
            //Call the factory with the right dependencies.
            if (typeof factory === 'function') {
                result = factory.apply(m.exports, deps);
            } else {
                result = factory;
            }
    
            if (result !== undefined) {
                m.exports = result;
                if (id) {
                    loaderCache[id] = m.exports;
                }
            }
        }
    
        stringRequire = function (systemRequire, exports, module, id, relId) {
            //Split the ID by a ! so that
            var index = id.indexOf('!'),
                originalId = id,
                prefix, plugin;
    
            if (index === -1) {
                id = normalize(id, relId);
    
                //Straight module lookup. If it is one of the special dependencies,
                //deal with it, otherwise, delegate to node.
                if (id === 'require') {
                    return makeRequire(systemRequire, exports, module, relId);
                } else if (id === 'exports') {
                    return exports;
                } else if (id === 'module') {
                    return module;
                } else if (loaderCache.hasOwnProperty(id)) {
                    return loaderCache[id];
                } else if (defineCache[id]) {
                    runFactory.apply(null, defineCache[id]);
                    return loaderCache[id];
                } else {
                    if(systemRequire) {
                        return systemRequire(originalId);
                    } else {
                        throw new Error('No module with ID: ' + id);
                    }
                }
            } else {
                //There is a plugin in play.
                prefix = id.substring(0, index);
                id = id.substring(index + 1, id.length);
    
                plugin = stringRequire(systemRequire, exports, module, prefix, relId);
    
                if (plugin.normalize) {
                    id = plugin.normalize(id, makeNormalize(relId));
                } else {
                    //Normalize the ID normally.
                    id = normalize(id, relId);
                }
    
                if (loaderCache[id]) {
                    return loaderCache[id];
                } else {
                    plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});
    
                    return loaderCache[id];
                }
            }
        };
    
        //Create a define function specific to the module asking for amdefine.
        function define(id, deps, factory) {
            if (Array.isArray(id)) {
                factory = deps;
                deps = id;
                id = undefined;
            } else if (typeof id !== 'string') {
                factory = id;
                id = deps = undefined;
            }
    
            if (deps && !Array.isArray(deps)) {
                factory = deps;
                deps = undefined;
            }
    
            if (!deps) {
                deps = ['require', 'exports', 'module'];
            }
    
            //Set up properties for this module. If an ID, then use
            //internal cache. If no ID, then use the external variables
            //for this node module.
            if (id) {
                //Put the module in deep freeze until there is a
                //require call for it.
                defineCache[id] = [id, deps, factory];
            } else {
                runFactory(id, deps, factory);
            }
        }
    
        //define.require, which has access to all the values in the
        //cache. Useful for AMD modules that all have IDs in the file,
        //but need to finally export a value to node based on one of those
        //IDs.
        define.require = function (id) {
            if (loaderCache[id]) {
                return loaderCache[id];
            }
    
            if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            }
        };
    
        define.amd = {};
    
        return define;
    }
    
    module.exports = amdefine;
    
  provide("amdefine", module.exports);
}(global));

// pakmanager:camelcase
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (str) {
    	str = str.trim();
    
    	if (str.length === 1 || !(/[_.\- ]+/).test(str) ) {
    		if (str[0] === str[0].toLowerCase() && str.slice(1) !== str.slice(1).toLowerCase()) {
    			return str;
    		}
    
    		return str.toLowerCase();
    	}
    
    	return str
    	.replace(/^[_.\- ]+/, '')
    	.toLowerCase()
    	.replace(/[_.\- ]+(\w|$)/g, function (m, p1) {
    		return p1.toUpperCase();
    	});
    };
    
  provide("camelcase", module.exports);
}(global));

// pakmanager:cliui
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var wrap = require('wordwrap'),
      align = {
        right: require('right-align'),
        center: require('center-align')
      },
      top = 0,
      right = 1,
      bottom = 2,
      left = 3
    
    function UI (opts) {
      this.width = opts.width
      this.wrap = opts.wrap
      this.rows = []
    }
    
    UI.prototype.span = function () {
      var cols = this.div.apply(this, arguments)
      cols.span = true
    }
    
    UI.prototype.div = function () {
      if (arguments.length === 0) this.div('')
      if (this.wrap && this._shouldApplyLayoutDSL.apply(this, arguments)) {
        return this._applyLayoutDSL(arguments[0])
      }
    
      var cols = []
    
      for (var i = 0, arg; (arg = arguments[i]) !== undefined; i++) {
        if (typeof arg === 'string') cols.push(this._colFromString(arg))
        else cols.push(arg)
      }
    
      this.rows.push(cols)
      return cols
    }
    
    UI.prototype._shouldApplyLayoutDSL = function () {
      return arguments.length === 1 && typeof arguments[0] === 'string' &&
        /[\t\n]/.test(arguments[0])
    }
    
    UI.prototype._applyLayoutDSL = function (str) {
      var _this = this,
        rows = str.split('\n'),
        leftColumnWidth = 0
    
      // simple heuristic for layout, make sure the
      // second column lines up along the left-hand.
      // don't allow the first column to take up more
      // than 50% of the screen.
      rows.forEach(function (row) {
        var columns = row.split('\t')
        if (columns.length > 1 && columns[0].length > leftColumnWidth) {
          leftColumnWidth = Math.min(
            Math.floor(_this.width * 0.5),
            columns[0].length
          )
        }
      })
    
      // generate a table:
      //  replacing ' ' with padding calculations.
      //  using the algorithmically generated width.
      rows.forEach(function (row) {
        var columns = row.split('\t')
        _this.div.apply(_this, columns.map(function (r, i) {
          return {
            text: r.trim(),
            padding: [0, r.match(/\s*$/)[0].length, 0, r.match(/^\s*/)[0].length],
            width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined
          }
        }))
      })
    
      return this.rows[this.rows.length - 1]
    }
    
    UI.prototype._colFromString = function (str) {
      return {
        text: str
      }
    }
    
    UI.prototype.toString = function () {
      var _this = this,
        lines = []
    
      _this.rows.forEach(function (row, i) {
        _this.rowToString(row, lines)
      })
    
      // don't display any lines with the
      // hidden flag set.
      lines = lines.filter(function (line) {
        return !line.hidden
      })
    
      return lines.map(function (line) {
        return line.text
      }).join('\n')
    }
    
    UI.prototype.rowToString = function (row, lines) {
      var _this = this,
        paddingLeft,
        rrows = this._rasterize(row),
        str = '',
        ts,
        width,
        wrapWidth
    
      rrows.forEach(function (rrow, r) {
        str = ''
        rrow.forEach(function (col, c) {
          ts = '' // temporary string used during alignment/padding.
          width = row[c].width // the width with padding.
          wrapWidth = _this._negatePadding(row[c]) // the width without padding.
    
          for (var i = 0; i < Math.max(wrapWidth, col.length); i++) {
            ts += col.charAt(i) || ' '
          }
    
          // align the string within its column.
          if (row[c].align && row[c].align !== 'left' && _this.wrap) {
            ts = align[row[c].align](ts.trim() + '\n' + new Array(wrapWidth + 1).join(' '))
              .split('\n')[0]
            if (ts.length < wrapWidth) ts += new Array(width - ts.length).join(' ')
          }
    
          // add left/right padding and print string.
          paddingLeft = (row[c].padding || [0, 0, 0, 0])[left]
          if (paddingLeft) str += new Array(row[c].padding[left] + 1).join(' ')
          str += ts
          if (row[c].padding && row[c].padding[right]) str += new Array(row[c].padding[right] + 1).join(' ')
    
          // if prior row is span, try to render the
          // current row on the prior line.
          if (r === 0 && lines.length > 0) {
            str = _this._renderInline(str, lines[lines.length - 1], paddingLeft)
          }
        })
    
        // remove trailing whitespace.
        lines.push({
          text: str.replace(/ +$/, ''),
          span: row.span
        })
      })
    
      return lines
    }
    
    // if the full 'source' can render in
    // the target line, do so.
    UI.prototype._renderInline = function (source, previousLine, paddingLeft) {
      var target = previousLine.text,
        str = ''
    
      if (!previousLine.span) return source
    
      // if we're not applying wrapping logic,
      // just always append to the span.
      if (!this.wrap) {
        previousLine.hidden = true
        return target + source
      }
    
      for (var i = 0, tc, sc; i < Math.max(source.length, target.length); i++) {
        tc = target.charAt(i) || ' '
        sc = source.charAt(i) || ' '
        // we tried to overwrite a character in the other string.
        if (tc !== ' ' && sc !== ' ') return source
        // there is not enough whitespace to maintain padding.
        if (sc !== ' ' && i < paddingLeft + target.length) return source
        // :thumbsup:
        if (tc === ' ') str += sc
        else str += tc
      }
    
      previousLine.hidden = true
    
      return str
    }
    
    UI.prototype._rasterize = function (row) {
      var _this = this,
        i,
        rrow,
        rrows = [],
        widths = this._columnWidths(row),
        wrapped
    
      // word wrap all columns, and create
      // a data-structure that is easy to rasterize.
      row.forEach(function (col, c) {
        // leave room for left and right padding.
        col.width = widths[c]
        if (_this.wrap) wrapped = wrap.hard(_this._negatePadding(col))(col.text).split('\n')
        else wrapped = col.text.split('\n')
    
        // add top and bottom padding.
        if (col.padding) {
          for (i = 0; i < (col.padding[top] || 0); i++) wrapped.unshift('')
          for (i = 0; i < (col.padding[bottom] || 0); i++) wrapped.push('')
        }
    
        wrapped.forEach(function (str, r) {
          if (!rrows[r]) rrows.push([])
    
          rrow = rrows[r]
    
          for (var i = 0; i < c; i++) {
            if (rrow[i] === undefined) rrow.push('')
          }
          rrow.push(str)
        })
      })
    
      return rrows
    }
    
    UI.prototype._negatePadding = function (col) {
      var wrapWidth = col.width
      if (col.padding) wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0)
      return wrapWidth
    }
    
    UI.prototype._columnWidths = function (row) {
      var _this = this,
        widths = [],
        unset = row.length,
        unsetWidth,
        remainingWidth = this.width
    
      // column widths can be set in config.
      row.forEach(function (col, i) {
        if (col.width) {
          unset--
          widths[i] = col.width
          remainingWidth -= col.width
        } else {
          widths[i] = undefined
        }
      })
    
      // any unset widths should be calculated.
      if (unset) unsetWidth = Math.floor(remainingWidth / unset)
      widths.forEach(function (w, i) {
        if (!_this.wrap) widths[i] = row[i].width || row[i].text.length
        else if (w === undefined) widths[i] = Math.max(unsetWidth, _minWidth(row[i]))
      })
    
      return widths
    }
    
    // calculates the minimum width of
    // a column, based on padding preferences.
    function _minWidth (col) {
      var padding = col.padding || []
    
      return 1 + (padding[left] || 0) + (padding[right] || 0)
    }
    
    module.exports = function (opts) {
      opts = opts || {}
    
      return new UI({
        width: (opts || {}).width || 80,
        wrap: typeof opts.wrap === 'boolean' ? opts.wrap : true
      })
    }
    
  provide("cliui", module.exports);
}(global));

// pakmanager:decamelize
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (str, sep) {
    	if (typeof str !== 'string') {
    		throw new TypeError('Expected a string');
    	}
    
    	return str.replace(/([a-z\d])([A-Z])/g, '$1' + (sep || '_') + '$2').toLowerCase();
    };
    
  provide("decamelize", module.exports);
}(global));

// pakmanager:window-size
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * window-size <https://github.com/jonschlinkert/window-size>
     *
     * Copyright (c) 2014-2015 Jon Schlinkert
     * Licensed under the MIT license.
     */
    
    const tty = require('tty');
    
    module.exports = (function() {
      var width;
      var height;
    
      if(tty.isatty(1) && tty.isatty(2)) {
        if(process.stdout.getWindowSize) {
          width = process.stdout.getWindowSize(1)[0];
          height = process.stdout.getWindowSize(1)[1];
        } else if (tty.getWindowSize) {
          width = tty.getWindowSize()[1];
          height = tty.getWindowSize()[0];
        } else if (process.stdout.columns && process.stdout.rows) {
          height = process.stdout.columns;
          width = process.stdout.rows;
        }
      } else {
        new Error('window-size could not get size with tty or process.stdout.');
      }
    
      return {height: height, width: width};
    })();
  provide("window-size", module.exports);
}(global));

// pakmanager:topo/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports = module.exports = internals.Topo = function () {
    
        this._items = [];
        this.nodes = [];
    };
    
    
    internals.Topo.prototype.add = function (nodes, options) {
    
        var self = this;
    
        options = options || {};
    
        // Validate rules
    
        var before = [].concat(options.before || []);
        var after = [].concat(options.after || []);
        var group = options.group || '?';
    
        Hoek.assert(before.indexOf(group) === -1, 'Item cannot come before itself:', group);
        Hoek.assert(before.indexOf('?') === -1, 'Item cannot come before unassociated items');
        Hoek.assert(after.indexOf(group) === -1, 'Item cannot come after itself:', group);
        Hoek.assert(after.indexOf('?') === -1, 'Item cannot come after unassociated items');
    
        ([].concat(nodes)).forEach(function (node, i) {
    
            var item = {
                seq: self._items.length,
                before: before,
                after: after,
                group: group,
                node: node
            };
    
            self._items.push(item);
        });
    
        // Insert event
    
        var error = this._sort();
        Hoek.assert(!error, 'item', (group !== '?' ? 'added into group ' + group : ''), 'created a dependencies error');
    
        return this.nodes;
    };
    
    
    internals.Topo.prototype._sort = function () {
    
        // Construct graph
    
        var groups = {};
        var graph = {};
        var graphAfters = {};
    
        for (var i = 0, il = this._items.length; i < il; ++i) {
            var item = this._items[i];
            var seq = item.seq;                         // Unique across all items
            var group = item.group;
    
            // Determine Groups
    
            groups[group] = groups[group] || [];
            groups[group].push(seq);
    
            // Build intermediary graph using 'before'
    
            graph[seq] = [item.before];
    
            // Build second intermediary graph with 'after'
    
            var after = item.after;
            for (var j = 0, jl = after.length; j < jl; ++j) {
                graphAfters[after[j]] = (graphAfters[after[j]] || []).concat(seq);
            }
        }
    
        // Expand intermediary graph
    
        var graphNodes = Object.keys(graph);
        for (i = 0, il = graphNodes.length; i < il; ++i) {
            var node = graphNodes[i];
            var expandedGroups = [];
    
            var graphNodeItems = Object.keys(graph[node]);
            for (j = 0, jl = graphNodeItems.length; j < jl; ++j) {
                var group = graph[node][graphNodeItems[j]];
                groups[group] = groups[group] || [];
                groups[group].forEach(function (d) {
    
                    expandedGroups.push(d);
                });
            }
            graph[node] = expandedGroups;
        }
    
        // Merge intermediary graph using graphAfters into final graph
    
        var afterNodes = Object.keys(graphAfters);
        for (i = 0, il = afterNodes.length; i < il; ++i) {
            var group = afterNodes[i];
    
            if (groups[group]) {
                for (j = 0, jl = groups[group].length; j < jl; ++j) {
                    var node = groups[group][j];
                    graph[node] = graph[node].concat(graphAfters[group]);
                }
            }
        }
    
        // Compile ancestors
    
        var ancestors = {};
        graphNodes = Object.keys(graph);
        for (i = 0, il = graphNodes.length; i < il; ++i) {
            var node = graphNodes[i];
            var children = graph[node];
    
            for (j = 0, jl = children.length; j < jl; ++j) {
                ancestors[children[j]] = (ancestors[children[j]] || []).concat(node);
            }
        }
    
        // Topo sort
    
        var visited = {};
        var sorted = [];
    
        for (i = 0, il = this._items.length; i < il; ++i) {
            var next = i;
    
            if (ancestors[i]) {
                next = null;
                for (j = 0, jl = this._items.length; j < jl; ++j) {
                    if (visited[j] === true) {
                        continue;
                    }
    
                    if (!ancestors[j]) {
                        ancestors[j] = [];
                    }
    
                    var shouldSeeCount = ancestors[j].length;
                    var seenCount = 0;
                    for (var l = 0, ll = shouldSeeCount; l < ll; ++l) {
                        if (sorted.indexOf(ancestors[j][l]) >= 0) {
                            ++seenCount;
                        }
                    }
    
                    if (seenCount === shouldSeeCount) {
                        next = j;
                        break;
                    }
                }
            }
    
            if (next !== null) {
                next = next.toString();         // Normalize to string TODO: replace with seq
                visited[next] = true;
                sorted.push(next);
            }
        }
    
        if (sorted.length !== this._items.length) {
            return new Error('Invalid dependencies');
        }
    
        var seqIndex = {};
        this._items.forEach(function (item) {
    
            seqIndex[item.seq] = item;
        });
    
        var sortedNodes = [];
        this._items = sorted.map(function (value) {
    
            var item = seqIndex[value];
            sortedNodes.push(item.node);
            return item;
        });
    
        this.nodes = sortedNodes;
    };
    
  provide("topo/lib", module.exports);
}(global));

// pakmanager:topo
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('topo/lib');
  provide("topo", module.exports);
}(global));

// pakmanager:isemail/lib/isemail
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * To validate an email address according to RFCs 5321, 5322 and others
     *
     * Copyright  2008-2011, Dominic Sayers
     * Test schema documentation Copyright  2011, Daniel Marschall
     * Port for Node.js Copyright  2013, GlobeSherpa
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     *   - Redistributions of source code must retain the above copyright notice,
     *     this list of conditions and the following disclaimer.
     *   - Redistributions in binary form must reproduce the above copyright notice,
     *     this list of conditions and the following disclaimer in the documentation
     *     and/or other materials provided with the distribution.
     *   - Neither the name of Dominic Sayers nor the names of its contributors may
     *     be used to endorse or promote products derived from this software without
     *     specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     * POSSIBILITY OF SUCH DAMAGE.
     *
     * @author      Dominic Sayers <dominic@sayers.cc>
     * @author      Eli Skeggs <eskeggs@globesherpa.com>
     * @copyright   2008-2011 Dominic Sayers
     * @copyright   2013-2014 GlobeSherpa
     * @license     http://www.opensource.org/licenses/bsd-license.php BSD License
     * @link        http://www.dominicsayers.com/isemail
     * @link        https://github.com/globesherpa/isemail
     * @version     1.1.1 - Optimization pass, simplify constants, style, dead code.
     */
    
    // lazy-loaded
    var dns, HAS_REQUIRE = typeof require !== 'undefined';
    
    // categories
    var ISEMAIL_VALID_CATEGORY = 1;
    var ISEMAIL_DNSWARN = 7;
    var ISEMAIL_RFC5321 = 15;
    var ISEMAIL_CFWS = 31;
    var ISEMAIL_DEPREC = 63;
    var ISEMAIL_RFC5322 = 127;
    var ISEMAIL_ERR = 255;
    
    // diagnoses
    // address is valid
    var ISEMAIL_VALID = 0;
    // address is valid but a DNS check was not successful
    var ISEMAIL_DNSWARN_NO_MX_RECORD = 5;
    var ISEMAIL_DNSWARN_NO_RECORD = 6;
    // address is valid for SMTP but has unusual elements
    var ISEMAIL_RFC5321_TLD = 9;
    var ISEMAIL_RFC5321_TLDNUMERIC = 10;
    var ISEMAIL_RFC5321_QUOTEDSTRING = 11;
    var ISEMAIL_RFC5321_ADDRESSLITERAL = 12;
    var ISEMAIL_RFC5321_IPV6DEPRECATED = 13;
    // address is valid within the message but cannot be used unmodified for the
    // envelope
    var ISEMAIL_CFWS_COMMENT = 17;
    var ISEMAIL_CFWS_FWS = 18;
    // address contains deprecated elements but may still be valid in restricted
    // contexts
    var ISEMAIL_DEPREC_LOCALPART = 33;
    var ISEMAIL_DEPREC_FWS = 34;
    var ISEMAIL_DEPREC_QTEXT = 35;
    var ISEMAIL_DEPREC_QP = 36;
    var ISEMAIL_DEPREC_COMMENT = 37;
    var ISEMAIL_DEPREC_CTEXT = 38;
    var ISEMAIL_DEPREC_CFWS_NEAR_AT = 49;
    // the address is only valid according to the broad definition of RFC 5322, but
    // otherwise invalid
    var ISEMAIL_RFC5322_DOMAIN = 65;
    var ISEMAIL_RFC5322_TOOLONG = 66;
    var ISEMAIL_RFC5322_LOCAL_TOOLONG = 67;
    var ISEMAIL_RFC5322_DOMAIN_TOOLONG = 68;
    var ISEMAIL_RFC5322_LABEL_TOOLONG = 69;
    var ISEMAIL_RFC5322_DOMAINLITERAL = 70;
    var ISEMAIL_RFC5322_DOMLIT_OBSDTEXT = 71;
    var ISEMAIL_RFC5322_IPV6_GRPCOUNT = 72;
    var ISEMAIL_RFC5322_IPV6_2X2XCOLON = 73;
    var ISEMAIL_RFC5322_IPV6_BADCHAR = 74;
    var ISEMAIL_RFC5322_IPV6_MAXGRPS = 75;
    var ISEMAIL_RFC5322_IPV6_COLONSTRT = 76;
    var ISEMAIL_RFC5322_IPV6_COLONEND = 77;
    // address is invalid for any purpose
    var ISEMAIL_ERR_EXPECTING_DTEXT = 129;
    var ISEMAIL_ERR_NOLOCALPART = 130;
    var ISEMAIL_ERR_NODOMAIN = 131;
    var ISEMAIL_ERR_CONSECUTIVEDOTS = 132;
    var ISEMAIL_ERR_ATEXT_AFTER_CFWS = 133;
    var ISEMAIL_ERR_ATEXT_AFTER_QS = 134;
    var ISEMAIL_ERR_ATEXT_AFTER_DOMLIT = 135;
    var ISEMAIL_ERR_EXPECTING_QPAIR = 136;
    var ISEMAIL_ERR_EXPECTING_ATEXT = 137;
    var ISEMAIL_ERR_EXPECTING_QTEXT = 138;
    var ISEMAIL_ERR_EXPECTING_CTEXT = 139;
    var ISEMAIL_ERR_BACKSLASHEND = 140;
    var ISEMAIL_ERR_DOT_START = 141;
    var ISEMAIL_ERR_DOT_END = 142;
    var ISEMAIL_ERR_DOMAINHYPHENSTART = 143;
    var ISEMAIL_ERR_DOMAINHYPHENEND = 144;
    var ISEMAIL_ERR_UNCLOSEDQUOTEDSTR = 145;
    var ISEMAIL_ERR_UNCLOSEDCOMMENT = 146;
    var ISEMAIL_ERR_UNCLOSEDDOMLIT = 147;
    var ISEMAIL_ERR_FWS_CRLF_X2 = 148;
    var ISEMAIL_ERR_FWS_CRLF_END = 149;
    var ISEMAIL_ERR_CR_NO_LF = 150;
    var ISEMAIL_ERR_UNKNOWN_TLD = 160;
    var ISEMAIL_ERR_TOOSHORT_DOMAIN = 161;
    
    // function control
    var THRESHOLD = 16;
    // email parts
    var COMPONENT_LOCALPART = 0;
    var COMPONENT_DOMAIN = 1;
    var COMPONENT_LITERAL = 2;
    var CONTEXT_COMMENT = 3;
    var CONTEXT_FWS = 4;
    var CONTEXT_QUOTEDSTRING = 5;
    var CONTEXT_QUOTEDPAIR = 6;
    
    // US-ASCII visible characters not valid for atext
    // (http://tools.ietf.org/html/rfc5322#section-3.2.3)
    var SPECIALS = '()<>[]:;@\\,."';
    
    function optimizeLookup(string) {
      var body = '', min = 0x100, max = 0, lookup = new Array(min);
      for (var i = min - 1; i >= 0; i--) {
        lookup[i] = false;
      }
      for (var i = 0; i < string.length; i++) {
        var chr = string.charCodeAt(i);
        if (chr < min) {
          min = chr;
        }
        if (chr > max) {
          max = chr;
        }
        lookup[chr] = true;
      }
      lookup.length = max;
      var body = 'var lookup = ' + JSON.stringify(lookup) + ';\n';
      body += 'return function(code) {\n';
      body += '  if (code < ' + min + ' || code > ' + max + ') {\n';
      body += '    return false;\n';
      body += '  }\n';
      body += '  return lookup[code];\n';
      body += '}';
      return (new Function(body))();
    }
    
    var specialsLookup = optimizeLookup(SPECIALS);
    
    // matches valid IPv4 addresses from the end of a string
    var IPv4_REGEX =
      /\b(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/;
    var IPv6_REGEX = /^[a-fA-F\d]{0,4}$/;
    var IPv6_REGEX_TEST = IPv6_REGEX.test.bind(IPv6_REGEX);
    
    var hasOwn = Object.prototype.hasOwnProperty;
    
    /**
     * Get the largest number in the array.
     *
     * Returns -Infinity if the array is empty.
     *
     * @param {Array.<number>} array The array to scan.
     * @return {number} The largest number contained.
     */
    function maxValue(array) {
      var v = -Infinity, i = 0, n = array.length;
    
      for (; i < n; i++) {
        if (array[i] > v) {
          v = array[i];
        }
      }
    
      return v;
    }
    
    /**
     * Check that an email address conforms to RFCs 5321, 5322 and others
     *
     * As of Version 3.0, we are now distinguishing clearly between a Mailbox
     * as defined by RFC 5321 and an addr-spec as defined by RFC 5322. Depending
     * on the context, either can be regarded as a valid email address. The
     * RFC 5321 Mailbox specification is more restrictive (comments, white space
     * and obsolete forms are not allowed).
     *
     * @param {string} email The email address to check.
     * @param {boolean} checkDNS If true then will check DNS for MX records. If true
     *   this isEmail _will_ be asynchronous.
     * @param {*} errorLevel Determines the boundary between valid and invalid
     *   addresses. Status codes above this number will be returned as-is, status
     *   codes below will be returned as ISEMAIL_VALID. Thus the calling program can
     *   simply look for ISEMAIL_VALID if it is only interested in whether an
     *   address is valid or not. The errorLevel will determine how "picky"
     *   isEmail() is about the address. If omitted or passed as false then
     *   isEmail() will return true or false rather than an integer error or
     *   warning. NB Note the difference between errorLevel = false and
     *   errorLevel = 0.
     * @return {*}
     */
    function isEmail(email, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      options || (options = {});
    
      var threshold, diagnose;
      if (typeof options.errorLevel === 'number') {
        diagnose = true;
        threshold = options.errorLevel;
      } else {
        diagnose = !!options.errorLevel;
        threshold = ISEMAIL_VALID;
      }
    
      if (options.tldWhitelist && typeof options.tldWhitelist !== 'object') {
        throw new TypeError('expected array or object tldWhitelist');
      }
    
      if (options.minDomainAtoms && (options.minDomainAtoms !==
          ((+options.minDomainAtoms) | 0) || options.minDomainAtoms < 0)) {
        throw new TypeError('expected positive integer minDomainAtoms');
      }
    
      var maxResult = ISEMAIL_VALID;
    
      function updateResult(value) {
        if (value > maxResult) {
          maxResult = value;
        }
      }
    
      var context = {
        now: COMPONENT_LOCALPART,
        prev: COMPONENT_LOCALPART,
        stack: [COMPONENT_LOCALPART]
      };
    
      var token = '', prevToken = '', charCode = 0;
      var parseData = {local: '', domain: ''};
      var atomList = {local: [''], domain: ['']};
    
      var elementCount = 0, elementLength = 0, crlfCount = 0;
      var hyphenFlag = false, assertEnd = false;
    
      for (var i = 0; i < email.length; i++) {
        token = email[i];
    
        switch (context.now) {
        // local-part
        case COMPONENT_LOCALPART:
          // http://tools.ietf.org/html/rfc5322#section-3.4.1
          //   local-part      =   dot-atom / quoted-string / obs-local-part
          //
          //   dot-atom        =   [CFWS] dot-atom-text [CFWS]
          //
          //   dot-atom-text   =   1*atext *("." 1*atext)
          //
          //   quoted-string   =   [CFWS]
          //                       DQUOTE *([FWS] qcontent) [FWS] DQUOTE
          //                       [CFWS]
          //
          //   obs-local-part  =   word *("." word)
          //
          //   word            =   atom / quoted-string
          //
          //   atom            =   [CFWS] 1*atext [CFWS]
          switch (token) {
          // comment
          case '(':
            if (elementLength === 0) {
              // comments are OK at the beginning of an element
              updateResult(elementCount === 0 ? ISEMAIL_CFWS_COMMENT :
                ISEMAIL_DEPREC_COMMENT);
            } else {
              updateResult(ISEMAIL_CFWS_COMMENT);
               // can't start a comment in an element, should be end
              assertEnd = true;
            }
            context.stack.push(context.now);
            context.now = CONTEXT_COMMENT;
            break;
          // next dot-atom element
          case '.':
            if (elementLength === 0) {
              // another dot, already?
              updateResult(elementCount === 0 ? ISEMAIL_ERR_DOT_START :
                ISEMAIL_ERR_CONSECUTIVEDOTS);
            } else {
              // the entire local-part can be a quoted string for RFC 5321
              // if it's just one atom that is quoted then it's an RFC 5322 obsolete
              // form
              if (assertEnd) {
                updateResult(ISEMAIL_DEPREC_LOCALPART);
              }
    
              // CFWS & quoted strings are OK again now we're at the beginning of an
              // element (although they are obsolete forms)
              assertEnd = false;
              elementLength = 0;
              elementCount++;
              parseData.local += token;
              atomList.local[elementCount] = ''; // TODO: push?
            }
            break;
          // quoted string
          case '"':
            if (elementLength === 0) {
              // the entire local-part can be a quoted string for RFC 5321
              // if it's just one atom that is quoted then it's an RFC 5322 obsolete
              // form
              updateResult(elementCount === 0 ? ISEMAIL_RFC5321_QUOTEDSTRING :
                ISEMAIL_DEPREC_LOCALPART);
    
              parseData.local += token;
              atomList.local[elementCount] += token;
              elementLength++;
              assertEnd = true; // quoted string must be the entire element
              context.stack.push(context.now);
              context.now = CONTEXT_QUOTEDSTRING;
            } else {
              updateResult(ISEMAIL_ERR_EXPECTING_ATEXT);
            }
            break;
          // folding white space
          case '\r':
            if ((++i === email.length) || email[i] !== '\n') {
              // fatal error
              updateResult(ISEMAIL_ERR_CR_NO_LF);
              break;
            }
          case ' ':
          case '\t':
            if (elementLength === 0) {
              updateResult(elementCount === 0 ? ISEMAIL_CFWS_FWS :
                ISEMAIL_DEPREC_FWS);
            } else {
              // we can't start FWS in the middle of an element, better be end
              assertEnd = true;
            }
    
            context.stack.push(context.now);
            context.now = CONTEXT_FWS;
            prevToken = token;
            break;
          // @
          case '@':
            // at this point we should have a valid local-part
            /* istanbul ignore next: logically unreachable */
            if (context.stack.length !== 1) {
              throw new Error('unexpected item on context stack');
            }
    
            if (parseData.local.length === 0) {
              // fatal error
              updateResult(ISEMAIL_ERR_NOLOCALPART);
            } else if (elementLength === 0) {
              // fatal error
              updateResult(ISEMAIL_ERR_DOT_END);
            // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.1
            //   the maximum total length of a user name or other local-part is 64
            //   octets
            } else if (parseData.local.length > 64) {
              updateResult(ISEMAIL_RFC5322_LOCAL_TOOLONG);
            // http://tools.ietf.org/html/rfc5322#section-3.4.1
            //   comments and folding white space
            //   SHOULD NOT be used around the "@" in the addr-spec
            //
            // http://tools.ietf.org/html/rfc2119
            // 4. SHOULD NOT  this phrase, or the phrase "NOT RECOMMENDED" mean that
            //    there may exist valid reasons in particular circumstances when the
            //    particular behavior is acceptable or even useful, but the full
            //    implications should be understood and the case carefully weighed
            //    before implementing any behavior described with this label
            } else if ((context.prev === CONTEXT_COMMENT) ||
                (context.prev === CONTEXT_FWS)) {
              updateResult(ISEMAIL_DEPREC_CFWS_NEAR_AT);
            }
    
            // clear everything down for the domain parsing
            context.now = COMPONENT_DOMAIN; // where we are
            context.stack[0] = COMPONENT_DOMAIN; // where we have been
            elementCount = 0;
            elementLength = 0;
            assertEnd = false; // CFWS can only appear at the end of the element
            break;
          // atext
          default:
            // http://tools.ietf.org/html/rfc5322#section-3.2.3
            //    atext = ALPHA / DIGIT / ; Printable US-ASCII
            //            "!" / "#" /     ;  characters not including
            //            "$" / "%" /     ;  specials.  Used for atoms.
            //            "&" / "'" /
            //            "*" / "+" /
            //            "-" / "/" /
            //            "=" / "?" /
            //            "^" / "_" /
            //            "`" / "{" /
            //            "|" / "}" /
            //            "~"
            if (assertEnd) {
              // we have encountered atext where it is no longer valid
              switch (context.prev) {
              case CONTEXT_COMMENT:
              case CONTEXT_FWS:
                updateResult(ISEMAIL_ERR_ATEXT_AFTER_CFWS);
                break;
              case CONTEXT_QUOTEDSTRING:
                updateResult(ISEMAIL_ERR_ATEXT_AFTER_QS);
                break;
              /* istanbul ignore next: logically unreachable */
              default:
                throw new Error('more atext found where none is allowed, ' +
                  'but unrecognized prev context: ' + context.prev);
              }
            } else {
              context.prev = context.now;
              charCode = token.charCodeAt(0);
    
              if (charCode < 33 || charCode > 126 || charCode === 10 ||
                  specialsLookup(charCode)) {
                // fatal error
                updateResult(ISEMAIL_ERR_EXPECTING_ATEXT);
              }
    
              parseData.local += token;
              atomList.local[elementCount] += token;
              elementLength++;
            }
          }
          break;
        case COMPONENT_DOMAIN:
          // http://tools.ietf.org/html/rfc5322#section-3.4.1
          //   domain          =   dot-atom / domain-literal / obs-domain
          //
          //   dot-atom        =   [CFWS] dot-atom-text [CFWS]
          //
          //   dot-atom-text   =   1*atext *("." 1*atext)
          //
          //   domain-literal  =   [CFWS] "[" *([FWS] dtext) [FWS] "]" [CFWS]
          //
          //   dtext           =   %d33-90 /          ; Printable US-ASCII
          //                       %d94-126 /         ;  characters not including
          //                       obs-dtext          ;  "[", "]", or "\"
          //
          //   obs-domain      =   atom *("." atom)
          //
          //   atom            =   [CFWS] 1*atext [CFWS]
    
          // http://tools.ietf.org/html/rfc5321#section-4.1.2
          //   Mailbox        = Local-part "@" ( Domain / address-literal )
          //
          //   Domain         = sub-domain *("." sub-domain)
          //
          //   address-literal  = "[" ( IPv4-address-literal /
          //                    IPv6-address-literal /
          //                    General-address-literal ) "]"
          //                    ; See Section 4.1.3
    
          // http://tools.ietf.org/html/rfc5322#section-3.4.1
          //      Note: A liberal syntax for the domain portion of addr-spec is
          //      given here.  However, the domain portion contains addressing
          //      information specified by and used in other protocols (e.g.,
          //      [RFC1034], [RFC1035], [RFC1123], [RFC5321]).  It is therefore
          //      incumbent upon implementations to conform to the syntax of
          //      addresses for the context in which they are used.
          // is_email() author's note: it's not clear how to interpret this in
          // the context of a general email address validator. The conclusion I
          // have reached is this: "addressing information" must comply with
          // RFC 5321 (and in turn RFC 1035), anything that is "semantically
          // invisible" must comply only with RFC 5322.
          switch (token) {
          // comment
          case '(':
            if (elementLength === 0) {
              // comments at the start of the domain are deprecated in the text
              // comments at the start of a subdomain are obs-domain
              // (http://tools.ietf.org/html/rfc5322#section-3.4.1)
              updateResult(elementCount === 0 ? ISEMAIL_DEPREC_CFWS_NEAR_AT :
                ISEMAIL_DEPREC_COMMENT);
            } else {
              updateResult(ISEMAIL_CFWS_COMMENT);
              assertEnd = true; // can't start a comment mid-element, better be end
            }
    
            context.stack.push(context.now);
            context.now = CONTEXT_COMMENT;
            break;
          // next dot-atom element
          case '.':
            if (elementLength === 0) {
              // another dot, already? fatal error
              updateResult(elementCount === 0 ? ISEMAIL_ERR_DOT_START :
                ISEMAIL_ERR_CONSECUTIVEDOTS);
            } else if (hyphenFlag) {
              // previous subdomain ended in a hyphen
              updateResult(ISEMAIL_ERR_DOMAINHYPHENEND); // fatal error
            } else if (elementLength > 63) {
              // Nowhere in RFC 5321 does it say explicitly that the
              // domain part of a Mailbox must be a valid domain according
              // to the DNS standards set out in RFC 1035, but this *is*
              // implied in several places. For instance, wherever the idea
              // of host routing is discussed the RFC says that the domain
              // must be looked up in the DNS. This would be nonsense unless
              // the domain was designed to be a valid DNS domain. Hence we
              // must conclude that the RFC 1035 restriction on label length
              // also applies to RFC 5321 domains.
              //
              // http://tools.ietf.org/html/rfc1035#section-2.3.4
              // labels          63 octets or less
    
              updateResult(ISEMAIL_RFC5322_LABEL_TOOLONG);
            }
    
            // CFWS is OK again now we're at the beginning of an element (although
            // it may be obsolete CFWS)
            assertEnd = false;
            elementLength = 0;
            elementCount++;
            atomList.domain[elementCount] = '';
            parseData.domain += token;
    
            break;
          // domain literal
          case '[':
            if (parseData.domain.length === 0) {
              // domain literal must be the only component
              assertEnd = true;
              elementLength++;
              context.stack.push(context.now);
              context.now = COMPONENT_LITERAL;
              parseData.domain += token;
              atomList.domain[elementCount] += token;
              parseData.literal = '';
            } else {
              // fatal error
              updateResult(ISEMAIL_ERR_EXPECTING_ATEXT);
            }
            break;
          // folding white space
          case '\r':
            if ((++i === email.length) || email[i] !== '\n') {
              // fatal error
              updateResult(ISEMAIL_ERR_CR_NO_LF);
              break;
            }
          case ' ':
          case '\t':
            if (elementLength === 0) {
              updateResult(elementCount === 0 ? ISEMAIL_DEPREC_CFWS_NEAR_AT :
                ISEMAIL_DEPREC_FWS);
            } else {
              // we can't start FWS in the middle of an element, so this better be
              // the end
              updateResult(ISEMAIL_CFWS_FWS);
              assertEnd = true;
            }
    
            context.stack.push(context.now);
            context.now = CONTEXT_FWS;
            prevToken = token;
            break;
          // atext
          default:
            // RFC 5322 allows any atext...
            // http://tools.ietf.org/html/rfc5322#section-3.2.3
            //    atext = ALPHA / DIGIT / ; Printable US-ASCII
            //            "!" / "#" /     ;  characters not including
            //            "$" / "%" /     ;  specials.  Used for atoms.
            //            "&" / "'" /
            //            "*" / "+" /
            //            "-" / "/" /
            //            "=" / "?" /
            //            "^" / "_" /
            //            "`" / "{" /
            //            "|" / "}" /
            //            "~"
    
            // But RFC 5321 only allows letter-digit-hyphen to comply with DNS rules
            //   (RFCs 1034 & 1123)
            // http://tools.ietf.org/html/rfc5321#section-4.1.2
            //   sub-domain     = Let-dig [Ldh-str]
            //
            //   Let-dig        = ALPHA / DIGIT
            //
            //   Ldh-str        = *( ALPHA / DIGIT / "-" ) Let-dig
            //
            if (assertEnd) {
              // we have encountered atext where it is no longer valid
              switch (context.prev) {
              case CONTEXT_COMMENT:
              case CONTEXT_FWS:
                updateResult(ISEMAIL_ERR_ATEXT_AFTER_CFWS);
                break;
              case COMPONENT_LITERAL:
                updateResult(ISEMAIL_ERR_ATEXT_AFTER_DOMLIT);
                break;
              /* istanbul ignore next: logically unreachable */
              default:
                throw new Error('more atext found where none is allowed, ' +
                  'but unrecognized prev context: ' + context.prev);
              }
            }
    
            charCode = token.charCodeAt(0);
            // assume this token isn't a hyphen unless we discover it is
            hyphenFlag = false;
    
            if (charCode < 33 || charCode > 126 || specialsLookup(charCode)) {
              // fatal error
              updateResult(ISEMAIL_ERR_EXPECTING_ATEXT);
            } else if (token === '-') {
              if (elementLength === 0) {
                // hyphens can't be at the beginning of a subdomain
                updateResult(ISEMAIL_ERR_DOMAINHYPHENSTART); // fatal error
              }
    
              hyphenFlag = true;
            } else if (!((charCode > 47 && charCode < 58) ||
                         (charCode > 64 && charCode < 91) ||
                         (charCode > 96 && charCode < 123))) {
              // not an RFC 5321 subdomain, but still OK by RFC 5322
              updateResult(ISEMAIL_RFC5322_DOMAIN);
            }
    
            parseData.domain += token;
            atomList.domain[elementCount] += token;
            elementLength++;
          }
          break;
        // domain literal
        case COMPONENT_LITERAL:
          // http://tools.ietf.org/html/rfc5322#section-3.4.1
          //   domain-literal  =   [CFWS] "[" *([FWS] dtext) [FWS] "]" [CFWS]
          //
          //   dtext           =   %d33-90 /          ; Printable US-ASCII
          //                       %d94-126 /         ;  characters not including
          //                       obs-dtext          ;  "[", "]", or "\"
          //
          //   obs-dtext       =   obs-NO-WS-CTL / quoted-pair
          switch (token) {
          // end of domain literal
          case ']':
            if (maxResult < ISEMAIL_DEPREC) {
              // Could be a valid RFC 5321 address literal, so let's check
    
              // http://tools.ietf.org/html/rfc5321#section-4.1.2
              //   address-literal  = "[" ( IPv4-address-literal /
              //                    IPv6-address-literal /
              //                    General-address-literal ) "]"
              //                    ; See Section 4.1.3
              //
              // http://tools.ietf.org/html/rfc5321#section-4.1.3
              //   IPv4-address-literal  = Snum 3("."  Snum)
              //
              //   IPv6-address-literal  = "IPv6:" IPv6-addr
              //
              //   General-address-literal  = Standardized-tag ":" 1*dcontent
              //
              //   Standardized-tag  = Ldh-str
              //                     ; Standardized-tag MUST be specified in a
              //                     ; Standards-Track RFC and registered with IANA
              //
              //   dcontent      = %d33-90 / ; Printable US-ASCII
              //                 %d94-126 ; excl. "[", "\", "]"
              //
              //   Snum          = 1*3DIGIT
              //                 ; representing a decimal integer
              //                 ; value in the range 0 through 255
              //
              //   IPv6-addr     = IPv6-full / IPv6-comp / IPv6v4-full / IPv6v4-comp
              //
              //   IPv6-hex      = 1*4HEXDIG
              //
              //   IPv6-full     = IPv6-hex 7(":" IPv6-hex)
              //
              //   IPv6-comp     = [IPv6-hex *5(":" IPv6-hex)] "::"
              //                 [IPv6-hex *5(":" IPv6-hex)]
              //                 ; The "::" represents at least 2 16-bit groups of
              //                 ; zeros.  No more than 6 groups in addition to the
              //                 ; "::" may be present.
              //
              //   IPv6v4-full   = IPv6-hex 5(":" IPv6-hex) ":" IPv4-address-literal
              //
              //   IPv6v4-comp   = [IPv6-hex *3(":" IPv6-hex)] "::"
              //                 [IPv6-hex *3(":" IPv6-hex) ":"]
              //                 IPv4-address-literal
              //                 ; The "::" represents at least 2 16-bit groups of
              //                 ; zeros.  No more than 4 groups in addition to the
              //                 ; "::" and IPv4-address-literal may be present.
              //
              // is_email() author's note: We can't use ip2long() to validate
              // IPv4 addresses because it accepts abbreviated addresses
              // (xxx.xxx.xxx), expanding the last group to complete the address.
              // filter_var() validates IPv6 address inconsistently (up to PHP 5.3.3
              // at least) -- see http://bugs.php.net/bug.php?id=53236 for example
    
              // TODO: var here?
              var maxGroups = 8, matchesIP, index = false;
              var addressLiteral = parseData.literal;
    
              // maybe extract IPv4 part from the end of the address-literal
              if (matchesIP = IPv4_REGEX.exec(addressLiteral)) {
                if ((index = matchesIP.index) !== 0) {
                  // convert IPv4 part to IPv6 format for futher testing
                  addressLiteral = addressLiteral.slice(0, matchesIP.index) + '0:0';
                }
              }
    
              if (index === 0) {
                // nothing there except a valid IPv4 address, so...
                updateResult(ISEMAIL_RFC5321_ADDRESSLITERAL);
              } else if (addressLiteral.slice(0, 5).toLowerCase() !== 'ipv6:') {
                updateResult(ISEMAIL_RFC5322_DOMAINLITERAL);
              } else {
                var match = addressLiteral.substr(5);
                matchesIP = match.split(':');
                index = match.indexOf('::');
    
                if (!~index) {
                  // need exactly the right number of groups
                  if (matchesIP.length !== maxGroups) {
                    updateResult(ISEMAIL_RFC5322_IPV6_GRPCOUNT);
                  }
                } else if (index !== match.lastIndexOf('::')) {
                  updateResult(ISEMAIL_RFC5322_IPV6_2X2XCOLON);
                } else {
                  if (index === 0 || index === match.length - 2) {
                    // RFC 4291 allows :: at the start or end of an address with
                    // 7 other groups in addition
                    maxGroups++;
                  }
    
                  if (matchesIP.length > maxGroups) {
                    updateResult(ISEMAIL_RFC5322_IPV6_MAXGRPS);
                  } else if (matchesIP.length === maxGroups) {
                    // eliding a single "::"
                    updateResult(ISEMAIL_RFC5321_IPV6DEPRECATED);
                  }
                }
    
                // IPv6 testing strategy
                if (match[0] === ':' && match[1] !== ':') {
                  updateResult(ISEMAIL_RFC5322_IPV6_COLONSTRT);
                } else if (match[match.length - 1] === ':' &&
                           match[match.length - 2] !== ':') {
                  updateResult(ISEMAIL_RFC5322_IPV6_COLONEND);
                } else if (matchesIP.every(IPv6_REGEX_TEST)) {
                  updateResult(ISEMAIL_RFC5321_ADDRESSLITERAL);
                } else {
                  updateResult(ISEMAIL_RFC5322_IPV6_BADCHAR);
                }
              }
            } else {
              updateResult(ISEMAIL_RFC5322_DOMAINLITERAL);
            }
    
            parseData.domain += token;
            atomList.domain[elementCount] += token;
            elementLength++;
            context.prev = context.now;
            context.now = context.stack.pop();
            break;
          case '\\':
            updateResult(ISEMAIL_RFC5322_DOMLIT_OBSDTEXT);
            context.stack.push(context.now);
            context.now = CONTEXT_QUOTEDPAIR;
            break;
          // folding white space
          case '\r':
            if ((++i === email.length) || email[i] !== '\n') {
              // fatal error
              updateResult(ISEMAIL_ERR_CR_NO_LF);
              break;
            }
          case ' ':
          case '\t':
            updateResult(ISEMAIL_CFWS_FWS);
    
            context.stack.push(context.now);
            context.now = CONTEXT_FWS;
            prevToken = token;
            break;
          // dtext
          default:
            // http://tools.ietf.org/html/rfc5322#section-3.4.1
            //   dtext         =   %d33-90 /  ; Printable US-ASCII
            //                     %d94-126 / ;  characters not including
            //                     obs-dtext  ;  "[", "]", or "\"
            //
            //   obs-dtext     =   obs-NO-WS-CTL / quoted-pair
            //
            //   obs-NO-WS-CTL =   %d1-8 /    ; US-ASCII control
            //                     %d11 /     ;  characters that do not
            //                     %d12 /     ;  include the carriage
            //                     %d14-31 /  ;  return, line feed, and
            //                     %d127      ;  white space characters
            charCode = token.charCodeAt(0);
    
            // CR, LF, SP & HTAB have already been parsed above
            if (charCode > 127 || charCode === 0 || token === '[') {
              // fatal error
              updateResult(ISEMAIL_ERR_EXPECTING_DTEXT);
              break;
            } else if (charCode < 33 || charCode === 127) {
              updateResult(ISEMAIL_RFC5322_DOMLIT_OBSDTEXT);
            }
    
            parseData.literal += token;
            parseData.domain += token;
            atomList.domain[elementCount] += token;
            elementLength++;
          }
          break;
        // quoted string
        case CONTEXT_QUOTEDSTRING:
          // http://tools.ietf.org/html/rfc5322#section-3.2.4
          //   quoted-string = [CFWS]
          //                   DQUOTE *([FWS] qcontent) [FWS] DQUOTE
          //                   [CFWS]
          //
          //   qcontent      = qtext / quoted-pair
          switch (token) {
          // quoted pair
          case '\\':
            context.stack.push(context.now);
            context.now = CONTEXT_QUOTEDPAIR;
            break;
          // folding white space
          // inside a quoted string, spaces are allowed as regular characters
          // it's only FWS if we include HTAB or CRLF
          case '\r':
            if ((++i === email.length) || email[i] !== '\n') {
              // fatal error
              updateResult(ISEMAIL_ERR_CR_NO_LF);
              break;
            }
          case '\t':
            // http://tools.ietf.org/html/rfc5322#section-3.2.2
            //   Runs of FWS, comment, or CFWS that occur between lexical tokens in
            //   a structured header field are semantically interpreted as a single
            //   space character.
    
            // http://tools.ietf.org/html/rfc5322#section-3.2.4
            //   the CRLF in any FWS/CFWS that appears within the quoted-string [is]
            //   semantically "invisible" and therefore not part of the
            //   quoted-string
    
            parseData.local += ' ';
            atomList.local[elementCount] += ' ';
            elementLength++;
    
            updateResult(ISEMAIL_CFWS_FWS);
            context.stack.push(context.now);
            context.now = CONTEXT_FWS;
            prevToken = token;
            break;
          // end of quoted string
          case '"':
            parseData.local += token;
            atomList.local[elementCount] += token;
            elementLength++;
            context.prev = context.now;
            context.now = context.stack.pop();
            break;
          // qtext
          default:
            // http://tools.ietf.org/html/rfc5322#section-3.2.4
            //   qtext          =   %d33 /             ; Printable US-ASCII
            //                      %d35-91 /          ;  characters not including
            //                      %d93-126 /         ;  "\" or the quote character
            //                      obs-qtext
            //
            //   obs-qtext      =   obs-NO-WS-CTL
            //
            //   obs-NO-WS-CTL  =   %d1-8 /            ; US-ASCII control
            //                      %d11 /             ;  characters that do not
            //                      %d12 /             ;  include the carriage
            //                      %d14-31 /          ;  return, line feed, and
            //                      %d127              ;  white space characters
            charCode = token.charCodeAt(0);
    
            if (charCode > 127 || charCode === 0 || charCode === 10) {
              updateResult(ISEMAIL_ERR_EXPECTING_QTEXT);
            } else if (charCode < 32 || charCode === 127) {
              updateResult(ISEMAIL_DEPREC_QTEXT);
            }
    
            parseData.local += token;
            atomList.local[elementCount] += token;
            elementLength++;
          }
    
          // http://tools.ietf.org/html/rfc5322#section-3.4.1
          //   If the string can be represented as a dot-atom (that is, it contains
          //   no characters other than atext characters or "." surrounded by atext
          //   characters), then the dot-atom form SHOULD be used and the quoted-
          //   string form SHOULD NOT be used.
    
          break;
        // quoted pair
        case CONTEXT_QUOTEDPAIR:
          // http://tools.ietf.org/html/rfc5322#section-3.2.1
          //   quoted-pair     =   ("\" (VCHAR / WSP)) / obs-qp
          //
          //   VCHAR           =  %d33-126   ; visible (printing) characters
          //   WSP             =  SP / HTAB  ; white space
          //
          //   obs-qp          =   "\" (%d0 / obs-NO-WS-CTL / LF / CR)
          //
          //   obs-NO-WS-CTL   =   %d1-8 /   ; US-ASCII control
          //                       %d11 /    ;  characters that do not
          //                       %d12 /    ;  include the carriage
          //                       %d14-31 / ;  return, line feed, and
          //                       %d127     ;  white space characters
          //
          // i.e. obs-qp       =  "\" (%d0-8, %d10-31 / %d127)
          charCode = token.charCodeAt(0);
    
          if (charCode > 127) {
            // fatal error
            updateResult(ISEMAIL_ERR_EXPECTING_QPAIR);
          } else if ((charCode < 31 && charCode !== 9) || charCode === 127) {
            // SP & HTAB are allowed
            updateResult(ISEMAIL_DEPREC_QP);
          }
    
          // At this point we know where this qpair occurred so
          // we could check to see if the character actually
          // needed to be quoted at all.
          // http://tools.ietf.org/html/rfc5321#section-4.1.2
          //   the sending system SHOULD transmit the
          //   form that uses the minimum quoting possible.
    
          // TODO: check whether the character needs to be quoted (escaped)
          // in this context
    
          context.prev = context.now;
          context.now = context.stack.pop(); // end of qpair
          token = '\\' + token;
    
          switch (context.now) {
          case CONTEXT_COMMENT: break;
          case CONTEXT_QUOTEDSTRING:
            parseData.local += token;
            atomList.local[elementCount] += token;
    
            // the maximum sizes specified by RFC 5321 are octet counts,
            // so we must include the backslash
            elementLength += 2;
            break;
          case COMPONENT_LITERAL:
            parseData.domain += token;
            atomList.domain[elementCount] += token;
    
            // the maximum sizes specified by RFC 5321 are octet counts,
            // so we must include the backslash
            elementLength += 2;
            break;
          /* istanbul ignore next: logically unreachable */
          default:
            throw new Error('quoted pair logic invoked in an invalid context: ' +
              context.now);
          }
          break;
        // comment
        case CONTEXT_COMMENT:
          // http://tools.ietf.org/html/rfc5322#section-3.2.2
          //   comment  = "(" *([FWS] ccontent) [FWS] ")"
          //
          //   ccontent = ctext / quoted-pair / comment
          switch (token) {
          // nested comment
          case '(':
            // nested comments are ok
            context.stack.push(context.now);
            context.now = CONTEXT_COMMENT;
            break;
          // end of comment
          case ')':
            context.prev = context.now;
            context.now = context.stack.pop();
    
            break;
          // quoted pair
          case '\\':
            context.stack.push(context.now);
            context.now = CONTEXT_QUOTEDPAIR;
            break;
          // folding white space
          case '\r':
            if ((++i === email.length) || email[i] !== '\n') {
              // fatal error
              updateResult(ISEMAIL_ERR_CR_NO_LF);
              break;
            }
          case ' ':
          case '\t':
            updateResult(ISEMAIL_CFWS_FWS);
    
            context.stack.push(context.now);
            context.now = CONTEXT_FWS;
            prevToken = token;
            break;
          // ctext
          default:
            // http://tools.ietf.org/html/rfc5322#section-3.2.3
            //   ctext         = %d33-39 /  ; Printable US-ASCII
            //                   %d42-91 /  ;  characters not including
            //                   %d93-126 / ;  "(", ")", or "\"
            //                   obs-ctext
            //
            //   obs-ctext     = obs-NO-WS-CTL
            //
            //   obs-NO-WS-CTL = %d1-8 /    ; US-ASCII control
            //                   %d11 /     ;  characters that do not
            //                   %d12 /     ;  include the carriage
            //                   %d14-31 /  ;  return, line feed, and
            //                   %d127      ;  white space characters
            charCode = token.charCodeAt(0);
    
            if (charCode > 127 || charCode === 0 || charCode === 10) {
              // fatal error
              updateResult(ISEMAIL_ERR_EXPECTING_CTEXT);
              break;
            } else if (charCode < 32 || charCode === 127) {
              updateResult(ISEMAIL_DEPREC_CTEXT);
            }
          }
          break;
        // folding white space
        case CONTEXT_FWS:
          // http://tools.ietf.org/html/rfc5322#section-3.2.2
          //   FWS     =   ([*WSP CRLF] 1*WSP) /  obs-FWS
          //                                   ; Folding white space
    
          // But note the erratum:
          // http://www.rfc-editor.org/errata_search.php?rfc=5322&eid=1908:
          //   In the obsolete syntax, any amount of folding white space MAY be
          //   inserted where the obs-FWS rule is allowed.  This creates the
          //   possibility of having two consecutive "folds" in a line, and
          //   therefore the possibility that a line which makes up a folded header
          //   field could be composed entirely of white space.
          //
          //   obs-FWS =   1*([CRLF] WSP)
    
          if (prevToken === '\r') {
            if (token === '\r') {
              // fatal error
              updateResult(ISEMAIL_ERR_FWS_CRLF_X2);
              break;
            }
    
            if (++crlfCount > 1) {
              // multiple folds = obsolete FWS
              updateResult(ISEMAIL_DEPREC_FWS);
            } else {
              crlfCount = 1;
            }
          }
    
          switch (token) {
          case '\r':
            if ((++i === email.length) || email[i] !== '\n') {
              // fatal error
              updateResult(ISEMAIL_ERR_CR_NO_LF);
            }
            break;
          case ' ':
          case '\t':
            break;
          default:
            if (prevToken === '\r') {
              // fatal error
              updateResult(ISEMAIL_ERR_FWS_CRLF_END);
            }
    
            crlfCount = 0;
    
            context.prev = context.now;
            context.now = context.stack.pop(); // end of FWS
    
            i--; // look at this token again in the parent context
          }
          prevToken = token;
          break;
        // unexpected context
        /* istanbul ignore next: logically unreachable */
        default:
          throw new Error('unknown context: ' + context.now);
        } // primary state machine
    
        if (maxResult > ISEMAIL_RFC5322) {
          // fatal error, no point continuing
          break;
        }
      } // token loop
    
      // check for errors
      if (maxResult < ISEMAIL_RFC5322) {
        // fatal errors
        if (context.now === CONTEXT_QUOTEDSTRING) {
          updateResult(ISEMAIL_ERR_UNCLOSEDQUOTEDSTR);
        } else if (context.now === CONTEXT_QUOTEDPAIR) {
          updateResult(ISEMAIL_ERR_BACKSLASHEND);
        } else if (context.now === CONTEXT_COMMENT) {
          updateResult(ISEMAIL_ERR_UNCLOSEDCOMMENT);
        } else if (context.now === COMPONENT_LITERAL) {
          updateResult(ISEMAIL_ERR_UNCLOSEDDOMLIT);
        } else if (token === '\r') {
          updateResult(ISEMAIL_ERR_FWS_CRLF_END);
        } else if (parseData.domain.length === 0) {
          updateResult(ISEMAIL_ERR_NODOMAIN);
        } else if (elementLength === 0) {
          updateResult(ISEMAIL_ERR_DOT_END);
        } else if (hyphenFlag) {
          updateResult(ISEMAIL_ERR_DOMAINHYPHENEND);
    
        // other errors
        } else if (parseData.domain.length > 255) {
          // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.2
          //   The maximum total length of a domain name or number is 255 octets.
          updateResult(ISEMAIL_RFC5322_DOMAIN_TOOLONG);
        } else if (parseData.local.length + parseData.domain.length + /* '@' */ 1 >
            254) {
          // http://tools.ietf.org/html/rfc5321#section-4.1.2
          //   Forward-path   = Path
          //
          //   Path           = "<" [ A-d-l ":" ] Mailbox ">"
          //
          // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3
          //   The maximum total length of a reverse-path or forward-path is 256
          //   octets (including the punctuation and element separators).
          //
          // Thus, even without (obsolete) routing information, the Mailbox can
          // only be 254 characters long. This is confirmed by this verified
          // erratum to RFC 3696:
          //
          // http://www.rfc-editor.org/errata_search.php?rfc=3696&eid=1690
          //   However, there is a restriction in RFC 2821 on the length of an
          //   address in MAIL and RCPT commands of 254 characters.  Since addresses
          //   that do not fit in those fields are not normally useful, the upper
          //   limit on address lengths should normally be considered to be 254.
          updateResult(ISEMAIL_RFC5322_TOOLONG);
        } else if (elementLength > 63) {
          // http://tools.ietf.org/html/rfc1035#section-2.3.4
          // labels   63 octets or less
          updateResult(ISEMAIL_RFC5322_LABEL_TOOLONG);
        } else if (options.minDomainAtoms && atomList.domain.length <
            options.minDomainAtoms) {
          updateResult(ISEMAIL_ERR_TOOSHORT_DOMAIN);
        } else if (options.tldWhitelist) {
          var tldAtom = atomList.domain[elementCount], tldValid = false, n;
          if (Array.isArray(options.tldWhitelist)) {
            for (i = 0, n = options.tldWhitelist.length; i < n; i++) {
              if (tldAtom === options.tldWhitelist[i]) {
                tldValid = true;
                break;
              }
            }
          } else {
            tldValid = hasOwn.call(options.tldWhitelist, tldAtom);
          }
          if (!tldValid) {
            updateResult(ISEMAIL_ERR_UNKNOWN_TLD);
          }
        }
      } // check for errors
    
      var dnsPositive = false;
    
      if (options.checkDNS && maxResult < ISEMAIL_DNSWARN && HAS_REQUIRE) {
        dns || (dns = require('dns'));
        // http://tools.ietf.org/html/rfc5321#section-2.3.5
        //   Names that can
        //   be resolved to MX RRs or address (i.e., A or AAAA) RRs (as discussed
        //   in Section 5) are permitted, as are CNAME RRs whose targets can be
        //   resolved, in turn, to MX or address RRs.
        //
        // http://tools.ietf.org/html/rfc5321#section-5.1
        //   The lookup first attempts to locate an MX record associated with the
        //   name.  If a CNAME record is found, the resulting name is processed as
        //   if it were the initial name. ... If an empty list of MXs is returned,
        //   the address is treated as if it was associated with an implicit MX
        //   RR, with a preference of 0, pointing to that host.
        //
        // isEmail() author's note: We will regard the existence of a CNAME to be
        // sufficient evidence of the domain's existence. For performance reasons
        // we will not repeat the DNS lookup for the CNAME's target, but we will
        // raise a warning because we didn't immediately find an MX record.
        if (elementCount === 0) {
          // checking TLD DNS only works if you explicitly check from the root
          parseData.domain += '.';
        }
    
        var dnsDomain = parseData.domain;
        dns.resolveMx(dnsDomain, function(err, records) {
          if ((err && err.code !== dns.NODATA) || (!err && !records)) {
            updateResult(ISEMAIL_DNSWARN_NO_RECORD);
            return finish();
          }
          if (records && records.length) {
            dnsPositive = true;
            return finish();
          }
          var done = false, count = 3;
          updateResult(ISEMAIL_DNSWARN_NO_MX_RECORD);
          dns.resolveCname(dnsDomain, handleRecords);
          dns.resolve4(dnsDomain, handleRecords);
          dns.resolve6(dnsDomain, handleRecords);
          function handleRecords(err, records) {
            if (done) return;
            count--;
            if (!err && records && records.length) {
              done = true;
              return finish();
            }
            if (count === 0) {
              // no usable records for the domain can be found
              updateResult(ISEMAIL_DNSWARN_NO_RECORD);
              done = true;
              finish();
            }
          }
        });
      } else if (options.checkDNS) {
        // guarantee asynchronicity
        typeof process !== 'undefined' && process &&
          typeof process.nextTick === 'function'
          ? process.nextTick(finish)
          : setTimeout(finish, 1);
      } else {
        return finish();
      } // checkDNS
    
      function finish() {
        if (!dnsPositive && maxResult < ISEMAIL_DNSWARN) {
          if (elementCount === 0) {
            updateResult(ISEMAIL_RFC5321_TLD);
          } else {
            var charCode = atomList.domain[elementCount].charCodeAt(0);
            if (charCode >= 48 && charCode <= 57) {
              updateResult(ISEMAIL_RFC5321_TLDNUMERIC);
            }
          }
        }
    
        if (maxResult < threshold) {
          maxResult = ISEMAIL_VALID;
        }
    
        if (!diagnose) {
          maxResult = maxResult < THRESHOLD;
        }
    
        if (typeof callback === 'function') {
          callback(maxResult);
        }
    
        return maxResult;
      } // finish
    } // isEmail
    
    module.exports = isEmail;
    
  provide("isemail/lib/isemail", module.exports);
}(global));

// pakmanager:isemail
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('isemail/lib/isemail');
    
  provide("isemail", module.exports);
}(global));

// pakmanager:moment
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  //! moment.js
    //! version : 2.10.3
    //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
    //! license : MIT
    //! momentjs.com
    
    (function (global, factory) {
        typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
        typeof define === 'function' && define.amd ? define(factory) :
        global.moment = factory()
    }(this, function () { 'use strict';
    
        var hookCallback;
    
        function utils_hooks__hooks () {
            return hookCallback.apply(null, arguments);
        }
    
        // This is done to register the method called with moment()
        // without creating circular dependencies.
        function setHookCallback (callback) {
            hookCallback = callback;
        }
    
        function isArray(input) {
            return Object.prototype.toString.call(input) === '[object Array]';
        }
    
        function isDate(input) {
            return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
        }
    
        function map(arr, fn) {
            var res = [], i;
            for (i = 0; i < arr.length; ++i) {
                res.push(fn(arr[i], i));
            }
            return res;
        }
    
        function hasOwnProp(a, b) {
            return Object.prototype.hasOwnProperty.call(a, b);
        }
    
        function extend(a, b) {
            for (var i in b) {
                if (hasOwnProp(b, i)) {
                    a[i] = b[i];
                }
            }
    
            if (hasOwnProp(b, 'toString')) {
                a.toString = b.toString;
            }
    
            if (hasOwnProp(b, 'valueOf')) {
                a.valueOf = b.valueOf;
            }
    
            return a;
        }
    
        function create_utc__createUTC (input, format, locale, strict) {
            return createLocalOrUTC(input, format, locale, strict, true).utc();
        }
    
        function defaultParsingFlags() {
            // We need to deep clone this object.
            return {
                empty           : false,
                unusedTokens    : [],
                unusedInput     : [],
                overflow        : -2,
                charsLeftOver   : 0,
                nullInput       : false,
                invalidMonth    : null,
                invalidFormat   : false,
                userInvalidated : false,
                iso             : false
            };
        }
    
        function getParsingFlags(m) {
            if (m._pf == null) {
                m._pf = defaultParsingFlags();
            }
            return m._pf;
        }
    
        function valid__isValid(m) {
            if (m._isValid == null) {
                var flags = getParsingFlags(m);
                m._isValid = !isNaN(m._d.getTime()) &&
                    flags.overflow < 0 &&
                    !flags.empty &&
                    !flags.invalidMonth &&
                    !flags.nullInput &&
                    !flags.invalidFormat &&
                    !flags.userInvalidated;
    
                if (m._strict) {
                    m._isValid = m._isValid &&
                        flags.charsLeftOver === 0 &&
                        flags.unusedTokens.length === 0 &&
                        flags.bigHour === undefined;
                }
            }
            return m._isValid;
        }
    
        function valid__createInvalid (flags) {
            var m = create_utc__createUTC(NaN);
            if (flags != null) {
                extend(getParsingFlags(m), flags);
            }
            else {
                getParsingFlags(m).userInvalidated = true;
            }
    
            return m;
        }
    
        var momentProperties = utils_hooks__hooks.momentProperties = [];
    
        function copyConfig(to, from) {
            var i, prop, val;
    
            if (typeof from._isAMomentObject !== 'undefined') {
                to._isAMomentObject = from._isAMomentObject;
            }
            if (typeof from._i !== 'undefined') {
                to._i = from._i;
            }
            if (typeof from._f !== 'undefined') {
                to._f = from._f;
            }
            if (typeof from._l !== 'undefined') {
                to._l = from._l;
            }
            if (typeof from._strict !== 'undefined') {
                to._strict = from._strict;
            }
            if (typeof from._tzm !== 'undefined') {
                to._tzm = from._tzm;
            }
            if (typeof from._isUTC !== 'undefined') {
                to._isUTC = from._isUTC;
            }
            if (typeof from._offset !== 'undefined') {
                to._offset = from._offset;
            }
            if (typeof from._pf !== 'undefined') {
                to._pf = getParsingFlags(from);
            }
            if (typeof from._locale !== 'undefined') {
                to._locale = from._locale;
            }
    
            if (momentProperties.length > 0) {
                for (i in momentProperties) {
                    prop = momentProperties[i];
                    val = from[prop];
                    if (typeof val !== 'undefined') {
                        to[prop] = val;
                    }
                }
            }
    
            return to;
        }
    
        var updateInProgress = false;
    
        // Moment prototype object
        function Moment(config) {
            copyConfig(this, config);
            this._d = new Date(+config._d);
            // Prevent infinite loop in case updateOffset creates new moment
            // objects.
            if (updateInProgress === false) {
                updateInProgress = true;
                utils_hooks__hooks.updateOffset(this);
                updateInProgress = false;
            }
        }
    
        function isMoment (obj) {
            return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
        }
    
        function toInt(argumentForCoercion) {
            var coercedNumber = +argumentForCoercion,
                value = 0;
    
            if (coercedNumber !== 0 && isFinite(coercedNumber)) {
                if (coercedNumber >= 0) {
                    value = Math.floor(coercedNumber);
                } else {
                    value = Math.ceil(coercedNumber);
                }
            }
    
            return value;
        }
    
        function compareArrays(array1, array2, dontConvert) {
            var len = Math.min(array1.length, array2.length),
                lengthDiff = Math.abs(array1.length - array2.length),
                diffs = 0,
                i;
            for (i = 0; i < len; i++) {
                if ((dontConvert && array1[i] !== array2[i]) ||
                    (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                    diffs++;
                }
            }
            return diffs + lengthDiff;
        }
    
        function Locale() {
        }
    
        var locales = {};
        var globalLocale;
    
        function normalizeLocale(key) {
            return key ? key.toLowerCase().replace('_', '-') : key;
        }
    
        // pick the locale from the array
        // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        function chooseLocale(names) {
            var i = 0, j, next, locale, split;
    
            while (i < names.length) {
                split = normalizeLocale(names[i]).split('-');
                j = split.length;
                next = normalizeLocale(names[i + 1]);
                next = next ? next.split('-') : null;
                while (j > 0) {
                    locale = loadLocale(split.slice(0, j).join('-'));
                    if (locale) {
                        return locale;
                    }
                    if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                        //the next array item is better than a shallower substring of this one
                        break;
                    }
                    j--;
                }
                i++;
            }
            return null;
        }
    
        function loadLocale(name) {
            var oldLocale = null;
            // TODO: Find a better way to register and load all the locales in Node
            if (!locales[name] && typeof module !== 'undefined' &&
                    module && module.exports) {
                try {
                    oldLocale = globalLocale._abbr;
                    require('./locale/' + name);
                    // because defineLocale currently also sets the global locale, we
                    // want to undo that for lazy loaded locales
                    locale_locales__getSetGlobalLocale(oldLocale);
                } catch (e) { }
            }
            return locales[name];
        }
    
        // This function will load locale and then set the global locale.  If
        // no arguments are passed in, it will simply return the current global
        // locale key.
        function locale_locales__getSetGlobalLocale (key, values) {
            var data;
            if (key) {
                if (typeof values === 'undefined') {
                    data = locale_locales__getLocale(key);
                }
                else {
                    data = defineLocale(key, values);
                }
    
                if (data) {
                    // moment.duration._locale = moment._locale = data;
                    globalLocale = data;
                }
            }
    
            return globalLocale._abbr;
        }
    
        function defineLocale (name, values) {
            if (values !== null) {
                values.abbr = name;
                if (!locales[name]) {
                    locales[name] = new Locale();
                }
                locales[name].set(values);
    
                // backwards compat for now: also set the locale
                locale_locales__getSetGlobalLocale(name);
    
                return locales[name];
            } else {
                // useful for testing
                delete locales[name];
                return null;
            }
        }
    
        // returns locale data
        function locale_locales__getLocale (key) {
            var locale;
    
            if (key && key._locale && key._locale._abbr) {
                key = key._locale._abbr;
            }
    
            if (!key) {
                return globalLocale;
            }
    
            if (!isArray(key)) {
                //short-circuit everything else
                locale = loadLocale(key);
                if (locale) {
                    return locale;
                }
                key = [key];
            }
    
            return chooseLocale(key);
        }
    
        var aliases = {};
    
        function addUnitAlias (unit, shorthand) {
            var lowerCase = unit.toLowerCase();
            aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
        }
    
        function normalizeUnits(units) {
            return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
        }
    
        function normalizeObjectUnits(inputObject) {
            var normalizedInput = {},
                normalizedProp,
                prop;
    
            for (prop in inputObject) {
                if (hasOwnProp(inputObject, prop)) {
                    normalizedProp = normalizeUnits(prop);
                    if (normalizedProp) {
                        normalizedInput[normalizedProp] = inputObject[prop];
                    }
                }
            }
    
            return normalizedInput;
        }
    
        function makeGetSet (unit, keepTime) {
            return function (value) {
                if (value != null) {
                    get_set__set(this, unit, value);
                    utils_hooks__hooks.updateOffset(this, keepTime);
                    return this;
                } else {
                    return get_set__get(this, unit);
                }
            };
        }
    
        function get_set__get (mom, unit) {
            return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
        }
    
        function get_set__set (mom, unit, value) {
            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    
        // MOMENTS
    
        function getSet (units, value) {
            var unit;
            if (typeof units === 'object') {
                for (unit in units) {
                    this.set(unit, units[unit]);
                }
            } else {
                units = normalizeUnits(units);
                if (typeof this[units] === 'function') {
                    return this[units](value);
                }
            }
            return this;
        }
    
        function zeroFill(number, targetLength, forceSign) {
            var output = '' + Math.abs(number),
                sign = number >= 0;
    
            while (output.length < targetLength) {
                output = '0' + output;
            }
            return (sign ? (forceSign ? '+' : '') : '-') + output;
        }
    
        var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g;
    
        var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    
        var formatFunctions = {};
    
        var formatTokenFunctions = {};
    
        // token:    'M'
        // padded:   ['MM', 2]
        // ordinal:  'Mo'
        // callback: function () { this.month() + 1 }
        function addFormatToken (token, padded, ordinal, callback) {
            var func = callback;
            if (typeof callback === 'string') {
                func = function () {
                    return this[callback]();
                };
            }
            if (token) {
                formatTokenFunctions[token] = func;
            }
            if (padded) {
                formatTokenFunctions[padded[0]] = function () {
                    return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
                };
            }
            if (ordinal) {
                formatTokenFunctions[ordinal] = function () {
                    return this.localeData().ordinal(func.apply(this, arguments), token);
                };
            }
        }
    
        function removeFormattingTokens(input) {
            if (input.match(/\[[\s\S]/)) {
                return input.replace(/^\[|\]$/g, '');
            }
            return input.replace(/\\/g, '');
        }
    
        function makeFormatFunction(format) {
            var array = format.match(formattingTokens), i, length;
    
            for (i = 0, length = array.length; i < length; i++) {
                if (formatTokenFunctions[array[i]]) {
                    array[i] = formatTokenFunctions[array[i]];
                } else {
                    array[i] = removeFormattingTokens(array[i]);
                }
            }
    
            return function (mom) {
                var output = '';
                for (i = 0; i < length; i++) {
                    output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
                }
                return output;
            };
        }
    
        // format date using native date object
        function formatMoment(m, format) {
            if (!m.isValid()) {
                return m.localeData().invalidDate();
            }
    
            format = expandFormat(format, m.localeData());
    
            if (!formatFunctions[format]) {
                formatFunctions[format] = makeFormatFunction(format);
            }
    
            return formatFunctions[format](m);
        }
    
        function expandFormat(format, locale) {
            var i = 5;
    
            function replaceLongDateFormatTokens(input) {
                return locale.longDateFormat(input) || input;
            }
    
            localFormattingTokens.lastIndex = 0;
            while (i >= 0 && localFormattingTokens.test(format)) {
                format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
                localFormattingTokens.lastIndex = 0;
                i -= 1;
            }
    
            return format;
        }
    
        var match1         = /\d/;            //       0 - 9
        var match2         = /\d\d/;          //      00 - 99
        var match3         = /\d{3}/;         //     000 - 999
        var match4         = /\d{4}/;         //    0000 - 9999
        var match6         = /[+-]?\d{6}/;    // -999999 - 999999
        var match1to2      = /\d\d?/;         //       0 - 99
        var match1to3      = /\d{1,3}/;       //       0 - 999
        var match1to4      = /\d{1,4}/;       //       0 - 9999
        var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999
    
        var matchUnsigned  = /\d+/;           //       0 - inf
        var matchSigned    = /[+-]?\d+/;      //    -inf - inf
    
        var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    
        var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
    
        // any word (or two) characters or numbers including two/three word month in arabic.
        var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
    
        var regexes = {};
    
        function addRegexToken (token, regex, strictRegex) {
            regexes[token] = typeof regex === 'function' ? regex : function (isStrict) {
                return (isStrict && strictRegex) ? strictRegex : regex;
            };
        }
    
        function getParseRegexForToken (token, config) {
            if (!hasOwnProp(regexes, token)) {
                return new RegExp(unescapeFormat(token));
            }
    
            return regexes[token](config._strict, config._locale);
        }
    
        // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
        function unescapeFormat(s) {
            return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
                return p1 || p2 || p3 || p4;
            }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
        }
    
        var tokens = {};
    
        function addParseToken (token, callback) {
            var i, func = callback;
            if (typeof token === 'string') {
                token = [token];
            }
            if (typeof callback === 'number') {
                func = function (input, array) {
                    array[callback] = toInt(input);
                };
            }
            for (i = 0; i < token.length; i++) {
                tokens[token[i]] = func;
            }
        }
    
        function addWeekParseToken (token, callback) {
            addParseToken(token, function (input, array, config, token) {
                config._w = config._w || {};
                callback(input, config._w, config, token);
            });
        }
    
        function addTimeToArrayFromToken(token, input, config) {
            if (input != null && hasOwnProp(tokens, token)) {
                tokens[token](input, config._a, config, token);
            }
        }
    
        var YEAR = 0;
        var MONTH = 1;
        var DATE = 2;
        var HOUR = 3;
        var MINUTE = 4;
        var SECOND = 5;
        var MILLISECOND = 6;
    
        function daysInMonth(year, month) {
            return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
        }
    
        // FORMATTING
    
        addFormatToken('M', ['MM', 2], 'Mo', function () {
            return this.month() + 1;
        });
    
        addFormatToken('MMM', 0, 0, function (format) {
            return this.localeData().monthsShort(this, format);
        });
    
        addFormatToken('MMMM', 0, 0, function (format) {
            return this.localeData().months(this, format);
        });
    
        // ALIASES
    
        addUnitAlias('month', 'M');
    
        // PARSING
    
        addRegexToken('M',    match1to2);
        addRegexToken('MM',   match1to2, match2);
        addRegexToken('MMM',  matchWord);
        addRegexToken('MMMM', matchWord);
    
        addParseToken(['M', 'MM'], function (input, array) {
            array[MONTH] = toInt(input) - 1;
        });
    
        addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
            var month = config._locale.monthsParse(input, token, config._strict);
            // if we didn't find a month name, mark the date as invalid.
            if (month != null) {
                array[MONTH] = month;
            } else {
                getParsingFlags(config).invalidMonth = input;
            }
        });
    
        // LOCALES
    
        var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
        function localeMonths (m) {
            return this._months[m.month()];
        }
    
        var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
        function localeMonthsShort (m) {
            return this._monthsShort[m.month()];
        }
    
        function localeMonthsParse (monthName, format, strict) {
            var i, mom, regex;
    
            if (!this._monthsParse) {
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = [];
            }
    
            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                mom = create_utc__createUTC([2000, i]);
                if (strict && !this._longMonthsParse[i]) {
                    this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                    this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
                }
                if (!strict && !this._monthsParse[i]) {
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                    return i;
                } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                    return i;
                } else if (!strict && this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        }
    
        // MOMENTS
    
        function setMonth (mom, value) {
            var dayOfMonth;
    
            // TODO: Move this out of here!
            if (typeof value === 'string') {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (typeof value !== 'number') {
                    return mom;
                }
            }
    
            dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
            return mom;
        }
    
        function getSetMonth (value) {
            if (value != null) {
                setMonth(this, value);
                utils_hooks__hooks.updateOffset(this, true);
                return this;
            } else {
                return get_set__get(this, 'Month');
            }
        }
    
        function getDaysInMonth () {
            return daysInMonth(this.year(), this.month());
        }
    
        function checkOverflow (m) {
            var overflow;
            var a = m._a;
    
            if (a && getParsingFlags(m).overflow === -2) {
                overflow =
                    a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                    a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                    a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                    a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                    a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                    a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                    -1;
    
                if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                    overflow = DATE;
                }
    
                getParsingFlags(m).overflow = overflow;
            }
    
            return m;
        }
    
        function warn(msg) {
            if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
                console.warn('Deprecation warning: ' + msg);
            }
        }
    
        function deprecate(msg, fn) {
            var firstTime = true,
                msgWithStack = msg + '\n' + (new Error()).stack;
    
            return extend(function () {
                if (firstTime) {
                    warn(msgWithStack);
                    firstTime = false;
                }
                return fn.apply(this, arguments);
            }, fn);
        }
    
        var deprecations = {};
    
        function deprecateSimple(name, msg) {
            if (!deprecations[name]) {
                warn(msg);
                deprecations[name] = true;
            }
        }
    
        utils_hooks__hooks.suppressDeprecationWarnings = false;
    
        var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    
        var isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
            ['YYYY-DDD', /\d{4}-\d{3}/]
        ];
    
        // iso time formats and regexes
        var isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ];
    
        var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
    
        // date from iso format
        function configFromISO(config) {
            var i, l,
                string = config._i,
                match = from_string__isoRegex.exec(string);
    
            if (match) {
                getParsingFlags(config).iso = true;
                for (i = 0, l = isoDates.length; i < l; i++) {
                    if (isoDates[i][1].exec(string)) {
                        // match[5] should be 'T' or undefined
                        config._f = isoDates[i][0] + (match[6] || ' ');
                        break;
                    }
                }
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(string)) {
                        config._f += isoTimes[i][0];
                        break;
                    }
                }
                if (string.match(matchOffset)) {
                    config._f += 'Z';
                }
                configFromStringAndFormat(config);
            } else {
                config._isValid = false;
            }
        }
    
        // date from iso format or fallback
        function configFromString(config) {
            var matched = aspNetJsonRegex.exec(config._i);
    
            if (matched !== null) {
                config._d = new Date(+matched[1]);
                return;
            }
    
            configFromISO(config);
            if (config._isValid === false) {
                delete config._isValid;
                utils_hooks__hooks.createFromInputFallback(config);
            }
        }
    
        utils_hooks__hooks.createFromInputFallback = deprecate(
            'moment construction falls back to js Date. This is ' +
            'discouraged and will be removed in upcoming major ' +
            'release. Please refer to ' +
            'https://github.com/moment/moment/issues/1407 for more info.',
            function (config) {
                config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
            }
        );
    
        function createDate (y, m, d, h, M, s, ms) {
            //can't just apply() to create a date:
            //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
            var date = new Date(y, m, d, h, M, s, ms);
    
            //the date constructor doesn't accept years < 1970
            if (y < 1970) {
                date.setFullYear(y);
            }
            return date;
        }
    
        function createUTCDate (y) {
            var date = new Date(Date.UTC.apply(null, arguments));
            if (y < 1970) {
                date.setUTCFullYear(y);
            }
            return date;
        }
    
        addFormatToken(0, ['YY', 2], 0, function () {
            return this.year() % 100;
        });
    
        addFormatToken(0, ['YYYY',   4],       0, 'year');
        addFormatToken(0, ['YYYYY',  5],       0, 'year');
        addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
    
        // ALIASES
    
        addUnitAlias('year', 'y');
    
        // PARSING
    
        addRegexToken('Y',      matchSigned);
        addRegexToken('YY',     match1to2, match2);
        addRegexToken('YYYY',   match1to4, match4);
        addRegexToken('YYYYY',  match1to6, match6);
        addRegexToken('YYYYYY', match1to6, match6);
    
        addParseToken(['YYYY', 'YYYYY', 'YYYYYY'], YEAR);
        addParseToken('YY', function (input, array) {
            array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
        });
    
        // HELPERS
    
        function daysInYear(year) {
            return isLeapYear(year) ? 366 : 365;
        }
    
        function isLeapYear(year) {
            return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
        }
    
        // HOOKS
    
        utils_hooks__hooks.parseTwoDigitYear = function (input) {
            return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
        };
    
        // MOMENTS
    
        var getSetYear = makeGetSet('FullYear', false);
    
        function getIsLeapYear () {
            return isLeapYear(this.year());
        }
    
        addFormatToken('w', ['ww', 2], 'wo', 'week');
        addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
    
        // ALIASES
    
        addUnitAlias('week', 'w');
        addUnitAlias('isoWeek', 'W');
    
        // PARSING
    
        addRegexToken('w',  match1to2);
        addRegexToken('ww', match1to2, match2);
        addRegexToken('W',  match1to2);
        addRegexToken('WW', match1to2, match2);
    
        addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
            week[token.substr(0, 1)] = toInt(input);
        });
    
        // HELPERS
    
        // firstDayOfWeek       0 = sun, 6 = sat
        //                      the day of the week that starts the week
        //                      (usually sunday or monday)
        // firstDayOfWeekOfYear 0 = sun, 6 = sat
        //                      the first week is the week that contains the first
        //                      of this day of the week
        //                      (eg. ISO weeks use thursday (4))
        function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
            var end = firstDayOfWeekOfYear - firstDayOfWeek,
                daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
                adjustedMoment;
    
    
            if (daysToDayOfWeek > end) {
                daysToDayOfWeek -= 7;
            }
    
            if (daysToDayOfWeek < end - 7) {
                daysToDayOfWeek += 7;
            }
    
            adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
            return {
                week: Math.ceil(adjustedMoment.dayOfYear() / 7),
                year: adjustedMoment.year()
            };
        }
    
        // LOCALES
    
        function localeWeek (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }
    
        var defaultLocaleWeek = {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        };
    
        function localeFirstDayOfWeek () {
            return this._week.dow;
        }
    
        function localeFirstDayOfYear () {
            return this._week.doy;
        }
    
        // MOMENTS
    
        function getSetWeek (input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, 'd');
        }
    
        function getSetISOWeek (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add((input - week) * 7, 'd');
        }
    
        addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
    
        // ALIASES
    
        addUnitAlias('dayOfYear', 'DDD');
    
        // PARSING
    
        addRegexToken('DDD',  match1to3);
        addRegexToken('DDDD', match3);
        addParseToken(['DDD', 'DDDD'], function (input, array, config) {
            config._dayOfYear = toInt(input);
        });
    
        // HELPERS
    
        //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
        function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
            var d = createUTCDate(year, 0, 1).getUTCDay();
            var daysToAdd;
            var dayOfYear;
    
            d = d === 0 ? 7 : d;
            weekday = weekday != null ? weekday : firstDayOfWeek;
            daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
            dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
    
            return {
                year      : dayOfYear > 0 ? year      : year - 1,
                dayOfYear : dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
            };
        }
    
        // MOMENTS
    
        function getSetDayOfYear (input) {
            var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
        }
    
        // Pick the first defined of two or three arguments.
        function defaults(a, b, c) {
            if (a != null) {
                return a;
            }
            if (b != null) {
                return b;
            }
            return c;
        }
    
        function currentDateArray(config) {
            var now = new Date();
            if (config._useUTC) {
                return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
            }
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    
        // convert an array to a date.
        // the array should mirror the parameters below
        // note: all values past the year are optional and will default to the lowest possible value.
        // [year, month, day , hour, minute, second, millisecond]
        function configFromArray (config) {
            var i, date, input = [], currentDate, yearToUse;
    
            if (config._d) {
                return;
            }
    
            currentDate = currentDateArray(config);
    
            //compute day of the year from weeks and weekdays
            if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
                dayOfYearFromWeekInfo(config);
            }
    
            //if the day of the year is set, figure out what it is
            if (config._dayOfYear) {
                yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
    
                if (config._dayOfYear > daysInYear(yearToUse)) {
                    getParsingFlags(config)._overflowDayOfYear = true;
                }
    
                date = createUTCDate(yearToUse, 0, config._dayOfYear);
                config._a[MONTH] = date.getUTCMonth();
                config._a[DATE] = date.getUTCDate();
            }
    
            // Default to current date.
            // * if no year, month, day of month are given, default to today
            // * if day of month is given, default month and year
            // * if month is given, default only year
            // * if year is given, don't default anything
            for (i = 0; i < 3 && config._a[i] == null; ++i) {
                config._a[i] = input[i] = currentDate[i];
            }
    
            // Zero out whatever was not defaulted, including time
            for (; i < 7; i++) {
                config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
            }
    
            // Check for 24:00:00.000
            if (config._a[HOUR] === 24 &&
                    config._a[MINUTE] === 0 &&
                    config._a[SECOND] === 0 &&
                    config._a[MILLISECOND] === 0) {
                config._nextDay = true;
                config._a[HOUR] = 0;
            }
    
            config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
            // Apply timezone offset from input. The actual utcOffset can be changed
            // with parseZone.
            if (config._tzm != null) {
                config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            }
    
            if (config._nextDay) {
                config._a[HOUR] = 24;
            }
        }
    
        function dayOfYearFromWeekInfo(config) {
            var w, weekYear, week, weekday, dow, doy, temp;
    
            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
                dow = 1;
                doy = 4;
    
                // TODO: We need to take the current isoWeekYear, but that depends on
                // how we interpret now (local, utc, fixed offset). So create
                // a now version of current config (take local/utc/offset flags, and
                // create now).
                weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
                week = defaults(w.W, 1);
                weekday = defaults(w.E, 1);
            } else {
                dow = config._locale._week.dow;
                doy = config._locale._week.doy;
    
                weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
                week = defaults(w.w, 1);
    
                if (w.d != null) {
                    // weekday -- low day numbers are considered next week
                    weekday = w.d;
                    if (weekday < dow) {
                        ++week;
                    }
                } else if (w.e != null) {
                    // local weekday -- counting starts from begining of week
                    weekday = w.e + dow;
                } else {
                    // default to begining of week
                    weekday = dow;
                }
            }
            temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
    
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    
        utils_hooks__hooks.ISO_8601 = function () {};
    
        // date from string and format string
        function configFromStringAndFormat(config) {
            // TODO: Move this to another part of the creation flow to prevent circular deps
            if (config._f === utils_hooks__hooks.ISO_8601) {
                configFromISO(config);
                return;
            }
    
            config._a = [];
            getParsingFlags(config).empty = true;
    
            // This array is used to make a Date, either with `new Date` or `Date.UTC`
            var string = '' + config._i,
                i, parsedInput, tokens, token, skipped,
                stringLength = string.length,
                totalParsedInputLength = 0;
    
            tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
    
            for (i = 0; i < tokens.length; i++) {
                token = tokens[i];
                parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
                if (parsedInput) {
                    skipped = string.substr(0, string.indexOf(parsedInput));
                    if (skipped.length > 0) {
                        getParsingFlags(config).unusedInput.push(skipped);
                    }
                    string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                    totalParsedInputLength += parsedInput.length;
                }
                // don't parse if it's not a known token
                if (formatTokenFunctions[token]) {
                    if (parsedInput) {
                        getParsingFlags(config).empty = false;
                    }
                    else {
                        getParsingFlags(config).unusedTokens.push(token);
                    }
                    addTimeToArrayFromToken(token, parsedInput, config);
                }
                else if (config._strict && !parsedInput) {
                    getParsingFlags(config).unusedTokens.push(token);
                }
            }
    
            // add remaining unparsed input length to the string
            getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
            if (string.length > 0) {
                getParsingFlags(config).unusedInput.push(string);
            }
    
            // clear _12h flag if hour is <= 12
            if (getParsingFlags(config).bigHour === true &&
                    config._a[HOUR] <= 12 &&
                    config._a[HOUR] > 0) {
                getParsingFlags(config).bigHour = undefined;
            }
            // handle meridiem
            config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
    
            configFromArray(config);
            checkOverflow(config);
        }
    
    
        function meridiemFixWrap (locale, hour, meridiem) {
            var isPm;
    
            if (meridiem == null) {
                // nothing to do
                return hour;
            }
            if (locale.meridiemHour != null) {
                return locale.meridiemHour(hour, meridiem);
            } else if (locale.isPM != null) {
                // Fallback
                isPm = locale.isPM(meridiem);
                if (isPm && hour < 12) {
                    hour += 12;
                }
                if (!isPm && hour === 12) {
                    hour = 0;
                }
                return hour;
            } else {
                // this is not supposed to happen
                return hour;
            }
        }
    
        function configFromStringAndArray(config) {
            var tempConfig,
                bestMoment,
    
                scoreToBeat,
                i,
                currentScore;
    
            if (config._f.length === 0) {
                getParsingFlags(config).invalidFormat = true;
                config._d = new Date(NaN);
                return;
            }
    
            for (i = 0; i < config._f.length; i++) {
                currentScore = 0;
                tempConfig = copyConfig({}, config);
                if (config._useUTC != null) {
                    tempConfig._useUTC = config._useUTC;
                }
                tempConfig._f = config._f[i];
                configFromStringAndFormat(tempConfig);
    
                if (!valid__isValid(tempConfig)) {
                    continue;
                }
    
                // if there is any input that was not parsed add a penalty for that format
                currentScore += getParsingFlags(tempConfig).charsLeftOver;
    
                //or tokens
                currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    
                getParsingFlags(tempConfig).score = currentScore;
    
                if (scoreToBeat == null || currentScore < scoreToBeat) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                }
            }
    
            extend(config, bestMoment || tempConfig);
        }
    
        function configFromObject(config) {
            if (config._d) {
                return;
            }
    
            var i = normalizeObjectUnits(config._i);
            config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];
    
            configFromArray(config);
        }
    
        function createFromConfig (config) {
            var input = config._i,
                format = config._f,
                res;
    
            config._locale = config._locale || locale_locales__getLocale(config._l);
    
            if (input === null || (format === undefined && input === '')) {
                return valid__createInvalid({nullInput: true});
            }
    
            if (typeof input === 'string') {
                config._i = input = config._locale.preparse(input);
            }
    
            if (isMoment(input)) {
                return new Moment(checkOverflow(input));
            } else if (isArray(format)) {
                configFromStringAndArray(config);
            } else if (format) {
                configFromStringAndFormat(config);
            } else if (isDate(input)) {
                config._d = input;
            } else {
                configFromInput(config);
            }
    
            res = new Moment(checkOverflow(config));
            if (res._nextDay) {
                // Adding is smart enough around DST
                res.add(1, 'd');
                res._nextDay = undefined;
            }
    
            return res;
        }
    
        function configFromInput(config) {
            var input = config._i;
            if (input === undefined) {
                config._d = new Date();
            } else if (isDate(input)) {
                config._d = new Date(+input);
            } else if (typeof input === 'string') {
                configFromString(config);
            } else if (isArray(input)) {
                config._a = map(input.slice(0), function (obj) {
                    return parseInt(obj, 10);
                });
                configFromArray(config);
            } else if (typeof(input) === 'object') {
                configFromObject(config);
            } else if (typeof(input) === 'number') {
                // from milliseconds
                config._d = new Date(input);
            } else {
                utils_hooks__hooks.createFromInputFallback(config);
            }
        }
    
        function createLocalOrUTC (input, format, locale, strict, isUTC) {
            var c = {};
    
            if (typeof(locale) === 'boolean') {
                strict = locale;
                locale = undefined;
            }
            // object construction must be done this way.
            // https://github.com/moment/moment/issues/1423
            c._isAMomentObject = true;
            c._useUTC = c._isUTC = isUTC;
            c._l = locale;
            c._i = input;
            c._f = format;
            c._strict = strict;
    
            return createFromConfig(c);
        }
    
        function local__createLocal (input, format, locale, strict) {
            return createLocalOrUTC(input, format, locale, strict, false);
        }
    
        var prototypeMin = deprecate(
             'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
             function () {
                 var other = local__createLocal.apply(null, arguments);
                 return other < this ? this : other;
             }
         );
    
        var prototypeMax = deprecate(
            'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
            function () {
                var other = local__createLocal.apply(null, arguments);
                return other > this ? this : other;
            }
        );
    
        // Pick a moment m from moments so that m[fn](other) is true for all
        // other. This relies on the function fn to be transitive.
        //
        // moments should either be an array of moment objects or an array, whose
        // first element is an array of moment objects.
        function pickBy(fn, moments) {
            var res, i;
            if (moments.length === 1 && isArray(moments[0])) {
                moments = moments[0];
            }
            if (!moments.length) {
                return local__createLocal();
            }
            res = moments[0];
            for (i = 1; i < moments.length; ++i) {
                if (moments[i][fn](res)) {
                    res = moments[i];
                }
            }
            return res;
        }
    
        // TODO: Use [].sort instead?
        function min () {
            var args = [].slice.call(arguments, 0);
    
            return pickBy('isBefore', args);
        }
    
        function max () {
            var args = [].slice.call(arguments, 0);
    
            return pickBy('isAfter', args);
        }
    
        function Duration (duration) {
            var normalizedInput = normalizeObjectUnits(duration),
                years = normalizedInput.year || 0,
                quarters = normalizedInput.quarter || 0,
                months = normalizedInput.month || 0,
                weeks = normalizedInput.week || 0,
                days = normalizedInput.day || 0,
                hours = normalizedInput.hour || 0,
                minutes = normalizedInput.minute || 0,
                seconds = normalizedInput.second || 0,
                milliseconds = normalizedInput.millisecond || 0;
    
            // representation for dateAddRemove
            this._milliseconds = +milliseconds +
                seconds * 1e3 + // 1000
                minutes * 6e4 + // 1000 * 60
                hours * 36e5; // 1000 * 60 * 60
            // Because of dateAddRemove treats 24 hours as different from a
            // day when working around DST, we need to store them separately
            this._days = +days +
                weeks * 7;
            // It is impossible translate months into days without knowing
            // which months you are are talking about, so we have to store
            // it separately.
            this._months = +months +
                quarters * 3 +
                years * 12;
    
            this._data = {};
    
            this._locale = locale_locales__getLocale();
    
            this._bubble();
        }
    
        function isDuration (obj) {
            return obj instanceof Duration;
        }
    
        function offset (token, separator) {
            addFormatToken(token, 0, 0, function () {
                var offset = this.utcOffset();
                var sign = '+';
                if (offset < 0) {
                    offset = -offset;
                    sign = '-';
                }
                return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
            });
        }
    
        offset('Z', ':');
        offset('ZZ', '');
    
        // PARSING
    
        addRegexToken('Z',  matchOffset);
        addRegexToken('ZZ', matchOffset);
        addParseToken(['Z', 'ZZ'], function (input, array, config) {
            config._useUTC = true;
            config._tzm = offsetFromString(input);
        });
    
        // HELPERS
    
        // timezone chunker
        // '+10:00' > ['10',  '00']
        // '-1530'  > ['-15', '30']
        var chunkOffset = /([\+\-]|\d\d)/gi;
    
        function offsetFromString(string) {
            var matches = ((string || '').match(matchOffset) || []);
            var chunk   = matches[matches.length - 1] || [];
            var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
            var minutes = +(parts[1] * 60) + toInt(parts[2]);
    
            return parts[0] === '+' ? minutes : -minutes;
        }
    
        // Return a moment from input, that is local/utc/zone equivalent to model.
        function cloneWithOffset(input, model) {
            var res, diff;
            if (model._isUTC) {
                res = model.clone();
                diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
                // Use low-level api, because this fn is low-level api.
                res._d.setTime(+res._d + diff);
                utils_hooks__hooks.updateOffset(res, false);
                return res;
            } else {
                return local__createLocal(input).local();
            }
            return model._isUTC ? local__createLocal(input).zone(model._offset || 0) : local__createLocal(input).local();
        }
    
        function getDateOffset (m) {
            // On Firefox.24 Date#getTimezoneOffset returns a floating point.
            // https://github.com/moment/moment/pull/1871
            return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
        }
    
        // HOOKS
    
        // This function will be called whenever a moment is mutated.
        // It is intended to keep the offset in sync with the timezone.
        utils_hooks__hooks.updateOffset = function () {};
    
        // MOMENTS
    
        // keepLocalTime = true means only change the timezone, without
        // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
        // +0200, so we adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        function getSetOffset (input, keepLocalTime) {
            var offset = this._offset || 0,
                localAdjust;
            if (input != null) {
                if (typeof input === 'string') {
                    input = offsetFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                if (!this._isUTC && keepLocalTime) {
                    localAdjust = getDateOffset(this);
                }
                this._offset = input;
                this._isUTC = true;
                if (localAdjust != null) {
                    this.add(localAdjust, 'm');
                }
                if (offset !== input) {
                    if (!keepLocalTime || this._changeInProgress) {
                        add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        utils_hooks__hooks.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
                return this;
            } else {
                return this._isUTC ? offset : getDateOffset(this);
            }
        }
    
        function getSetZone (input, keepLocalTime) {
            if (input != null) {
                if (typeof input !== 'string') {
                    input = -input;
                }
    
                this.utcOffset(input, keepLocalTime);
    
                return this;
            } else {
                return -this.utcOffset();
            }
        }
    
        function setOffsetToUTC (keepLocalTime) {
            return this.utcOffset(0, keepLocalTime);
        }
    
        function setOffsetToLocal (keepLocalTime) {
            if (this._isUTC) {
                this.utcOffset(0, keepLocalTime);
                this._isUTC = false;
    
                if (keepLocalTime) {
                    this.subtract(getDateOffset(this), 'm');
                }
            }
            return this;
        }
    
        function setOffsetToParsedOffset () {
            if (this._tzm) {
                this.utcOffset(this._tzm);
            } else if (typeof this._i === 'string') {
                this.utcOffset(offsetFromString(this._i));
            }
            return this;
        }
    
        function hasAlignedHourOffset (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = local__createLocal(input).utcOffset();
            }
    
            return (this.utcOffset() - input) % 60 === 0;
        }
    
        function isDaylightSavingTime () {
            return (
                this.utcOffset() > this.clone().month(0).utcOffset() ||
                this.utcOffset() > this.clone().month(5).utcOffset()
            );
        }
    
        function isDaylightSavingTimeShifted () {
            if (this._a) {
                var other = this._isUTC ? create_utc__createUTC(this._a) : local__createLocal(this._a);
                return this.isValid() && compareArrays(this._a, other.toArray()) > 0;
            }
    
            return false;
        }
    
        function isLocal () {
            return !this._isUTC;
        }
    
        function isUtcOffset () {
            return this._isUTC;
        }
    
        function isUtc () {
            return this._isUTC && this._offset === 0;
        }
    
        var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;
    
        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;
    
        function create__createDuration (input, key) {
            var duration = input,
                // matching against regexp is expensive, do it on demand
                match = null,
                sign,
                ret,
                diffRes;
    
            if (isDuration(input)) {
                duration = {
                    ms : input._milliseconds,
                    d  : input._days,
                    M  : input._months
                };
            } else if (typeof input === 'number') {
                duration = {};
                if (key) {
                    duration[key] = input;
                } else {
                    duration.milliseconds = input;
                }
            } else if (!!(match = aspNetRegex.exec(input))) {
                sign = (match[1] === '-') ? -1 : 1;
                duration = {
                    y  : 0,
                    d  : toInt(match[DATE])        * sign,
                    h  : toInt(match[HOUR])        * sign,
                    m  : toInt(match[MINUTE])      * sign,
                    s  : toInt(match[SECOND])      * sign,
                    ms : toInt(match[MILLISECOND]) * sign
                };
            } else if (!!(match = create__isoRegex.exec(input))) {
                sign = (match[1] === '-') ? -1 : 1;
                duration = {
                    y : parseIso(match[2], sign),
                    M : parseIso(match[3], sign),
                    d : parseIso(match[4], sign),
                    h : parseIso(match[5], sign),
                    m : parseIso(match[6], sign),
                    s : parseIso(match[7], sign),
                    w : parseIso(match[8], sign)
                };
            } else if (duration == null) {// checks for null or undefined
                duration = {};
            } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
                diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
    
                duration = {};
                duration.ms = diffRes.milliseconds;
                duration.M = diffRes.months;
            }
    
            ret = new Duration(duration);
    
            if (isDuration(input) && hasOwnProp(input, '_locale')) {
                ret._locale = input._locale;
            }
    
            return ret;
        }
    
        create__createDuration.fn = Duration.prototype;
    
        function parseIso (inp, sign) {
            // We'd normally use ~~inp for this, but unfortunately it also
            // converts floats to ints.
            // inp may be undefined, so careful calling replace on it.
            var res = inp && parseFloat(inp.replace(',', '.'));
            // apply sign while we're at it
            return (isNaN(res) ? 0 : res) * sign;
        }
    
        function positiveMomentsDifference(base, other) {
            var res = {milliseconds: 0, months: 0};
    
            res.months = other.month() - base.month() +
                (other.year() - base.year()) * 12;
            if (base.clone().add(res.months, 'M').isAfter(other)) {
                --res.months;
            }
    
            res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
    
            return res;
        }
    
        function momentsDifference(base, other) {
            var res;
            other = cloneWithOffset(other, base);
            if (base.isBefore(other)) {
                res = positiveMomentsDifference(base, other);
            } else {
                res = positiveMomentsDifference(other, base);
                res.milliseconds = -res.milliseconds;
                res.months = -res.months;
            }
    
            return res;
        }
    
        function createAdder(direction, name) {
            return function (val, period) {
                var dur, tmp;
                //invert the arguments, but complain about it
                if (period !== null && !isNaN(+period)) {
                    deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                    tmp = val; val = period; period = tmp;
                }
    
                val = typeof val === 'string' ? +val : val;
                dur = create__createDuration(val, period);
                add_subtract__addSubtract(this, dur, direction);
                return this;
            };
        }
    
        function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
            var milliseconds = duration._milliseconds,
                days = duration._days,
                months = duration._months;
            updateOffset = updateOffset == null ? true : updateOffset;
    
            if (milliseconds) {
                mom._d.setTime(+mom._d + milliseconds * isAdding);
            }
            if (days) {
                get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
            }
            if (months) {
                setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
            }
            if (updateOffset) {
                utils_hooks__hooks.updateOffset(mom, days || months);
            }
        }
    
        var add_subtract__add      = createAdder(1, 'add');
        var add_subtract__subtract = createAdder(-1, 'subtract');
    
        function moment_calendar__calendar (time) {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're local/utc/offset or not.
            var now = time || local__createLocal(),
                sod = cloneWithOffset(now, this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                    diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                    diff < 2 ? 'nextDay' :
                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.localeData().calendar(format, this, local__createLocal(now)));
        }
    
        function clone () {
            return new Moment(this);
        }
    
        function isAfter (input, units) {
            var inputMs;
            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
            if (units === 'millisecond') {
                input = isMoment(input) ? input : local__createLocal(input);
                return +this > +input;
            } else {
                inputMs = isMoment(input) ? +input : +local__createLocal(input);
                return inputMs < +this.clone().startOf(units);
            }
        }
    
        function isBefore (input, units) {
            var inputMs;
            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
            if (units === 'millisecond') {
                input = isMoment(input) ? input : local__createLocal(input);
                return +this < +input;
            } else {
                inputMs = isMoment(input) ? +input : +local__createLocal(input);
                return +this.clone().endOf(units) < inputMs;
            }
        }
    
        function isBetween (from, to, units) {
            return this.isAfter(from, units) && this.isBefore(to, units);
        }
    
        function isSame (input, units) {
            var inputMs;
            units = normalizeUnits(units || 'millisecond');
            if (units === 'millisecond') {
                input = isMoment(input) ? input : local__createLocal(input);
                return +this === +input;
            } else {
                inputMs = +local__createLocal(input);
                return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
            }
        }
    
        function absFloor (number) {
            if (number < 0) {
                return Math.ceil(number);
            } else {
                return Math.floor(number);
            }
        }
    
        function diff (input, units, asFloat) {
            var that = cloneWithOffset(input, this),
                zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,
                delta, output;
    
            units = normalizeUnits(units);
    
            if (units === 'year' || units === 'month' || units === 'quarter') {
                output = monthDiff(this, that);
                if (units === 'quarter') {
                    output = output / 3;
                } else if (units === 'year') {
                    output = output / 12;
                }
            } else {
                delta = this - that;
                output = units === 'second' ? delta / 1e3 : // 1000
                    units === 'minute' ? delta / 6e4 : // 1000 * 60
                    units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    delta;
            }
            return asFloat ? output : absFloor(output);
        }
    
        function monthDiff (a, b) {
            // difference in months
            var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
                // b is in (anchor - 1 month, anchor + 1 month)
                anchor = a.clone().add(wholeMonthDiff, 'months'),
                anchor2, adjust;
    
            if (b - anchor < 0) {
                anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
                // linear across the month
                adjust = (b - anchor) / (anchor - anchor2);
            } else {
                anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
                // linear across the month
                adjust = (b - anchor) / (anchor2 - anchor);
            }
    
            return -(wholeMonthDiff + adjust);
        }
    
        utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    
        function toString () {
            return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
        }
    
        function moment_format__toISOString () {
            var m = this.clone().utc();
            if (0 < m.year() && m.year() <= 9999) {
                if ('function' === typeof Date.prototype.toISOString) {
                    // native implementation is ~50x faster, use it when we can
                    return this.toDate().toISOString();
                } else {
                    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
                }
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        }
    
        function format (inputString) {
            var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
            return this.localeData().postformat(output);
        }
    
        function from (time, withoutSuffix) {
            if (!this.isValid()) {
                return this.localeData().invalidDate();
            }
            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        }
    
        function fromNow (withoutSuffix) {
            return this.from(local__createLocal(), withoutSuffix);
        }
    
        function to (time, withoutSuffix) {
            if (!this.isValid()) {
                return this.localeData().invalidDate();
            }
            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        }
    
        function toNow (withoutSuffix) {
            return this.to(local__createLocal(), withoutSuffix);
        }
    
        function locale (key) {
            var newLocaleData;
    
            if (key === undefined) {
                return this._locale._abbr;
            } else {
                newLocaleData = locale_locales__getLocale(key);
                if (newLocaleData != null) {
                    this._locale = newLocaleData;
                }
                return this;
            }
        }
    
        var lang = deprecate(
            'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
            function (key) {
                if (key === undefined) {
                    return this.localeData();
                } else {
                    return this.locale(key);
                }
            }
        );
    
        function localeData () {
            return this._locale;
        }
    
        function startOf (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
            }
    
            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            }
            if (units === 'isoWeek') {
                this.isoWeekday(1);
            }
    
            // quarters are also special
            if (units === 'quarter') {
                this.month(Math.floor(this.month() / 3) * 3);
            }
    
            return this;
        }
    
        function endOf (units) {
            units = normalizeUnits(units);
            if (units === undefined || units === 'millisecond') {
                return this;
            }
            return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
        }
    
        function to_type__valueOf () {
            return +this._d - ((this._offset || 0) * 60000);
        }
    
        function unix () {
            return Math.floor(+this / 1000);
        }
    
        function toDate () {
            return this._offset ? new Date(+this) : this._d;
        }
    
        function toArray () {
            var m = this;
            return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
        }
    
        function moment_valid__isValid () {
            return valid__isValid(this);
        }
    
        function parsingFlags () {
            return extend({}, getParsingFlags(this));
        }
    
        function invalidAt () {
            return getParsingFlags(this).overflow;
        }
    
        addFormatToken(0, ['gg', 2], 0, function () {
            return this.weekYear() % 100;
        });
    
        addFormatToken(0, ['GG', 2], 0, function () {
            return this.isoWeekYear() % 100;
        });
    
        function addWeekYearFormatToken (token, getter) {
            addFormatToken(0, [token, token.length], 0, getter);
        }
    
        addWeekYearFormatToken('gggg',     'weekYear');
        addWeekYearFormatToken('ggggg',    'weekYear');
        addWeekYearFormatToken('GGGG',  'isoWeekYear');
        addWeekYearFormatToken('GGGGG', 'isoWeekYear');
    
        // ALIASES
    
        addUnitAlias('weekYear', 'gg');
        addUnitAlias('isoWeekYear', 'GG');
    
        // PARSING
    
        addRegexToken('G',      matchSigned);
        addRegexToken('g',      matchSigned);
        addRegexToken('GG',     match1to2, match2);
        addRegexToken('gg',     match1to2, match2);
        addRegexToken('GGGG',   match1to4, match4);
        addRegexToken('gggg',   match1to4, match4);
        addRegexToken('GGGGG',  match1to6, match6);
        addRegexToken('ggggg',  match1to6, match6);
    
        addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
            week[token.substr(0, 2)] = toInt(input);
        });
    
        addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
            week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
        });
    
        // HELPERS
    
        function weeksInYear(year, dow, doy) {
            return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;
        }
    
        // MOMENTS
    
        function getSetWeekYear (input) {
            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
            return input == null ? year : this.add((input - year), 'y');
        }
    
        function getSetISOWeekYear (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add((input - year), 'y');
        }
    
        function getISOWeeksInYear () {
            return weeksInYear(this.year(), 1, 4);
        }
    
        function getWeeksInYear () {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }
    
        addFormatToken('Q', 0, 0, 'quarter');
    
        // ALIASES
    
        addUnitAlias('quarter', 'Q');
    
        // PARSING
    
        addRegexToken('Q', match1);
        addParseToken('Q', function (input, array) {
            array[MONTH] = (toInt(input) - 1) * 3;
        });
    
        // MOMENTS
    
        function getSetQuarter (input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        }
    
        addFormatToken('D', ['DD', 2], 'Do', 'date');
    
        // ALIASES
    
        addUnitAlias('date', 'D');
    
        // PARSING
    
        addRegexToken('D',  match1to2);
        addRegexToken('DD', match1to2, match2);
        addRegexToken('Do', function (isStrict, locale) {
            return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
        });
    
        addParseToken(['D', 'DD'], DATE);
        addParseToken('Do', function (input, array) {
            array[DATE] = toInt(input.match(match1to2)[0], 10);
        });
    
        // MOMENTS
    
        var getSetDayOfMonth = makeGetSet('Date', true);
    
        addFormatToken('d', 0, 'do', 'day');
    
        addFormatToken('dd', 0, 0, function (format) {
            return this.localeData().weekdaysMin(this, format);
        });
    
        addFormatToken('ddd', 0, 0, function (format) {
            return this.localeData().weekdaysShort(this, format);
        });
    
        addFormatToken('dddd', 0, 0, function (format) {
            return this.localeData().weekdays(this, format);
        });
    
        addFormatToken('e', 0, 0, 'weekday');
        addFormatToken('E', 0, 0, 'isoWeekday');
    
        // ALIASES
    
        addUnitAlias('day', 'd');
        addUnitAlias('weekday', 'e');
        addUnitAlias('isoWeekday', 'E');
    
        // PARSING
    
        addRegexToken('d',    match1to2);
        addRegexToken('e',    match1to2);
        addRegexToken('E',    match1to2);
        addRegexToken('dd',   matchWord);
        addRegexToken('ddd',  matchWord);
        addRegexToken('dddd', matchWord);
    
        addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config) {
            var weekday = config._locale.weekdaysParse(input);
            // if we didn't get a weekday name, mark the date as invalid
            if (weekday != null) {
                week.d = weekday;
            } else {
                getParsingFlags(config).invalidWeekday = input;
            }
        });
    
        addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
            week[token] = toInt(input);
        });
    
        // HELPERS
    
        function parseWeekday(input, locale) {
            if (typeof input === 'string') {
                if (!isNaN(input)) {
                    input = parseInt(input, 10);
                }
                else {
                    input = locale.weekdaysParse(input);
                    if (typeof input !== 'number') {
                        return null;
                    }
                }
            }
            return input;
        }
    
        // LOCALES
    
        var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
        function localeWeekdays (m) {
            return this._weekdays[m.day()];
        }
    
        var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
        function localeWeekdaysShort (m) {
            return this._weekdaysShort[m.day()];
        }
    
        var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
        function localeWeekdaysMin (m) {
            return this._weekdaysMin[m.day()];
        }
    
        function localeWeekdaysParse (weekdayName) {
            var i, mom, regex;
    
            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }
    
            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = local__createLocal([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        }
    
        // MOMENTS
    
        function getSetDayOfWeek (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.localeData());
                return this.add(input - day, 'd');
            } else {
                return day;
            }
        }
    
        function getSetLocaleDayOfWeek (input) {
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, 'd');
        }
    
        function getSetISODayOfWeek (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        }
    
        addFormatToken('H', ['HH', 2], 0, 'hour');
        addFormatToken('h', ['hh', 2], 0, function () {
            return this.hours() % 12 || 12;
        });
    
        function meridiem (token, lowercase) {
            addFormatToken(token, 0, 0, function () {
                return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
            });
        }
    
        meridiem('a', true);
        meridiem('A', false);
    
        // ALIASES
    
        addUnitAlias('hour', 'h');
    
        // PARSING
    
        function matchMeridiem (isStrict, locale) {
            return locale._meridiemParse;
        }
    
        addRegexToken('a',  matchMeridiem);
        addRegexToken('A',  matchMeridiem);
        addRegexToken('H',  match1to2);
        addRegexToken('h',  match1to2);
        addRegexToken('HH', match1to2, match2);
        addRegexToken('hh', match1to2, match2);
    
        addParseToken(['H', 'HH'], HOUR);
        addParseToken(['a', 'A'], function (input, array, config) {
            config._isPm = config._locale.isPM(input);
            config._meridiem = input;
        });
        addParseToken(['h', 'hh'], function (input, array, config) {
            array[HOUR] = toInt(input);
            getParsingFlags(config).bigHour = true;
        });
    
        // LOCALES
    
        function localeIsPM (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        }
    
        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
        function localeMeridiem (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        }
    
    
        // MOMENTS
    
        // Setting the hour should keep the time, because the user explicitly
        // specified which hour he wants. So trying to maintain the same hour (in
        // a new timezone) makes sense. Adding/subtracting hours does not follow
        // this rule.
        var getSetHour = makeGetSet('Hours', true);
    
        addFormatToken('m', ['mm', 2], 0, 'minute');
    
        // ALIASES
    
        addUnitAlias('minute', 'm');
    
        // PARSING
    
        addRegexToken('m',  match1to2);
        addRegexToken('mm', match1to2, match2);
        addParseToken(['m', 'mm'], MINUTE);
    
        // MOMENTS
    
        var getSetMinute = makeGetSet('Minutes', false);
    
        addFormatToken('s', ['ss', 2], 0, 'second');
    
        // ALIASES
    
        addUnitAlias('second', 's');
    
        // PARSING
    
        addRegexToken('s',  match1to2);
        addRegexToken('ss', match1to2, match2);
        addParseToken(['s', 'ss'], SECOND);
    
        // MOMENTS
    
        var getSetSecond = makeGetSet('Seconds', false);
    
        addFormatToken('S', 0, 0, function () {
            return ~~(this.millisecond() / 100);
        });
    
        addFormatToken(0, ['SS', 2], 0, function () {
            return ~~(this.millisecond() / 10);
        });
    
        function millisecond__milliseconds (token) {
            addFormatToken(0, [token, 3], 0, 'millisecond');
        }
    
        millisecond__milliseconds('SSS');
        millisecond__milliseconds('SSSS');
    
        // ALIASES
    
        addUnitAlias('millisecond', 'ms');
    
        // PARSING
    
        addRegexToken('S',    match1to3, match1);
        addRegexToken('SS',   match1to3, match2);
        addRegexToken('SSS',  match1to3, match3);
        addRegexToken('SSSS', matchUnsigned);
        addParseToken(['S', 'SS', 'SSS', 'SSSS'], function (input, array) {
            array[MILLISECOND] = toInt(('0.' + input) * 1000);
        });
    
        // MOMENTS
    
        var getSetMillisecond = makeGetSet('Milliseconds', false);
    
        addFormatToken('z',  0, 0, 'zoneAbbr');
        addFormatToken('zz', 0, 0, 'zoneName');
    
        // MOMENTS
    
        function getZoneAbbr () {
            return this._isUTC ? 'UTC' : '';
        }
    
        function getZoneName () {
            return this._isUTC ? 'Coordinated Universal Time' : '';
        }
    
        var momentPrototype__proto = Moment.prototype;
    
        momentPrototype__proto.add          = add_subtract__add;
        momentPrototype__proto.calendar     = moment_calendar__calendar;
        momentPrototype__proto.clone        = clone;
        momentPrototype__proto.diff         = diff;
        momentPrototype__proto.endOf        = endOf;
        momentPrototype__proto.format       = format;
        momentPrototype__proto.from         = from;
        momentPrototype__proto.fromNow      = fromNow;
        momentPrototype__proto.to           = to;
        momentPrototype__proto.toNow        = toNow;
        momentPrototype__proto.get          = getSet;
        momentPrototype__proto.invalidAt    = invalidAt;
        momentPrototype__proto.isAfter      = isAfter;
        momentPrototype__proto.isBefore     = isBefore;
        momentPrototype__proto.isBetween    = isBetween;
        momentPrototype__proto.isSame       = isSame;
        momentPrototype__proto.isValid      = moment_valid__isValid;
        momentPrototype__proto.lang         = lang;
        momentPrototype__proto.locale       = locale;
        momentPrototype__proto.localeData   = localeData;
        momentPrototype__proto.max          = prototypeMax;
        momentPrototype__proto.min          = prototypeMin;
        momentPrototype__proto.parsingFlags = parsingFlags;
        momentPrototype__proto.set          = getSet;
        momentPrototype__proto.startOf      = startOf;
        momentPrototype__proto.subtract     = add_subtract__subtract;
        momentPrototype__proto.toArray      = toArray;
        momentPrototype__proto.toDate       = toDate;
        momentPrototype__proto.toISOString  = moment_format__toISOString;
        momentPrototype__proto.toJSON       = moment_format__toISOString;
        momentPrototype__proto.toString     = toString;
        momentPrototype__proto.unix         = unix;
        momentPrototype__proto.valueOf      = to_type__valueOf;
    
        // Year
        momentPrototype__proto.year       = getSetYear;
        momentPrototype__proto.isLeapYear = getIsLeapYear;
    
        // Week Year
        momentPrototype__proto.weekYear    = getSetWeekYear;
        momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
    
        // Quarter
        momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
    
        // Month
        momentPrototype__proto.month       = getSetMonth;
        momentPrototype__proto.daysInMonth = getDaysInMonth;
    
        // Week
        momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
        momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
        momentPrototype__proto.weeksInYear    = getWeeksInYear;
        momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
    
        // Day
        momentPrototype__proto.date       = getSetDayOfMonth;
        momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
        momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
        momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
        momentPrototype__proto.dayOfYear  = getSetDayOfYear;
    
        // Hour
        momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
    
        // Minute
        momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
    
        // Second
        momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
    
        // Millisecond
        momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
    
        // Offset
        momentPrototype__proto.utcOffset            = getSetOffset;
        momentPrototype__proto.utc                  = setOffsetToUTC;
        momentPrototype__proto.local                = setOffsetToLocal;
        momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
        momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
        momentPrototype__proto.isDST                = isDaylightSavingTime;
        momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
        momentPrototype__proto.isLocal              = isLocal;
        momentPrototype__proto.isUtcOffset          = isUtcOffset;
        momentPrototype__proto.isUtc                = isUtc;
        momentPrototype__proto.isUTC                = isUtc;
    
        // Timezone
        momentPrototype__proto.zoneAbbr = getZoneAbbr;
        momentPrototype__proto.zoneName = getZoneName;
    
        // Deprecations
        momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
        momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
        momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
        momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);
    
        var momentPrototype = momentPrototype__proto;
    
        function moment__createUnix (input) {
            return local__createLocal(input * 1000);
        }
    
        function moment__createInZone () {
            return local__createLocal.apply(null, arguments).parseZone();
        }
    
        var defaultCalendar = {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        };
    
        function locale_calendar__calendar (key, mom, now) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.call(mom, now) : output;
        }
    
        var defaultLongDateFormat = {
            LTS  : 'h:mm:ss A',
            LT   : 'h:mm A',
            L    : 'MM/DD/YYYY',
            LL   : 'MMMM D, YYYY',
            LLL  : 'MMMM D, YYYY LT',
            LLLL : 'dddd, MMMM D, YYYY LT'
        };
    
        function longDateFormat (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        }
    
        var defaultInvalidDate = 'Invalid date';
    
        function invalidDate () {
            return this._invalidDate;
        }
    
        var defaultOrdinal = '%d';
        var defaultOrdinalParse = /\d{1,2}/;
    
        function ordinal (number) {
            return this._ordinal.replace('%d', number);
        }
    
        function preParsePostFormat (string) {
            return string;
        }
    
        var defaultRelativeTime = {
            future : 'in %s',
            past   : '%s ago',
            s  : 'a few seconds',
            m  : 'a minute',
            mm : '%d minutes',
            h  : 'an hour',
            hh : '%d hours',
            d  : 'a day',
            dd : '%d days',
            M  : 'a month',
            MM : '%d months',
            y  : 'a year',
            yy : '%d years'
        };
    
        function relative__relativeTime (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        }
    
        function pastFuture (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        }
    
        function locale_set__set (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
            // Lenient ordinal parsing accepts just a number in addition to
            // number + (possibly) stuff coming from _ordinalParseLenient.
            this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
        }
    
        var prototype__proto = Locale.prototype;
    
        prototype__proto._calendar       = defaultCalendar;
        prototype__proto.calendar        = locale_calendar__calendar;
        prototype__proto._longDateFormat = defaultLongDateFormat;
        prototype__proto.longDateFormat  = longDateFormat;
        prototype__proto._invalidDate    = defaultInvalidDate;
        prototype__proto.invalidDate     = invalidDate;
        prototype__proto._ordinal        = defaultOrdinal;
        prototype__proto.ordinal         = ordinal;
        prototype__proto._ordinalParse   = defaultOrdinalParse;
        prototype__proto.preparse        = preParsePostFormat;
        prototype__proto.postformat      = preParsePostFormat;
        prototype__proto._relativeTime   = defaultRelativeTime;
        prototype__proto.relativeTime    = relative__relativeTime;
        prototype__proto.pastFuture      = pastFuture;
        prototype__proto.set             = locale_set__set;
    
        // Month
        prototype__proto.months       =        localeMonths;
        prototype__proto._months      = defaultLocaleMonths;
        prototype__proto.monthsShort  =        localeMonthsShort;
        prototype__proto._monthsShort = defaultLocaleMonthsShort;
        prototype__proto.monthsParse  =        localeMonthsParse;
    
        // Week
        prototype__proto.week = localeWeek;
        prototype__proto._week = defaultLocaleWeek;
        prototype__proto.firstDayOfYear = localeFirstDayOfYear;
        prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
    
        // Day of Week
        prototype__proto.weekdays       =        localeWeekdays;
        prototype__proto._weekdays      = defaultLocaleWeekdays;
        prototype__proto.weekdaysMin    =        localeWeekdaysMin;
        prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
        prototype__proto.weekdaysShort  =        localeWeekdaysShort;
        prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
        prototype__proto.weekdaysParse  =        localeWeekdaysParse;
    
        // Hours
        prototype__proto.isPM = localeIsPM;
        prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
        prototype__proto.meridiem = localeMeridiem;
    
        function lists__get (format, index, field, setter) {
            var locale = locale_locales__getLocale();
            var utc = create_utc__createUTC().set(setter, index);
            return locale[field](utc, format);
        }
    
        function list (format, index, field, count, setter) {
            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }
    
            format = format || '';
    
            if (index != null) {
                return lists__get(format, index, field, setter);
            }
    
            var i;
            var out = [];
            for (i = 0; i < count; i++) {
                out[i] = lists__get(format, i, field, setter);
            }
            return out;
        }
    
        function lists__listMonths (format, index) {
            return list(format, index, 'months', 12, 'month');
        }
    
        function lists__listMonthsShort (format, index) {
            return list(format, index, 'monthsShort', 12, 'month');
        }
    
        function lists__listWeekdays (format, index) {
            return list(format, index, 'weekdays', 7, 'day');
        }
    
        function lists__listWeekdaysShort (format, index) {
            return list(format, index, 'weekdaysShort', 7, 'day');
        }
    
        function lists__listWeekdaysMin (format, index) {
            return list(format, index, 'weekdaysMin', 7, 'day');
        }
    
        locale_locales__getSetGlobalLocale('en', {
            ordinalParse: /\d{1,2}(th|st|nd|rd)/,
            ordinal : function (number) {
                var b = number % 10,
                    output = (toInt(number % 100 / 10) === 1) ? 'th' :
                    (b === 1) ? 'st' :
                    (b === 2) ? 'nd' :
                    (b === 3) ? 'rd' : 'th';
                return number + output;
            }
        });
    
        // Side effect imports
        utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
        utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);
    
        var mathAbs = Math.abs;
    
        function duration_abs__abs () {
            var data           = this._data;
    
            this._milliseconds = mathAbs(this._milliseconds);
            this._days         = mathAbs(this._days);
            this._months       = mathAbs(this._months);
    
            data.milliseconds  = mathAbs(data.milliseconds);
            data.seconds       = mathAbs(data.seconds);
            data.minutes       = mathAbs(data.minutes);
            data.hours         = mathAbs(data.hours);
            data.months        = mathAbs(data.months);
            data.years         = mathAbs(data.years);
    
            return this;
        }
    
        function duration_add_subtract__addSubtract (duration, input, value, direction) {
            var other = create__createDuration(input, value);
    
            duration._milliseconds += direction * other._milliseconds;
            duration._days         += direction * other._days;
            duration._months       += direction * other._months;
    
            return duration._bubble();
        }
    
        // supports only 2.0-style add(1, 's') or add(duration)
        function duration_add_subtract__add (input, value) {
            return duration_add_subtract__addSubtract(this, input, value, 1);
        }
    
        // supports only 2.0-style subtract(1, 's') or subtract(duration)
        function duration_add_subtract__subtract (input, value) {
            return duration_add_subtract__addSubtract(this, input, value, -1);
        }
    
        function bubble () {
            var milliseconds = this._milliseconds;
            var days         = this._days;
            var months       = this._months;
            var data         = this._data;
            var seconds, minutes, hours, years = 0;
    
            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;
    
            seconds           = absFloor(milliseconds / 1000);
            data.seconds      = seconds % 60;
    
            minutes           = absFloor(seconds / 60);
            data.minutes      = minutes % 60;
    
            hours             = absFloor(minutes / 60);
            data.hours        = hours % 24;
    
            days += absFloor(hours / 24);
    
            // Accurately convert days to years, assume start from year 0.
            years = absFloor(daysToYears(days));
            days -= absFloor(yearsToDays(years));
    
            // 30 days to a month
            // TODO (iskren): Use anchor date (like 1st Jan) to compute this.
            months += absFloor(days / 30);
            days   %= 30;
    
            // 12 months -> 1 year
            years  += absFloor(months / 12);
            months %= 12;
    
            data.days   = days;
            data.months = months;
            data.years  = years;
    
            return this;
        }
    
        function daysToYears (days) {
            // 400 years have 146097 days (taking into account leap year rules)
            return days * 400 / 146097;
        }
    
        function yearsToDays (years) {
            // years * 365 + absFloor(years / 4) -
            //     absFloor(years / 100) + absFloor(years / 400);
            return years * 146097 / 400;
        }
    
        function as (units) {
            var days;
            var months;
            var milliseconds = this._milliseconds;
    
            units = normalizeUnits(units);
    
            if (units === 'month' || units === 'year') {
                days   = this._days   + milliseconds / 864e5;
                months = this._months + daysToYears(days) * 12;
                return units === 'month' ? months : months / 12;
            } else {
                // handle milliseconds separately because of floating point math errors (issue #1867)
                days = this._days + Math.round(yearsToDays(this._months / 12));
                switch (units) {
                    case 'week'   : return days / 7     + milliseconds / 6048e5;
                    case 'day'    : return days         + milliseconds / 864e5;
                    case 'hour'   : return days * 24    + milliseconds / 36e5;
                    case 'minute' : return days * 1440  + milliseconds / 6e4;
                    case 'second' : return days * 86400 + milliseconds / 1000;
                    // Math.floor prevents floating point math errors here
                    case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                    default: throw new Error('Unknown unit ' + units);
                }
            }
        }
    
        // TODO: Use this.as('ms')?
        function duration_as__valueOf () {
            return (
                this._milliseconds +
                this._days * 864e5 +
                (this._months % 12) * 2592e6 +
                toInt(this._months / 12) * 31536e6
            );
        }
    
        function makeAs (alias) {
            return function () {
                return this.as(alias);
            };
        }
    
        var asMilliseconds = makeAs('ms');
        var asSeconds      = makeAs('s');
        var asMinutes      = makeAs('m');
        var asHours        = makeAs('h');
        var asDays         = makeAs('d');
        var asWeeks        = makeAs('w');
        var asMonths       = makeAs('M');
        var asYears        = makeAs('y');
    
        function duration_get__get (units) {
            units = normalizeUnits(units);
            return this[units + 's']();
        }
    
        function makeGetter(name) {
            return function () {
                return this._data[name];
            };
        }
    
        var duration_get__milliseconds = makeGetter('milliseconds');
        var seconds      = makeGetter('seconds');
        var minutes      = makeGetter('minutes');
        var hours        = makeGetter('hours');
        var days         = makeGetter('days');
        var months       = makeGetter('months');
        var years        = makeGetter('years');
    
        function weeks () {
            return absFloor(this.days() / 7);
        }
    
        var round = Math.round;
        var thresholds = {
            s: 45,  // seconds to minute
            m: 45,  // minutes to hour
            h: 22,  // hours to day
            d: 26,  // days to month
            M: 11   // months to year
        };
    
        // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
            return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }
    
        function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
            var duration = create__createDuration(posNegDuration).abs();
            var seconds  = round(duration.as('s'));
            var minutes  = round(duration.as('m'));
            var hours    = round(duration.as('h'));
            var days     = round(duration.as('d'));
            var months   = round(duration.as('M'));
            var years    = round(duration.as('y'));
    
            var a = seconds < thresholds.s && ['s', seconds]  ||
                    minutes === 1          && ['m']           ||
                    minutes < thresholds.m && ['mm', minutes] ||
                    hours   === 1          && ['h']           ||
                    hours   < thresholds.h && ['hh', hours]   ||
                    days    === 1          && ['d']           ||
                    days    < thresholds.d && ['dd', days]    ||
                    months  === 1          && ['M']           ||
                    months  < thresholds.M && ['MM', months]  ||
                    years   === 1          && ['y']           || ['yy', years];
    
            a[2] = withoutSuffix;
            a[3] = +posNegDuration > 0;
            a[4] = locale;
            return substituteTimeAgo.apply(null, a);
        }
    
        // This function allows you to set a threshold for relative time strings
        function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
            if (thresholds[threshold] === undefined) {
                return false;
            }
            if (limit === undefined) {
                return thresholds[threshold];
            }
            thresholds[threshold] = limit;
            return true;
        }
    
        function humanize (withSuffix) {
            var locale = this.localeData();
            var output = duration_humanize__relativeTime(this, !withSuffix, locale);
    
            if (withSuffix) {
                output = locale.pastFuture(+this, output);
            }
    
            return locale.postformat(output);
        }
    
        var iso_string__abs = Math.abs;
    
        function iso_string__toISOString() {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var Y = iso_string__abs(this.years());
            var M = iso_string__abs(this.months());
            var D = iso_string__abs(this.days());
            var h = iso_string__abs(this.hours());
            var m = iso_string__abs(this.minutes());
            var s = iso_string__abs(this.seconds() + this.milliseconds() / 1000);
            var total = this.asSeconds();
    
            if (!total) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }
    
            return (total < 0 ? '-' : '') +
                'P' +
                (Y ? Y + 'Y' : '') +
                (M ? M + 'M' : '') +
                (D ? D + 'D' : '') +
                ((h || m || s) ? 'T' : '') +
                (h ? h + 'H' : '') +
                (m ? m + 'M' : '') +
                (s ? s + 'S' : '');
        }
    
        var duration_prototype__proto = Duration.prototype;
    
        duration_prototype__proto.abs            = duration_abs__abs;
        duration_prototype__proto.add            = duration_add_subtract__add;
        duration_prototype__proto.subtract       = duration_add_subtract__subtract;
        duration_prototype__proto.as             = as;
        duration_prototype__proto.asMilliseconds = asMilliseconds;
        duration_prototype__proto.asSeconds      = asSeconds;
        duration_prototype__proto.asMinutes      = asMinutes;
        duration_prototype__proto.asHours        = asHours;
        duration_prototype__proto.asDays         = asDays;
        duration_prototype__proto.asWeeks        = asWeeks;
        duration_prototype__proto.asMonths       = asMonths;
        duration_prototype__proto.asYears        = asYears;
        duration_prototype__proto.valueOf        = duration_as__valueOf;
        duration_prototype__proto._bubble        = bubble;
        duration_prototype__proto.get            = duration_get__get;
        duration_prototype__proto.milliseconds   = duration_get__milliseconds;
        duration_prototype__proto.seconds        = seconds;
        duration_prototype__proto.minutes        = minutes;
        duration_prototype__proto.hours          = hours;
        duration_prototype__proto.days           = days;
        duration_prototype__proto.weeks          = weeks;
        duration_prototype__proto.months         = months;
        duration_prototype__proto.years          = years;
        duration_prototype__proto.humanize       = humanize;
        duration_prototype__proto.toISOString    = iso_string__toISOString;
        duration_prototype__proto.toString       = iso_string__toISOString;
        duration_prototype__proto.toJSON         = iso_string__toISOString;
        duration_prototype__proto.locale         = locale;
        duration_prototype__proto.localeData     = localeData;
    
        // Deprecations
        duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
        duration_prototype__proto.lang = lang;
    
        // Side effect imports
    
        addFormatToken('X', 0, 0, 'unix');
        addFormatToken('x', 0, 0, 'valueOf');
    
        // PARSING
    
        addRegexToken('x', matchSigned);
        addRegexToken('X', matchTimestamp);
        addParseToken('X', function (input, array, config) {
            config._d = new Date(parseFloat(input, 10) * 1000);
        });
        addParseToken('x', function (input, array, config) {
            config._d = new Date(toInt(input));
        });
    
        // Side effect imports
    
    
        utils_hooks__hooks.version = '2.10.3';
    
        setHookCallback(local__createLocal);
    
        utils_hooks__hooks.fn                    = momentPrototype;
        utils_hooks__hooks.min                   = min;
        utils_hooks__hooks.max                   = max;
        utils_hooks__hooks.utc                   = create_utc__createUTC;
        utils_hooks__hooks.unix                  = moment__createUnix;
        utils_hooks__hooks.months                = lists__listMonths;
        utils_hooks__hooks.isDate                = isDate;
        utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
        utils_hooks__hooks.invalid               = valid__createInvalid;
        utils_hooks__hooks.duration              = create__createDuration;
        utils_hooks__hooks.isMoment              = isMoment;
        utils_hooks__hooks.weekdays              = lists__listWeekdays;
        utils_hooks__hooks.parseZone             = moment__createInZone;
        utils_hooks__hooks.localeData            = locale_locales__getLocale;
        utils_hooks__hooks.isDuration            = isDuration;
        utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
        utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
        utils_hooks__hooks.defineLocale          = defineLocale;
        utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
        utils_hooks__hooks.normalizeUnits        = normalizeUnits;
        utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    
        var _moment = utils_hooks__hooks;
    
        return _moment;
    
    }));
  provide("moment", module.exports);
  $.ender(module.exports);
}(global));

// pakmanager:moment/ender-bridge
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  $.ender({ moment:  require('moment') })
    
  provide("moment/ender-bridge", module.exports);
  $.ender(module.exports);
}(global));

// pakmanager:cryptiles/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Crypto = require('crypto');
    var Boom = require('boom');
    
    
    // Declare internals
    
    var internals = {};
    
    
    // Generate a cryptographically strong pseudo-random data
    
    exports.randomString = function (size) {
    
        var buffer = exports.randomBits((size + 1) * 6);
        if (buffer instanceof Error) {
            return buffer;
        }
    
        var string = buffer.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
        return string.slice(0, size);
    };
    
    
    exports.randomBits = function (bits) {
    
        if (!bits ||
            bits < 0) {
    
            return Boom.internal('Invalid random bits count');
        }
    
        var bytes = Math.ceil(bits / 8);
        try {
            return Crypto.randomBytes(bytes);
        }
        catch (err) {
            return Boom.internal('Failed generating random bits: ' + err.message);
        }
    };
    
    
    // Compare two strings using fixed time algorithm (to prevent time-based analysis of MAC digest match)
    
    exports.fixedTimeComparison = function (a, b) {
    
        if (typeof a !== 'string' ||
            typeof b !== 'string') {
    
            return false;
        }
    
        var mismatch = (a.length === b.length ? 0 : 1);
        if (mismatch) {
            b = a;
        }
    
        for (var i = 0, il = a.length; i < il; ++i) {
            var ac = a.charCodeAt(i);
            var bc = b.charCodeAt(i);
            mismatch |= (ac ^ bc);
        }
    
        return (mismatch === 0);
    };
    
    
    
  provide("cryptiles/lib", module.exports);
}(global));

// pakmanager:cryptiles
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('cryptiles/lib');
  provide("cryptiles", module.exports);
}(global));

// pakmanager:b64
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
        Encode and decode functions adapted from:
        Version 1.0 12/25/99 Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
        http://www.onicos.com/staff/iz/amuse/javascript/expert/base64.txt
    */
    
    // Load modules
    
    var Stream = require('stream');
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {
        blank: new Buffer(''),
        decodeChars: [
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,
            -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1
        ]
    };
    
    
    exports.encode = function (buffer) {
    
        return new Buffer(buffer.toString('base64'));
    };
    
    
    exports.decode = function (buffer) {
    
        var decodeChars = internals.decodeChars;
        var len = buffer.length;
        var allocated = Math.ceil(len / 4) * 3;
        var result = new Buffer(allocated);
    
        var c1, c2, c3, c4;
        for (var i = 0, j = 0; i < len; ) {
            do {
                c1 = decodeChars[buffer[i++] & 0xff];
            }
            while (i < len && c1 === -1);
    
            if (c1 === -1) {
                break;
            }
    
            do {
                c2 = decodeChars[buffer[i++] & 0xff];
            }
            while (i < len && c2 === -1);
    
            if (c2 === -1) {
                break;
            }
    
            result[j++] = (c1 << 2) | ((c2 & 0x30) >> 4);
    
            do {
                c3 = buffer[i++] & 0xff;
                if (c3 === 61) {                        // =
                    return result.slice(0, j);
                }
    
                c3 = decodeChars[c3];
            }
            while (i < len && c3 === -1);
    
            if (c3 === -1) {
                break;
            }
    
            result[j++] = ((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2);
    
            do {
                c4 = buffer[i++] & 0xff;
                if (c4 === 61) {                        // =
                    return result.slice(0, j);
                }
    
                c4 = decodeChars[c4];
            }
            while (i < len && c4 === -1);
    
            if (c4 !== -1) {
                result[j++] = ((c3 & 0x03) << 6) | c4;
            }
        }
    
        return (j === allocated ? result : result.slice(0, j));
    };
    
    
    exports.Encoder = internals.Encoder = function () {
    
        Stream.Transform.call(this);
    
        this._reminder = null;
    };
    
    Hoek.inherits(internals.Encoder, Stream.Transform);
    
    
    internals.Encoder.prototype._transform = function (chunk, encoding, callback) {
    
        var part = this._reminder ? Buffer.concat([this._reminder, chunk]) : chunk;
        var remaining = part.length % 3;
        if (remaining) {
            this._reminder = part.slice(part.length - remaining);
            part = part.slice(0, part.length - remaining);
        }
        else {
            this._reminder = null;
        }
    
        this.push(exports.encode(part));
        return callback();
    };
    
    
    internals.Encoder.prototype._flush = function (callback) {
    
        if (this._reminder) {
            this.push(exports.encode(this._reminder));
        }
    
        return callback();
    };
    
    
    exports.Decoder = internals.Decoder = function () {
    
        Stream.Transform.call(this);
    
        this._reminder = null;
    };
    
    Hoek.inherits(internals.Decoder, Stream.Transform);
    
    
    internals.Decoder.prototype._transform = function (chunk, encoding, callback) {
    
        var part = this._reminder ? Buffer.concat([this._reminder, chunk]) : chunk;
        var remaining = part.length % 4;
        if (remaining) {
            this._reminder = part.slice(part.length - remaining);
            part = part.slice(0, part.length - remaining);
        }
        else {
            this._reminder = null;
        }
    
        this.push(exports.decode(part));
        return callback();
    };
    
    
    internals.Decoder.prototype._flush = function (callback) {
    
        if (this._reminder) {
            this.push(exports.decode(this._reminder));
        }
    
        return callback();
    };
    
  provide("b64", module.exports);
}(global));

// pakmanager:content
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Boom = require('boom');
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    
    /*
        RFC 7231 Section 3.1.1.1
    
        media-type = type "/" subtype *( OWS ";" OWS parameter )
        type       = token
        subtype    = token
        parameter  = token "=" ( token / quoted-string )
    */
    
    //                             1: type/subtype                    2: "b"   3: b
    internals.contentTypeRegex = /^([^\/]+\/[^\s;]+)(?:(?:\s*;\s*boundary=(?:"([^"]+)"|([^;"]+)))|(?:\s*;\s*[^=]+=(?:(?:"(?:[^"]+)")|(?:[^;"]+))))*$/i;
    
    
    exports.type = function (header) {
    
        var match = header.match(internals.contentTypeRegex);
        if (!match) {
            return Boom.badRequest('Invalid content-type header');
        }
    
        var mime = match[1].toLowerCase();
        var boundary = match[2] || match[3];
        if (mime.indexOf('multipart/') === 0 &&
            !boundary) {
    
            return Boom.badRequest('Invalid content-type header: multipart missing boundary');
        }
    
        return { mime: mime, boundary: boundary };
    };
    
    
    /*
        RFC 6266 Section 4.1 (http://tools.ietf.org/html/rfc6266#section-4.1)
    
        content-disposition = "Content-Disposition" ":" disposition-type *( ";" disposition-parm )
        disposition-type    = "inline" | "attachment" | token                                           ; case-insensitive
        disposition-parm    = filename-parm | token [ "*" ] "=" ( token | quoted-string | ext-value)    ; ext-value defined in [RFC5987], Section 3.2
    
        Content-Disposition header field values with multiple instances of the same parameter name are invalid.
    
        Note that due to the rules for implied linear whitespace (Section 2.1 of [RFC2616]), OPTIONAL whitespace
        can appear between words (token or quoted-string) and separator characters.
    
        Furthermore, note that the format used for ext-value allows specifying a natural language (e.g., "en"); this is of limited use
        for filenames and is likely to be ignored by recipients.
    */
    
    
    internals.contentDispositionRegex = /^\s*form-data\s*(?:;\s*(.+))?$/i;
    
    //                                        1: name   2: *            3: ext-value                  4: quoted  5: token
    internals.contentDispositionParamRegex = /([^\=\*]+)(\*)?\s*\=\s*(?:([^;']+\'[\w-]*\'[^;\s]+)|(?:\"([^"]*)\")|([^;\s]*))(?:(?:\s*;\s*)|(?:\s*$))/g;
    
    exports.disposition = function (header) {
    
        if (!header) {
            return Boom.badRequest('Missing content-disposition header');
        }
    
        var match = header.match(internals.contentDispositionRegex);
        if (!match) {
            return Boom.badRequest('Invalid content-disposition header format');
        }
    
        var parameters = match[1];
        if (!parameters) {
            return Boom.badRequest('Invalid content-disposition header missing parameters');
        }
    
        var result = {};
        var leftovers = parameters.replace(internals.contentDispositionParamRegex, function ($0, $1, $2, $3, $4, $5) {
    
            if ($2) {
                if (!$3) {
                    return 'error';         // Generate leftovers
                }
    
                try {
                    result[$1] = decodeURIComponent($3.split('\'')[2]);
                }
                catch (err) {
                    return 'error';          // Generate leftover
                }
            }
            else {
                result[$1] = $4 || $5 || '';
            }
    
            return '';
        });
    
        if (leftovers) {
            return Boom.badRequest('Invalid content-disposition header format includes invalid parameters');
        }
    
        if (!result.name) {
            return Boom.badRequest('Invalid content-disposition header missing name parameter');
        }
    
        return result;
    };
    
  provide("content", module.exports);
}(global));

// pakmanager:nigel/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Events = require('events');
    var Stream = require('stream');
    var Hoek = require('hoek');
    var Vise = require('vise');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.compile = function (needle) {
    
        Hoek.assert(needle && needle.length, 'Missing needle');
        Hoek.assert(Buffer.isBuffer(needle), 'Needle must be a buffer');
    
        var profile = {
            value: needle,
            lastPos: needle.length - 1,
            last: needle[needle.length - 1],
            length: needle.length,
            badCharShift: new Buffer(256)                  // Lookup table of how many characters can be skipped for each match
        };
    
        for (var i = 0; i < 256; ++i) {
            profile.badCharShift[i] = profile.length;       // Defaults to the full length of the needle
        }
    
        var last = profile.length - 1;
        for (i = 0; i < last; ++i) {                        // For each character in the needle (skip last since its position is already the default)
            profile.badCharShift[profile.value[i]] = last - i;
        }
    
        return profile;
    };
    
    
    exports.horspool = function (haystack, needle, start) {
    
        Hoek.assert(haystack, 'Missing haystack');
    
        needle = (needle.badCharShift ? needle : exports.compile(needle));
        start = start || 0;
    
        for (var i = start, il = haystack.length - needle.length; i <= il;) {       // Has enough room to fit the entire needle
            var lastChar = haystack.readUInt8(i + needle.lastPos, true);
            if (lastChar === needle.last &&
                internals.startsWith(haystack, needle, i)) {
    
                return i;
            }
    
            i += needle.badCharShift[lastChar];           // Jump to the next possible position based on last character location in needle
        }
    
        return -1;
    };
    
    
    internals.startsWith = function (haystack, needle, pos) {
    
        if (haystack.startsWith) {
            return haystack.startsWith(needle.value, pos, needle.lastPos);
        }
    
        for (var i = 0, il = needle.lastPos; i < il; ++i) {
            if (needle.value[i] !== haystack.readUInt8(pos + i, true)) {
                return false;
            }
        }
    
        return true;
    };
    
    
    exports.all = function (haystack, needle, start) {
    
        needle = exports.compile(needle);
        start = start || 0;
    
        var matches = [];
        for (var last = start, hlen = haystack.length; last !== -1 && last < hlen;) {
    
            last = exports.horspool(haystack, needle, last)
            if (last !== -1) {
                matches.push(last);
                last += needle.length;
            }
        }
    
        return matches;
    };
    
    
    internals._indexOf = function (haystack, needle) {
    
        Hoek.assert(haystack, 'Missing haystack');
    
        for (var i = 0, il = haystack.length - needle.length; i <= il; ++i) {       // Has enough room to fit the entire needle
            if (haystack.startsWith(needle.value, i)) {
                return i;
            }
        }
    
        return -1;
    };
    
    
    exports.Stream = internals.Stream = function (needle) {
    
        var self = this;
    
        Stream.Writable.call(this);
    
        this.needle(needle);
        this._haystack = new Vise();
        this._indexOf = this._needle.length > 2 ? exports.horspool : internals._indexOf;
    
        this.on('finish', function () {
    
            // Flush out the remainder
    
            var chunks = self._haystack.chunks();
            for (var i = 0, il = chunks.length; i < il; ++i) {
                self.emit('haystack', chunks[i]);
            }
    
            setImmediate(function () {                  // Give pending events a chance to fire
    
                self.emit('close');
            });
        });
    };
    
    Hoek.inherits(internals.Stream, Stream.Writable);
    
    
    internals.Stream.prototype.needle = function (needle) {
    
        this._needle = exports.compile(needle);
    };
    
    
    internals.Stream.prototype._write = function (chunk, encoding, next) {
    
        this._haystack.push(chunk);
    
        var match = this._indexOf(this._haystack, this._needle);
        if (match === -1 &&
            chunk.length >= this._needle.length) {
    
            this._flush(this._haystack.length - chunk.length);
        }
    
        while (match !== -1) {
            this._flush(match);
            this._haystack.shift(this._needle.length);
            this.emit('needle');
    
            match = this._indexOf(this._haystack, this._needle);
        }
    
        if (this._haystack.length) {
            var notChecked = this._haystack.length - this._needle.length + 1;       // Not enough space for Horspool
            for (var i = notChecked; i < this._haystack.length; ++i) {
                if (this._haystack.startsWith(this._needle.value, i, this._haystack.length - i)) {
                    break;
                }
            }
    
            this._flush(i);
        }
    
        return next();
    };
    
    
    internals.Stream.prototype._flush = function (pos) {
    
        var chunks = this._haystack.shift(pos);
        for (var i = 0, il = chunks.length; i < il; ++i) {
            this.emit('haystack', chunks[i]);
        }
    };
    
    
    internals.Stream.prototype.flush = function () {
    
        var chunks = this._haystack.shift(this._haystack.length);
        for (var i = 0, il = chunks.length; i < il; ++i) {
            this.emit('haystack', chunks[i]);
        }
    };
    
  provide("nigel/lib", module.exports);
}(global));

// pakmanager:nigel
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('nigel/lib');
  provide("nigel", module.exports);
}(global));

// pakmanager:minimist
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function (args, opts) {
        if (!opts) opts = {};
        
        var flags = { bools : {}, strings : {}, unknownFn: null };
    
        if (typeof opts['unknown'] === 'function') {
            flags.unknownFn = opts['unknown'];
        }
    
        if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
          flags.allBools = true;
        } else {
          [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
              flags.bools[key] = true;
          });
        }
        
        var aliases = {};
        Object.keys(opts.alias || {}).forEach(function (key) {
            aliases[key] = [].concat(opts.alias[key]);
            aliases[key].forEach(function (x) {
                aliases[x] = [key].concat(aliases[key].filter(function (y) {
                    return x !== y;
                }));
            });
        });
    
        [].concat(opts.string).filter(Boolean).forEach(function (key) {
            flags.strings[key] = true;
            if (aliases[key]) {
                flags.strings[aliases[key]] = true;
            }
         });
    
        var defaults = opts['default'] || {};
        
        var argv = { _ : [] };
        Object.keys(flags.bools).forEach(function (key) {
            setArg(key, defaults[key] === undefined ? false : defaults[key]);
        });
        
        var notFlags = [];
    
        if (args.indexOf('--') !== -1) {
            notFlags = args.slice(args.indexOf('--')+1);
            args = args.slice(0, args.indexOf('--'));
        }
    
        function argDefined(key, arg) {
            return (flags.allBools && /^--[^=]+$/.test(arg)) ||
                flags.strings[key] || flags.bools[key] || aliases[key];
        }
    
        function setArg (key, val, arg) {
            if (arg && flags.unknownFn && !argDefined(key, arg)) {
                if (flags.unknownFn(arg) === false) return;
            }
    
            var value = !flags.strings[key] && isNumber(val)
                ? Number(val) : val
            ;
            setKey(argv, key.split('.'), value);
            
            (aliases[key] || []).forEach(function (x) {
                setKey(argv, x.split('.'), value);
            });
        }
    
        function setKey (obj, keys, value) {
            var o = obj;
            keys.slice(0,-1).forEach(function (key) {
                if (o[key] === undefined) o[key] = {};
                o = o[key];
            });
    
            var key = keys[keys.length - 1];
            if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
                o[key] = value;
            }
            else if (Array.isArray(o[key])) {
                o[key].push(value);
            }
            else {
                o[key] = [ o[key], value ];
            }
        }
        
        for (var i = 0; i < args.length; i++) {
            var arg = args[i];
            
            if (/^--.+=/.test(arg)) {
                // Using [\s\S] instead of . because js doesn't support the
                // 'dotall' regex modifier. See:
                // http://stackoverflow.com/a/1068308/13216
                var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
                setArg(m[1], m[2], arg);
            }
            else if (/^--no-.+/.test(arg)) {
                var key = arg.match(/^--no-(.+)/)[1];
                setArg(key, false, arg);
            }
            else if (/^--.+/.test(arg)) {
                var key = arg.match(/^--(.+)/)[1];
                var next = args[i + 1];
                if (next !== undefined && !/^-/.test(next)
                && !flags.bools[key]
                && !flags.allBools
                && (aliases[key] ? !flags.bools[aliases[key]] : true)) {
                    setArg(key, next, arg);
                    i++;
                }
                else if (/^(true|false)$/.test(next)) {
                    setArg(key, next === 'true', arg);
                    i++;
                }
                else {
                    setArg(key, flags.strings[key] ? '' : true, arg);
                }
            }
            else if (/^-[^-]+/.test(arg)) {
                var letters = arg.slice(1,-1).split('');
                
                var broken = false;
                for (var j = 0; j < letters.length; j++) {
                    var next = arg.slice(j+2);
                    
                    if (next === '-') {
                        setArg(letters[j], next, arg)
                        continue;
                    }
                    
                    if (/[A-Za-z]/.test(letters[j])
                    && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                        setArg(letters[j], next, arg);
                        broken = true;
                        break;
                    }
                    
                    if (letters[j+1] && letters[j+1].match(/\W/)) {
                        setArg(letters[j], arg.slice(j+2), arg);
                        broken = true;
                        break;
                    }
                    else {
                        setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
                    }
                }
                
                var key = arg.slice(-1)[0];
                if (!broken && key !== '-') {
                    if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])
                    && !flags.bools[key]
                    && (aliases[key] ? !flags.bools[aliases[key]] : true)) {
                        setArg(key, args[i+1], arg);
                        i++;
                    }
                    else if (args[i+1] && /true|false/.test(args[i+1])) {
                        setArg(key, args[i+1] === 'true', arg);
                        i++;
                    }
                    else {
                        setArg(key, flags.strings[key] ? '' : true, arg);
                    }
                }
            }
            else {
                if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                    argv._.push(
                        flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
                    );
                }
                if (opts.stopEarly) {
                    argv._.push.apply(argv._, args.slice(i + 1));
                    break;
                }
            }
        }
        
        Object.keys(defaults).forEach(function (key) {
            if (!hasKey(argv, key.split('.'))) {
                setKey(argv, key.split('.'), defaults[key]);
                
                (aliases[key] || []).forEach(function (x) {
                    setKey(argv, x.split('.'), defaults[key]);
                });
            }
        });
        
        if (opts['--']) {
            argv['--'] = new Array();
            notFlags.forEach(function(key) {
                argv['--'].push(key);
            });
        }
        else {
            notFlags.forEach(function(key) {
                argv._.push(key);
            });
        }
    
        return argv;
    };
    
    function hasKey (obj, keys) {
        var o = obj;
        keys.slice(0,-1).forEach(function (key) {
            o = (o[key] || {});
        });
    
        var key = keys[keys.length - 1];
        return key in o;
    }
    
    function isNumber (x) {
        if (typeof x === 'number') return true;
        if (/^0x[0-9a-f]+$/i.test(x)) return true;
        return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    
    
  provide("minimist", module.exports);
}(global));

// pakmanager:async
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * async
     * https://github.com/caolan/async
     *
     * Copyright 2010-2014 Caolan McMahon
     * Released under the MIT license
     */
    (function () {
    
        var async = {};
        function noop() {}
    
        // global on the server, window in the browser
        var previous_async;
    
        // Establish the root object, `window` (`self`) in the browser, `global`
        // on the server, or `this` in some virtual machines. We use `self`
        // instead of `window` for `WebWorker` support.
        var root = typeof self === 'object' && self.self === self && self ||
                typeof global === 'object' && global.global === global && global ||
                this;
    
        if (root != null) {
            previous_async = root.async;
        }
    
        async.noConflict = function () {
            root.async = previous_async;
            return async;
        };
    
        function only_once(fn) {
            var called = false;
            return function() {
                if (called) throw new Error("Callback was already called.");
                called = true;
                fn.apply(this, arguments);
            };
        }
    
        function _once(fn) {
            var called = false;
            return function() {
                if (called) return;
                called = true;
                fn.apply(this, arguments);
            };
        }
    
        //// cross-browser compatiblity functions ////
    
        var _toString = Object.prototype.toString;
    
        var _isArray = Array.isArray || function (obj) {
            return _toString.call(obj) === '[object Array]';
        };
    
        function _isArrayLike(arr) {
            return _isArray(arr) || (
                // has a positive integer length property
                typeof arr.length === "number" &&
                arr.length >= 0 &&
                arr.length % 1 === 0
            );
        }
    
        function _each(coll, iterator) {
            return _isArrayLike(coll) ?
                _arrayEach(coll, iterator) :
                _forEachOf(coll, iterator);
        }
    
        function _arrayEach(arr, iterator) {
            var index = -1,
                length = arr.length;
    
            while (++index < length) {
                iterator(arr[index], index, arr);
            }
        }
    
        function _map(arr, iterator) {
            var index = -1,
                length = arr.length,
                result = Array(length);
    
            while (++index < length) {
                result[index] = iterator(arr[index], index, arr);
            }
            return result;
        }
    
        function _range(count) {
            return _map(Array(count), function (v, i) { return i; });
        }
    
        function _reduce(arr, iterator, memo) {
            _arrayEach(arr, function (x, i, a) {
                memo = iterator(memo, x, i, a);
            });
            return memo;
        }
    
        function _forEachOf(object, iterator) {
            _arrayEach(_keys(object), function (key) {
                iterator(object[key], key);
            });
        }
    
        var _keys = Object.keys || function (obj) {
            var keys = [];
            for (var k in obj) {
                if (obj.hasOwnProperty(k)) {
                    keys.push(k);
                }
            }
            return keys;
        };
    
        function _keyIterator(coll) {
            var i = -1;
            var len;
            var keys;
            if (_isArrayLike(coll)) {
                len = coll.length;
                return function next() {
                    i++;
                    return i < len ? i : null;
                };
            } else {
                keys = _keys(coll);
                len = keys.length;
                return function next() {
                    i++;
                    return i < len ? keys[i] : null;
                };
            }
        }
    
        function _baseSlice(arr, start) {
            start = start || 0;
            var index = -1;
            var length = arr.length;
    
            if (start) {
                length -= start;
                length = length < 0 ? 0 : length;
            }
            var result = Array(length);
    
            while (++index < length) {
                result[index] = arr[index + start];
            }
            return result;
        }
    
        function _withoutIndex(iterator) {
            return function (value, index, callback) {
                return iterator(value, callback);
            };
        }
    
        //// exported async module functions ////
    
        //// nextTick implementation with browser-compatible fallback ////
    
        // capture the global reference to guard against fakeTimer mocks
        var _setImmediate;
        if (typeof setImmediate === 'function') {
            _setImmediate = setImmediate;
        }
    
        if (typeof process === 'undefined' || !(process.nextTick)) {
            if (_setImmediate) {
                async.nextTick = function (fn) {
                    // not a direct alias for IE10 compatibility
                    _setImmediate(fn);
                };
                async.setImmediate = async.nextTick;
            }
            else {
                async.nextTick = function (fn) {
                    setTimeout(fn, 0);
                };
                async.setImmediate = async.nextTick;
            }
        }
        else {
            async.nextTick = process.nextTick;
            if (_setImmediate) {
                async.setImmediate = function (fn) {
                  // not a direct alias for IE10 compatibility
                    _setImmediate(fn);
                };
            }
            else {
                async.setImmediate = async.nextTick;
            }
        }
    
        async.forEach =
        async.each = function (arr, iterator, callback) {
            return async.eachOf(arr, _withoutIndex(iterator), callback);
        };
    
        async.forEachSeries =
        async.eachSeries = function (arr, iterator, callback) {
            return async.eachOfSeries(arr, _withoutIndex(iterator), callback);
        };
    
    
        async.forEachLimit =
        async.eachLimit = function (arr, limit, iterator, callback) {
            return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);
        };
    
        async.forEachOf =
        async.eachOf = function (object, iterator, callback) {
            callback = _once(callback || noop);
            object = object || [];
            var size = _isArrayLike(object) ? object.length : _keys(object).length;
            var completed = 0;
            if (!size) {
                return callback(null);
            }
            _each(object, function (value, key) {
                iterator(object[key], key, only_once(done));
            });
            function done(err) {
                if (err) {
                    callback(err);
                }
                else {
                    completed += 1;
                    if (completed >= size) {
                        callback(null);
                    }
                }
            }
        };
    
        async.forEachOfSeries =
        async.eachOfSeries = function (obj, iterator, callback) {
            callback = _once(callback || noop);
            obj = obj || [];
            var nextKey = _keyIterator(obj);
            var key = nextKey();
            function iterate() {
                var sync = true;
                if (key === null) {
                    return callback(null);
                }
                iterator(obj[key], key, only_once(function (err) {
                    if (err) {
                        callback(err);
                    }
                    else {
                        key = nextKey();
                        if (key === null) {
                            return callback(null);
                        } else {
                            if (sync) {
                                async.nextTick(iterate);
                            } else {
                                iterate();
                            }
                        }
                    }
                }));
                sync = false;
            }
            iterate();
        };
    
    
    
        async.forEachOfLimit =
        async.eachOfLimit = function (obj, limit, iterator, callback) {
            _eachOfLimit(limit)(obj, iterator, callback);
        };
    
        function _eachOfLimit(limit) {
    
            return function (obj, iterator, callback) {
                callback = _once(callback || noop);
                obj = obj || [];
                var nextKey = _keyIterator(obj);
                if (limit <= 0) {
                    return callback(null);
                }
                var done = false;
                var running = 0;
                var errored = false;
    
                (function replenish () {
                    if (done && running <= 0) {
                        return callback(null);
                    }
    
                    while (running < limit && !errored) {
                        var key = nextKey();
                        if (key === null) {
                            done = true;
                            if (running <= 0) {
                                callback(null);
                            }
                            return;
                        }
                        running += 1;
                        iterator(obj[key], key, only_once(function (err) {
                            running -= 1;
                            if (err) {
                                callback(err);
                                errored = true;
                            }
                            else {
                                replenish();
                            }
                        }));
                    }
                })();
            };
        }
    
    
        function doParallel(fn) {
            return function (obj, iterator, callback) {
                return fn(async.eachOf, obj, iterator, callback);
            };
        }
        function doParallelLimit(limit, fn) {
            return function (obj, iterator, callback) {
                return fn(_eachOfLimit(limit), obj, iterator, callback);
            };
        }
        function doSeries(fn) {
            return function (obj, iterator, callback) {
                return fn(async.eachOfSeries, obj, iterator, callback);
            };
        }
    
        function _asyncMap(eachfn, arr, iterator, callback) {
            callback = _once(callback || noop);
            var results = [];
            eachfn(arr, function (value, index, callback) {
                iterator(value, function (err, v) {
                    results[index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    
        async.map = doParallel(_asyncMap);
        async.mapSeries = doSeries(_asyncMap);
        async.mapLimit = function (arr, limit, iterator, callback) {
            return _mapLimit(limit)(arr, iterator, callback);
        };
    
        function _mapLimit(limit) {
            return doParallelLimit(limit, _asyncMap);
        }
    
        // reduce only has a series version, as doing reduce in parallel won't
        // work in many situations.
        async.inject =
        async.foldl =
        async.reduce = function (arr, memo, iterator, callback) {
            async.eachOfSeries(arr, function (x, i, callback) {
                iterator(memo, x, function (err, v) {
                    memo = v;
                    callback(err);
                });
            }, function (err) {
                callback(err || null, memo);
            });
        };
    
        async.foldr =
        async.reduceRight = function (arr, memo, iterator, callback) {
            var reversed = _map(arr, function (x) {
                return x;
            }).reverse();
            async.reduce(reversed, memo, iterator, callback);
        };
    
        function _filter(eachfn, arr, iterator, callback) {
            var results = [];
            arr = _map(arr, function (x, i) {
                return {index: i, value: x};
            });
            eachfn(arr, function (x, index, callback) {
                iterator(x.value, function (v) {
                    if (v) {
                        results.push(x);
                    }
                    callback();
                });
            }, function () {
                callback(_map(results.sort(function (a, b) {
                    return a.index - b.index;
                }), function (x) {
                    return x.value;
                }));
            });
        }
    
        async.select =
        async.filter = doParallel(_filter);
    
        async.selectSeries =
        async.filterSeries = doSeries(_filter);
    
        function _reject(eachfn, arr, iterator, callback) {
            _filter(eachfn, arr, function(value, cb) {
                iterator(value, function(v) {
                    cb(!v);
                });
            }, callback);
        }
        async.reject = doParallel(_reject);
        async.rejectSeries = doSeries(_reject);
    
        function _detect(eachfn, arr, iterator, main_callback) {
            eachfn(arr, function (x, index, callback) {
                iterator(x, function (result) {
                    if (result) {
                        main_callback(x);
                        main_callback = noop;
                    }
                    else {
                        callback();
                    }
                });
            }, function () {
                main_callback();
            });
        }
        async.detect = doParallel(_detect);
        async.detectSeries = doSeries(_detect);
    
        async.any =
        async.some = function (arr, iterator, main_callback) {
            async.eachOf(arr, function (x, _, callback) {
                iterator(x, function (v) {
                    if (v) {
                        main_callback(true);
                        main_callback = noop;
                    }
                    callback();
                });
            }, function () {
                main_callback(false);
            });
        };
    
        async.all =
        async.every = function (arr, iterator, main_callback) {
            async.eachOf(arr, function (x, _, callback) {
                iterator(x, function (v) {
                    if (!v) {
                        main_callback(false);
                        main_callback = noop;
                    }
                    callback();
                });
            }, function () {
                main_callback(true);
            });
        };
    
        async.sortBy = function (arr, iterator, callback) {
            async.map(arr, function (x, callback) {
                iterator(x, function (err, criteria) {
                    if (err) {
                        callback(err);
                    }
                    else {
                        callback(null, {value: x, criteria: criteria});
                    }
                });
            }, function (err, results) {
                if (err) {
                    return callback(err);
                }
                else {
                    callback(null, _map(results.sort(comparator), function (x) {
                        return x.value;
                    }));
                }
    
            });
    
            function comparator(left, right) {
                var a = left.criteria, b = right.criteria;
                return a < b ? -1 : a > b ? 1 : 0;
            }
        };
    
        async.auto = function (tasks, callback) {
            callback = _once(callback || noop);
            var keys = _keys(tasks);
            var remainingTasks = keys.length;
            if (!remainingTasks) {
                return callback(null);
            }
    
            var results = {};
    
            var listeners = [];
            function addListener(fn) {
                listeners.unshift(fn);
            }
            function removeListener(fn) {
                for (var i = 0; i < listeners.length; i += 1) {
                    if (listeners[i] === fn) {
                        listeners.splice(i, 1);
                        return;
                    }
                }
            }
            function taskComplete() {
                remainingTasks--;
                _arrayEach(listeners.slice(0), function (fn) {
                    fn();
                });
            }
    
            addListener(function () {
                if (!remainingTasks) {
                    callback(null, results);
                }
            });
    
            _arrayEach(keys, function (k) {
                var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
                function taskCallback(err) {
                    var args = _baseSlice(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    if (err) {
                        var safeResults = {};
                        _arrayEach(_keys(results), function(rkey) {
                            safeResults[rkey] = results[rkey];
                        });
                        safeResults[k] = args;
                        callback(err, safeResults);
                    }
                    else {
                        results[k] = args;
                        async.setImmediate(taskComplete);
                    }
                }
                var requires = task.slice(0, Math.abs(task.length - 1)) || [];
                // prevent dead-locks
                var len = requires.length;
                var dep;
                while (len--) {
                    if (!(dep = tasks[requires[len]])) {
                        throw new Error('Has inexistant dependency');
                    }
                    if (_isArray(dep) && !!~dep.indexOf(k)) {
                        throw new Error('Has cyclic dependencies');
                    }
                }
                function ready() {
                    return _reduce(requires, function (a, x) {
                        return (a && results.hasOwnProperty(x));
                    }, true) && !results.hasOwnProperty(k);
                }
                if (ready()) {
                    task[task.length - 1](taskCallback, results);
                }
                else {
                    addListener(listener);
                }
                function listener() {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                }
            });
        };
    
    
    
        async.retry = function(/*[times,] task [, callback]*/) {
            var DEFAULT_TIMES = 5;
            var DEFAULT_INTERVAL = 0;
    
            var attempts = [];
    
            var opts = {
              times: DEFAULT_TIMES,
              interval: DEFAULT_INTERVAL
            };
    
            function parseTimes(acc, t){
              if(typeof t === 'number'){
                acc.times = parseInt(t, 10) || DEFAULT_TIMES;
              } else if(typeof t === 'object'){
                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;
                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;
              } else {
                throw new Error('Unsupported argument type for \'times\': ' + typeof(t));
              }
            }
    
            switch(arguments.length){
                case 1: {
                  opts.task = arguments[0];
                  break;
                }
                case 2 : {
                  if(typeof arguments[0] === 'number' || typeof arguments[0] === 'object'){
                    parseTimes(opts, arguments[0]);
                    opts.task = arguments[1];
                  } else {
                    opts.task = arguments[0];
                    opts.callback = arguments[1];
                  }
                  break;
                }
                case 3: {
                  parseTimes(opts, arguments[0]);
                  opts.task = arguments[1];
                  opts.callback = arguments[2];
                  break;
                }
                default: {
                  throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');
                }
              }
    
            function wrappedTask(wrappedCallback, wrappedResults) {
                function retryAttempt(task, finalAttempt) {
                    return function(seriesCallback) {
                        task(function(err, result){
                            seriesCallback(!err || finalAttempt, {err: err, result: result});
                        }, wrappedResults);
                    };
                }
    
                function retryInterval(interval){
                  return function(seriesCallback){
                    setTimeout(function(){
                      seriesCallback(null);
                    }, interval);
                  };
                }
    
                while (opts.times) {
    
                    var finalAttempt = !(opts.times-=1);
                    attempts.push(retryAttempt(opts.task, finalAttempt));
                    if(!finalAttempt && opts.interval > 0){
                      attempts.push(retryInterval(opts.interval));
                    }
                }
    
                async.series(attempts, function(done, data){
                    data = data[data.length - 1];
                    (wrappedCallback || opts.callback)(data.err, data.result);
                });
            }
    
            // If a callback is passed, run this as a controll flow
            return opts.callback ? wrappedTask() : wrappedTask;
        };
    
        async.waterfall = function (tasks, callback) {
            callback = _once(callback || noop);
            if (!_isArray(tasks)) {
                var err = new Error('First argument to waterfall must be an array of functions');
                return callback(err);
            }
            if (!tasks.length) {
                return callback();
            }
            function wrapIterator(iterator) {
                return function (err) {
                    if (err) {
                        callback.apply(null, arguments);
                    }
                    else {
                        var args = _baseSlice(arguments, 1);
                        var next = iterator.next();
                        if (next) {
                            args.push(wrapIterator(next));
                        }
                        else {
                            args.push(callback);
                        }
                        ensureAsync(iterator).apply(null, args);
                    }
                };
            }
            wrapIterator(async.iterator(tasks))();
        };
    
        function _parallel(eachfn, tasks, callback) {
            callback = callback || noop;
            var results = _isArrayLike(tasks) ? [] : {};
    
            eachfn(tasks, function (task, key, callback) {
                task(function (err) {
                    var args = _baseSlice(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[key] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    
        async.parallel = function (tasks, callback) {
            _parallel(async.eachOf, tasks, callback);
        };
    
        async.parallelLimit = function(tasks, limit, callback) {
            _parallel(_eachOfLimit(limit), tasks, callback);
        };
    
        async.series = function (tasks, callback) {
            callback = callback || noop;
            var results = _isArrayLike(tasks) ? [] : {};
    
            async.eachOfSeries(tasks, function (task, key, callback) {
                task(function (err) {
                    var args = _baseSlice(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[key] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        };
    
        async.iterator = function (tasks) {
            function makeCallback(index) {
                function fn() {
                    if (tasks.length) {
                        tasks[index].apply(null, arguments);
                    }
                    return fn.next();
                }
                fn.next = function () {
                    return (index < tasks.length - 1) ? makeCallback(index + 1): null;
                };
                return fn;
            }
            return makeCallback(0);
        };
    
        async.apply = function (fn) {
            var args = _baseSlice(arguments, 1);
            return function () {
                return fn.apply(
                    null, args.concat(_baseSlice(arguments))
                );
            };
        };
    
        function _concat(eachfn, arr, fn, callback) {
            var result = [];
            eachfn(arr, function (x, index, cb) {
                fn(x, function (err, y) {
                    result = result.concat(y || []);
                    cb(err);
                });
            }, function (err) {
                callback(err, result);
            });
        }
        async.concat = doParallel(_concat);
        async.concatSeries = doSeries(_concat);
    
        async.whilst = function (test, iterator, callback) {
            callback = callback || noop;
            if (test()) {
                iterator(function (err) {
                    if (err) {
                        return callback(err);
                    }
                    async.whilst(test, iterator, callback);
                });
            }
            else {
                callback(null);
            }
        };
    
        async.doWhilst = function (iterator, test, callback) {
            callback = callback || noop;
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                var args = _baseSlice(arguments, 1);
                if (test.apply(null, args)) {
                    async.doWhilst(iterator, test, callback);
                }
                else {
                    callback(null);
                }
            });
        };
    
        async.until = function (test, iterator, callback) {
            callback = callback || noop;
            if (!test()) {
                iterator(function (err) {
                    if (err) {
                        return callback(err);
                    }
                    async.until(test, iterator, callback);
                });
            }
            else {
                callback(null);
            }
        };
    
        async.doUntil = function (iterator, test, callback) {
            callback = callback || noop;
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                var args = _baseSlice(arguments, 1);
                if (!test.apply(null, args)) {
                    async.doUntil(iterator, test, callback);
                }
                else {
                    callback(null);
                }
            });
        };
    
        async.during = function (test, iterator, callback) {
            callback = callback || noop;
            test(function(err, truth) {
                if (err) {
                    return callback(err);
                }
                if (truth) {
                    iterator(function (err) {
                        if (err) {
                            return callback(err);
                        }
                        async.during(test, iterator, callback);
                    });
                }
                else {
                    callback(null);
                }
            });
        };
    
        async.doDuring = function (iterator, test, callback) {
            callback = callback || noop;
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                var args = _baseSlice(arguments, 1);
                args.push(function (err, truth) {
                    if (err) {
                       return callback(err);
                    }
                    if (truth) {
                        async.doDuring(iterator, test, callback);
                    }
                    else {
                        callback(null);
                    }
                });
                test.apply(null, args);
            });
        };
    
        function _queue(worker, concurrency, payload) {
            if (concurrency == null) {
                concurrency = 1;
            }
            else if(concurrency === 0) {
                throw new Error('Concurrency must not be zero');
            }
            function _insert(q, data, pos, callback) {
                if (callback != null && typeof callback !== "function") {
                    throw new Error("task callback must be a function");
                }
                q.started = true;
                if (!_isArray(data)) {
                    data = [data];
                }
                if(data.length === 0 && q.idle()) {
                    // call drain immediately if there are no tasks
                    return async.setImmediate(function() {
                       q.drain();
                    });
                }
                _arrayEach(data, function(task) {
                    var item = {
                        data: task,
                        callback: callback || noop
                    };
    
                    if (pos) {
                        q.tasks.unshift(item);
                    } else {
                        q.tasks.push(item);
                    }
    
                    if (q.tasks.length === q.concurrency) {
                        q.saturated();
                    }
                });
                async.setImmediate(q.process);
            }
            function _next(q, tasks) {
                return function(){
                    workers -= 1;
                    var args = arguments;
                    _arrayEach(tasks, function (task) {
                        task.callback.apply(task, args);
                    });
                    if (q.tasks.length + workers === 0) {
                        q.drain();
                    }
                    q.process();
                };
            }
    
            var workers = 0;
            var q = {
                tasks: [],
                concurrency: concurrency,
                payload: payload,
                saturated: noop,
                empty: noop,
                drain: noop,
                started: false,
                paused: false,
                push: function (data, callback) {
                    _insert(q, data, false, callback);
                },
                kill: function () {
                    q.drain = noop;
                    q.tasks = [];
                },
                unshift: function (data, callback) {
                    _insert(q, data, true, callback);
                },
                process: function () {
                    if (!q.paused && workers < q.concurrency && q.tasks.length) {
                        while(workers < q.concurrency && q.tasks.length){
                            var tasks = q.payload ?
                                q.tasks.splice(0, q.payload) :
                                q.tasks.splice(0, q.tasks.length);
    
                            var data = _map(tasks, function (task) {
                                return task.data;
                            });
    
                            if (q.tasks.length === 0) {
                                q.empty();
                            }
                            workers += 1;
                            var cb = only_once(_next(q, tasks));
                            worker(data, cb);
                        }
                    }
                },
                length: function () {
                    return q.tasks.length;
                },
                running: function () {
                    return workers;
                },
                idle: function() {
                    return q.tasks.length + workers === 0;
                },
                pause: function () {
                    q.paused = true;
                },
                resume: function () {
                    if (q.paused === false) { return; }
                    q.paused = false;
                    var resumeCount = Math.min(q.concurrency, q.tasks.length);
                    // Need to call q.process once per concurrent
                    // worker to preserve full concurrency after pause
                    for (var w = 1; w <= resumeCount; w++) {
                        async.setImmediate(q.process);
                    }
                }
            };
            return q;
        }
    
        async.queue = function (worker, concurrency) {
            var q = _queue(function (items, cb) {
                worker(items[0], cb);
            }, concurrency, 1);
    
            return q;
        };
    
        async.priorityQueue = function (worker, concurrency) {
    
            function _compareTasks(a, b){
                return a.priority - b.priority;
            }
    
            function _binarySearch(sequence, item, compare) {
              var beg = -1,
                  end = sequence.length - 1;
              while (beg < end) {
                  var mid = beg + ((end - beg + 1) >>> 1);
                  if (compare(item, sequence[mid]) >= 0) {
                      beg = mid;
                  } else {
                      end = mid - 1;
                  }
              }
              return beg;
            }
    
            function _insert(q, data, priority, callback) {
                if (callback != null && typeof callback !== "function") {
                    throw new Error("task callback must be a function");
                }
                q.started = true;
                if (!_isArray(data)) {
                    data = [data];
                }
                if(data.length === 0) {
                    // call drain immediately if there are no tasks
                    return async.setImmediate(function() {
                        q.drain();
                    });
                }
                _arrayEach(data, function(task) {
                    var item = {
                        data: task,
                        priority: priority,
                        callback: typeof callback === 'function' ? callback : noop
                    };
    
                    q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);
    
                    if (q.tasks.length === q.concurrency) {
                        q.saturated();
                    }
                    async.setImmediate(q.process);
                });
            }
    
            // Start with a normal queue
            var q = async.queue(worker, concurrency);
    
            // Override push to accept second parameter representing priority
            q.push = function (data, priority, callback) {
                _insert(q, data, priority, callback);
            };
    
            // Remove unshift function
            delete q.unshift;
    
            return q;
        };
    
        async.cargo = function (worker, payload) {
            return _queue(worker, 1, payload);
        };
    
        function _console_fn(name) {
            return function (fn) {
                var args = _baseSlice(arguments, 1);
                fn.apply(null, args.concat([function (err) {
                    var args = _baseSlice(arguments, 1);
                    if (typeof console !== 'undefined') {
                        if (err) {
                            if (console.error) {
                                console.error(err);
                            }
                        }
                        else if (console[name]) {
                            _arrayEach(args, function (x) {
                                console[name](x);
                            });
                        }
                    }
                }]));
            };
        }
        async.log = _console_fn('log');
        async.dir = _console_fn('dir');
        /*async.info = _console_fn('info');
        async.warn = _console_fn('warn');
        async.error = _console_fn('error');*/
    
        async.memoize = function (fn, hasher) {
            var memo = {};
            var queues = {};
            hasher = hasher || function (x) {
                return x;
            };
            function memoized() {
                var args = _baseSlice(arguments);
                var callback = args.pop();
                var key = hasher.apply(null, args);
                if (key in memo) {
                    async.nextTick(function () {
                        callback.apply(null, memo[key]);
                    });
                }
                else if (key in queues) {
                    queues[key].push(callback);
                }
                else {
                    queues[key] = [callback];
                    fn.apply(null, args.concat([function () {
                        memo[key] = _baseSlice(arguments);
                        var q = queues[key];
                        delete queues[key];
                        for (var i = 0, l = q.length; i < l; i++) {
                          q[i].apply(null, arguments);
                        }
                    }]));
                }
            }
            memoized.memo = memo;
            memoized.unmemoized = fn;
            return memoized;
        };
    
        async.unmemoize = function (fn) {
            return function () {
                return (fn.unmemoized || fn).apply(null, arguments);
            };
        };
    
        function _times(mapper) {
            return function (count, iterator, callback) {
                mapper(_range(count), iterator, callback);
            };
        }
    
        async.times = _times(async.map);
        async.timesSeries = _times(async.mapSeries);
        async.timesLimit = function (count, limit, iterator, callback) {
            return async.mapLimit(_range(count), limit, iterator, callback);
        };
    
        async.seq = function (/* functions... */) {
            var fns = arguments;
            return function () {
                var that = this;
                var args = _baseSlice(arguments);
    
                var callback = args.slice(-1)[0];
                if (typeof callback == 'function') {
                    args.pop();
                } else {
                    callback = noop;
                }
    
                async.reduce(fns, args, function (newargs, fn, cb) {
                    fn.apply(that, newargs.concat([function () {
                        var err = arguments[0];
                        var nextargs = _baseSlice(arguments, 1);
                        cb(err, nextargs);
                    }]));
                },
                function (err, results) {
                    callback.apply(that, [err].concat(results));
                });
            };
        };
    
        async.compose = function (/* functions... */) {
            return async.seq.apply(null, Array.prototype.reverse.call(arguments));
        };
    
    
        function _applyEach(eachfn, fns /*args...*/) {
            function go() {
                var that = this;
                var args = _baseSlice(arguments);
                var callback = args.pop();
                return eachfn(fns, function (fn, _, cb) {
                    fn.apply(that, args.concat([cb]));
                },
                callback);
            }
            if (arguments.length > 2) {
                var args = _baseSlice(arguments, 2);
                return go.apply(this, args);
            }
            else {
                return go;
            }
        }
    
        async.applyEach = function (/*fns, args...*/) {
            var args = _baseSlice(arguments);
            return _applyEach.apply(null, [async.eachOf].concat(args));
        };
        async.applyEachSeries = function (/*fns, args...*/) {
            var args = _baseSlice(arguments);
            return _applyEach.apply(null, [async.eachOfSeries].concat(args));
        };
    
    
        async.forever = function (fn, callback) {
            var done = only_once(callback || noop);
            var task = ensureAsync(fn);
            function next(err) {
                if (err) {
                    return done(err);
                }
                task(next);
            }
            next();
        };
    
        function ensureAsync(fn) {
            return function (/*...args, callback*/) {
                var args = _baseSlice(arguments);
                var callback = args.pop();
                args.push(function () {
                    var innerArgs = arguments;
                    if (sync) {
                        async.setImmediate(function () {
                            callback.apply(null, innerArgs);
                        });
                    } else {
                        callback.apply(null, innerArgs);
                    }
                });
                var sync = true;
                fn.apply(this, args);
                sync = false;
            };
        }
    
        async.ensureAsync = ensureAsync;
    
        async.constant = function constant(/*values...*/) {
            var args = [null].concat(_baseSlice(arguments));
            return function (callback) {
                return callback.apply(this, args);
            };
        };
    
        async.wrapSync =
        async.asyncify = function asyncify(func) {
            return function (/*args..., callback*/) {
                var args = _baseSlice(arguments);
                var callback = args.pop();
                var result;
                try {
                    result = func.apply(this, args);
                } catch (e) {
                    return callback(e);
                }
                callback(null, result);
            };
        };
    
        // Node.js
        if (typeof module !== 'undefined' && module.exports) {
            module.exports = async;
        }
        // AMD / RequireJS
        else if (typeof define !== 'undefined' && define.amd) {
            define([], function () {
                return async;
            });
        }
        // included directly via <script> tag
        else {
            root.async = async;
        }
    
    }());
    
  provide("async", module.exports);
}(global));

// pakmanager:source-map/source-map/base64
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
    
      /**
       * Encode an integer in the range of 0 to 63 to a single base 64 digit.
       */
      exports.encode = function (number) {
        if (0 <= number && number < intToCharMap.length) {
          return intToCharMap[number];
        }
        throw new TypeError("Must be between 0 and 63: " + aNumber);
      };
    
      /**
       * Decode a single base 64 character code digit to an integer. Returns -1 on
       * failure.
       */
      exports.decode = function (charCode) {
        var bigA = 65;     // 'A'
        var bigZ = 90;     // 'Z'
    
        var littleA = 97;  // 'a'
        var littleZ = 122; // 'z'
    
        var zero = 48;     // '0'
        var nine = 57;     // '9'
    
        var plus = 43;     // '+'
        var slash = 47;    // '/'
    
        var littleOffset = 26;
        var numberOffset = 52;
    
        // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
        if (bigA <= charCode && charCode <= bigZ) {
          return (charCode - bigA);
        }
    
        // 26 - 51: abcdefghijklmnopqrstuvwxyz
        if (littleA <= charCode && charCode <= littleZ) {
          return (charCode - littleA + littleOffset);
        }
    
        // 52 - 61: 0123456789
        if (zero <= charCode && charCode <= nine) {
          return (charCode - zero + numberOffset);
        }
    
        // 62: +
        if (charCode == plus) {
          return 62;
        }
    
        // 63: /
        if (charCode == slash) {
          return 63;
        }
    
        // Invalid base64 digit.
        return -1;
      };
    
    });
    
  provide("source-map/source-map/base64", module.exports);
}(global));

// pakmanager:source-map/source-map/util
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      /**
       * This is a helper function for getting values from parameter/options
       * objects.
       *
       * @param args The object we are extracting values from
       * @param name The name of the property we are getting.
       * @param defaultValue An optional value to return if the property is missing
       * from the object. If this is not specified and the property is missing, an
       * error will be thrown.
       */
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;
    
      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
    
      function urlParse(aUrl) {
        var match = aUrl.match(urlRegexp);
        if (!match) {
          return null;
        }
        return {
          scheme: match[1],
          auth: match[2],
          host: match[3],
          port: match[4],
          path: match[5]
        };
      }
      exports.urlParse = urlParse;
    
      function urlGenerate(aParsedUrl) {
        var url = '';
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ':';
        }
        url += '//';
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + '@';
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ":" + aParsedUrl.port
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;
    
      /**
       * Normalizes a path, or the path portion of a URL:
       *
       * - Replaces consequtive slashes with one slash.
       * - Removes unnecessary '.' parts.
       * - Removes unnecessary '<dir>/..' parts.
       *
       * Based on code in the Node.js 'path' core module.
       *
       * @param aPath The path or url to normalize.
       */
      function normalize(aPath) {
        var path = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path = url.path;
        }
        var isAbsolute = (path.charAt(0) === '/');
    
        var parts = path.split(/\/+/);
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
          part = parts[i];
          if (part === '.') {
            parts.splice(i, 1);
          } else if (part === '..') {
            up++;
          } else if (up > 0) {
            if (part === '') {
              // The first part is blank if the path is absolute. Trying to go
              // above the root is a no-op. Therefore we can remove all '..' parts
              // directly after the root.
              parts.splice(i + 1, up);
              up = 0;
            } else {
              parts.splice(i, 2);
              up--;
            }
          }
        }
        path = parts.join('/');
    
        if (path === '') {
          path = isAbsolute ? '/' : '.';
        }
    
        if (url) {
          url.path = path;
          return urlGenerate(url);
        }
        return path;
      }
      exports.normalize = normalize;
    
      /**
       * Joins two paths/URLs.
       *
       * @param aRoot The root path or URL.
       * @param aPath The path or URL to be joined with the root.
       *
       * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
       *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
       *   first.
       * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
       *   is updated with the result and aRoot is returned. Otherwise the result
       *   is returned.
       *   - If aPath is absolute, the result is aPath.
       *   - Otherwise the two paths are joined with a slash.
       * - Joining for example 'http://' and 'www.example.com' is also supported.
       */
      function join(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        if (aPath === "") {
          aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || '/';
        }
    
        // `join(foo, '//www.example.org')`
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
    
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
    
        // `join('http://', 'www.example.com')`
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
    
        var joined = aPath.charAt(0) === '/'
          ? aPath
          : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
    
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports.join = join;
    
      /**
       * Make a path relative to a URL or another path.
       *
       * @param aRoot The root path or URL.
       * @param aPath The path or URL to be made relative to aRoot.
       */
      function relative(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
    
        aRoot = aRoot.replace(/\/$/, '');
    
        // It is possible for the path to be above the root. In this case, simply
        // checking whether the root is a prefix of the path won't work. Instead, we
        // need to remove components from the root one by one, until either we find
        // a prefix that fits, or we run out of components to remove.
        var level = 0;
        while (aPath.indexOf(aRoot + '/') !== 0) {
          var index = aRoot.lastIndexOf("/");
          if (index < 0) {
            return aPath;
          }
    
          // If the only part of the root that is left is the scheme (i.e. http://,
          // file:///, etc.), one or more slashes (/), or simply nothing at all, we
          // have exhausted all components, so the path is not relative to the root.
          aRoot = aRoot.slice(0, index);
          if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
          }
    
          ++level;
        }
    
        // Make sure we add a "../" for each component we removed from the root.
        return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
      }
      exports.relative = relative;
    
      /**
       * Because behavior goes wacky when you set `__proto__` on objects, we
       * have to prefix all the strings in our set with an arbitrary character.
       *
       * See https://github.com/mozilla/source-map/pull/31 and
       * https://github.com/mozilla/source-map/issues/30
       *
       * @param String aStr
       */
      function toSetString(aStr) {
        return '$' + aStr;
      }
      exports.toSetString = toSetString;
    
      function fromSetString(aStr) {
        return aStr.substr(1);
      }
      exports.fromSetString = fromSetString;
    
      /**
       * Comparator between two mappings where the original positions are compared.
       *
       * Optionally pass in `true` as `onlyCompareGenerated` to consider two
       * mappings with the same original source/line/column, but different generated
       * line and column the same. Useful when searching for a mapping with a
       * stubbed out mapping.
       */
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp = mappingA.source - mappingB.source;
        if (cmp !== 0) {
          return cmp;
        }
    
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
    
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
          return cmp;
        }
    
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
    
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
    
        return mappingA.name - mappingB.name;
      };
      exports.compareByOriginalPositions = compareByOriginalPositions;
    
      /**
       * Comparator between two mappings where the generated positions are
       * compared.
       *
       * Optionally pass in `true` as `onlyCompareGenerated` to consider two
       * mappings with the same generated line and column, but different
       * source/name/original line and column the same. Useful when searching for a
       * mapping with a stubbed out mapping.
       */
      function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
    
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
          return cmp;
        }
    
        cmp = mappingA.source - mappingB.source;
        if (cmp !== 0) {
          return cmp;
        }
    
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
    
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
    
        return mappingA.name - mappingB.name;
      };
      exports.compareByGeneratedPositions = compareByGeneratedPositions;
    
    });
    
  provide("source-map/source-map/util", module.exports);
}(global));

// pakmanager:source-map/source-map/base64-vlq
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     *
     * Based on the Base 64 VLQ implementation in Closure Compiler:
     * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
     *
     * Copyright 2011 The Closure Compiler Authors. All rights reserved.
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are
     * met:
     *
     *  * Redistributions of source code must retain the above copyright
     *    notice, this list of conditions and the following disclaimer.
     *  * Redistributions in binary form must reproduce the above
     *    copyright notice, this list of conditions and the following
     *    disclaimer in the documentation and/or other materials provided
     *    with the distribution.
     *  * Neither the name of Google Inc. nor the names of its
     *    contributors may be used to endorse or promote products derived
     *    from this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
     * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
     * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var base64 =  require('source-map/source-map/base64');
    
      // A single base 64 digit can contain 6 bits of data. For the base 64 variable
      // length quantities we use in the source map spec, the first bit is the sign,
      // the next four bits are the actual value, and the 6th bit is the
      // continuation bit. The continuation bit tells us whether there are more
      // digits in this value following this digit.
      //
      //   Continuation
      //   |    Sign
      //   |    |
      //   V    V
      //   101011
    
      var VLQ_BASE_SHIFT = 5;
    
      // binary: 100000
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    
      // binary: 011111
      var VLQ_BASE_MASK = VLQ_BASE - 1;
    
      // binary: 100000
      var VLQ_CONTINUATION_BIT = VLQ_BASE;
    
      /**
       * Converts from a two-complement value to a value where the sign bit is
       * placed in the least significant bit.  For example, as decimals:
       *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
       *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
       */
      function toVLQSigned(aValue) {
        return aValue < 0
          ? ((-aValue) << 1) + 1
          : (aValue << 1) + 0;
      }
    
      /**
       * Converts to a two-complement value from a value where the sign bit is
       * placed in the least significant bit.  For example, as decimals:
       *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
       *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
       */
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative
          ? -shifted
          : shifted;
      }
    
      /**
       * Returns the base 64 VLQ encoded value.
       */
      exports.encode = function base64VLQ_encode(aValue) {
        var encoded = "";
        var digit;
    
        var vlq = toVLQSigned(aValue);
    
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            // There are still more digits in this value, so we must make sure the
            // continuation bit is marked.
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
    
        return encoded;
      };
    
      /**
       * Decodes the next base 64 VLQ value from the given string and returns the
       * value and the rest of the string via the out parameter.
       */
      exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
        var strLen = aStr.length;
        var result = 0;
        var shift = 0;
        var continuation, digit;
    
        do {
          if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
          }
    
          digit = base64.decode(aStr.charCodeAt(aIndex++));
          if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
          }
    
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);
    
        aOutParam.value = fromVLQSigned(result);
        aOutParam.rest = aIndex;
      };
    
    });
    
  provide("source-map/source-map/base64-vlq", module.exports);
}(global));

// pakmanager:source-map/source-map/array-set
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var util =  require('source-map/source-map/util');
    
      /**
       * A data structure which is a combination of an array and a set. Adding a new
       * member is O(1), testing for membership is O(1), and finding the index of an
       * element is O(1). Removing elements from the set is not supported. Only
       * strings are supported for membership.
       */
      function ArraySet() {
        this._array = [];
        this._set = {};
      }
    
      /**
       * Static method for creating ArraySet instances from an existing array.
       */
      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
        var set = new ArraySet();
        for (var i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      };
    
      /**
       * Return how many unique items are in this ArraySet. If duplicates have been
       * added, than those do not count towards the size.
       *
       * @returns Number
       */
      ArraySet.prototype.size = function ArraySet_size() {
        return Object.getOwnPropertyNames(this._set).length;
      };
    
      /**
       * Add the given string to this set.
       *
       * @param String aStr
       */
      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var isDuplicate = this.has(aStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          this._set[util.toSetString(aStr)] = idx;
        }
      };
    
      /**
       * Is the given string a member of this set?
       *
       * @param String aStr
       */
      ArraySet.prototype.has = function ArraySet_has(aStr) {
        return Object.prototype.hasOwnProperty.call(this._set,
                                                    util.toSetString(aStr));
      };
    
      /**
       * What is the index of the given string in the array?
       *
       * @param String aStr
       */
      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (this.has(aStr)) {
          return this._set[util.toSetString(aStr)];
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };
    
      /**
       * What is the element at the given index?
       *
       * @param Number aIdx
       */
      ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error('No element indexed by ' + aIdx);
      };
    
      /**
       * Returns the array representation of this set (which has the proper indices
       * indicated by indexOf). Note that this is a copy of the internal array used
       * for storing the members so that no one can mess with internal state.
       */
      ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
    
      exports.ArraySet = ArraySet;
    
    });
    
  provide("source-map/source-map/array-set", module.exports);
}(global));

// pakmanager:source-map/source-map/mapping-list
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2014 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var util =  require('source-map/source-map/util');
    
      /**
       * Determine whether mappingB is after mappingA with respect to generated
       * position.
       */
      function generatedPositionAfter(mappingA, mappingB) {
        // Optimized for most common case
        var lineA = mappingA.generatedLine;
        var lineB = mappingB.generatedLine;
        var columnA = mappingA.generatedColumn;
        var columnB = mappingB.generatedColumn;
        return lineB > lineA || lineB == lineA && columnB >= columnA ||
               util.compareByGeneratedPositions(mappingA, mappingB) <= 0;
      }
    
      /**
       * A data structure to provide a sorted view of accumulated mappings in a
       * performance conscious manner. It trades a neglibable overhead in general
       * case for a large speedup in case of mappings being added in order.
       */
      function MappingList() {
        this._array = [];
        this._sorted = true;
        // Serves as infimum
        this._last = {generatedLine: -1, generatedColumn: 0};
      }
    
      /**
       * Iterate through internal items. This method takes the same arguments that
       * `Array.prototype.forEach` takes.
       *
       * NOTE: The order of the mappings is NOT guaranteed.
       */
      MappingList.prototype.unsortedForEach =
        function MappingList_forEach(aCallback, aThisArg) {
          this._array.forEach(aCallback, aThisArg);
        };
    
      /**
       * Add the given source mapping.
       *
       * @param Object aMapping
       */
      MappingList.prototype.add = function MappingList_add(aMapping) {
        var mapping;
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      };
    
      /**
       * Returns the flat, sorted array of mappings. The mappings are sorted by
       * generated position.
       *
       * WARNING: This method returns internal data without copying, for
       * performance. The return value must NOT be mutated, and should be treated as
       * an immutable borrow. If you want to take ownership, you must make your own
       * copy.
       */
      MappingList.prototype.toArray = function MappingList_toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositions);
          this._sorted = true;
        }
        return this._array;
      };
    
      exports.MappingList = MappingList;
    
    });
    
  provide("source-map/source-map/mapping-list", module.exports);
}(global));

// pakmanager:source-map/source-map/binary-search
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      exports.GREATEST_LOWER_BOUND = 1;
      exports.LEAST_UPPER_BOUND = 2;
    
      /**
       * Recursive implementation of binary search.
       *
       * @param aLow Indices here and lower do not contain the needle.
       * @param aHigh Indices here and higher do not contain the needle.
       * @param aNeedle The element being searched for.
       * @param aHaystack The non-empty array being searched.
       * @param aCompare Function which takes two elements and returns -1, 0, or 1.
       * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
       *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       */
      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
        // This function terminates when one of the following is true:
        //
        //   1. We find the exact element we are looking for.
        //
        //   2. We did not find the exact element, but we can return the index of
        //      the next-closest element.
        //
        //   3. We did not find the exact element, and there is no next-closest
        //      element than the one we are searching for, so we return -1.
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
          // Found the element we are looking for.
          return mid;
        }
        else if (cmp > 0) {
          // Our needle is greater than aHaystack[mid].
          if (aHigh - mid > 1) {
            // The element is in the upper half.
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
          }
    
          // The exact needle element was not found in this haystack. Determine if
          // we are in termination case (3) or (2) and return the appropriate thing.
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return aHigh < aHaystack.length ? aHigh : -1;
          } else {
            return mid;
          }
        }
        else {
          // Our needle is less than aHaystack[mid].
          if (mid - aLow > 1) {
            // The element is in the lower half.
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
          }
    
          // we are in termination case (3) or (2) and return the appropriate thing.
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return mid;
          } else {
            return aLow < 0 ? -1 : aLow;
          }
        }
      }
    
      /**
       * This is an implementation of binary search which will always try and return
       * the index of the closest element if there is no exact hit. This is because
       * mappings between original and generated line/col pairs are single points,
       * and there is an implicit region between each of them, so a miss just means
       * that you aren't on the very start of a region.
       *
       * @param aNeedle The element you are looking for.
       * @param aHaystack The array that is being searched.
       * @param aCompare A function which takes the needle and an element in the
       *     array and returns -1, 0, or 1 depending on whether the needle is less
       *     than, equal to, or greater than the element, respectively.
       * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
       *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
       */
      exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
        if (aHaystack.length === 0) {
          return -1;
        }
    
        var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                                    aCompare, aBias || exports.GREATEST_LOWER_BOUND);
        if (index < 0) {
          return -1;
        }
    
        // We have found either the exact element, or the next-closest element than
        // the one we are searching for. However, there may be more than one such
        // element. Make sure we always return the smallest of these.
        while (index - 1 >= 0) {
          if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
            break;
          }
          --index;
        }
    
        return index;
      };
    
    });
    
  provide("source-map/source-map/binary-search", module.exports);
}(global));

// pakmanager:source-map/source-map/quick-sort
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      // It turns out that some (most?) JavaScript engines don't self-host
      // `Array.prototype.sort`. This makes sense because C++ will likely remain
      // faster than JS when doing raw CPU-intensive sorting. However, when using a
      // custom comparator function, calling back and forth between the VM's C++ and
      // JIT'd JS is rather slow *and* loses JIT type information, resulting in
      // worse generated code for the comparator function than would be optimal. In
      // fact, when sorting with a comparator, these costs outweigh the benefits of
      // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
      // a ~3500ms mean speed-up in `bench/bench.html`.
    
      /**
       * Swap the elements indexed by `x` and `y` in the array `ary`.
       *
       * @param {Array} ary
       *        The array.
       * @param {Number} x
       *        The index of the first item.
       * @param {Number} y
       *        The index of the second item.
       */
      function swap(ary, x, y) {
        var temp = ary[x];
        ary[x] = ary[y];
        ary[y] = temp;
      }
    
      /**
       * Returns a random integer within the range `low .. high` inclusive.
       *
       * @param {Number} low
       *        The lower bound on the range.
       * @param {Number} high
       *        The upper bound on the range.
       */
      function randomIntInRange(low, high) {
        return Math.round(low + (Math.random() * (high - low)));
      }
    
      /**
       * The Quick Sort algorithm.
       *
       * @param {Array} ary
       *        An array to sort.
       * @param {function} comparator
       *        Function to use to compare two items.
       * @param {Number} p
       *        Start index of the array
       * @param {Number} r
       *        End index of the array
       */
      function doQuickSort(ary, comparator, p, r) {
        // If our lower bound is less than our upper bound, we (1) partition the
        // array into two pieces and (2) recurse on each half. If it is not, this is
        // the empty array and our base case.
    
        if (p < r) {
          // (1) Partitioning.
          //
          // The partitioning chooses a pivot between `p` and `r` and moves all
          // elements that are less than or equal to the pivot to the before it, and
          // all the elements that are greater than it after it. The effect is that
          // once partition is done, the pivot is in the exact place it will be when
          // the array is put in sorted order, and it will not need to be moved
          // again. This runs in O(n) time.
    
          // Always choose a random pivot so that an input array which is reverse
          // sorted does not cause O(n^2) running time.
          var pivotIndex = randomIntInRange(p, r);
          var i = p - 1;
    
          swap(ary, pivotIndex, r);
          var pivot = ary[r];
    
          // Immediately after `j` is incremented in this loop, the following hold
          // true:
          //
          //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
          //
          //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
          for (var j = p; j < r; j++) {
            if (comparator(ary[j], pivot) <= 0) {
              i += 1;
              swap(ary, i, j);
            }
          }
    
          swap(ary, i + 1, j);
          var q = i + 1;
    
          // (2) Recurse on each half.
    
          doQuickSort(ary, comparator, p, q - 1);
          doQuickSort(ary, comparator, q + 1, r);
        }
      }
    
      /**
       * Sort the given array in-place with the given comparator function.
       *
       * @param {Array} ary
       *        An array to sort.
       * @param {function} comparator
       *        Function to use to compare two items.
       */
      exports.quickSort = function (ary, comparator) {
        doQuickSort(ary, comparator, 0, ary.length - 1);
      };
    
    });
    
  provide("source-map/source-map/quick-sort", module.exports);
}(global));

// pakmanager:source-map/source-map/source-map-generator
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var base64VLQ =  require('source-map/source-map/base64-vlq');
      var util =  require('source-map/source-map/util');
      var ArraySet =  require('source-map/source-map/array-set').ArraySet;
      var MappingList =  require('source-map/source-map/mapping-list').MappingList;
    
      /**
       * An instance of the SourceMapGenerator represents a source map which is
       * being built incrementally. You may pass an object with the following
       * properties:
       *
       *   - file: The filename of the generated source.
       *   - sourceRoot: A root for all relative URLs in this source map.
       */
      function SourceMapGenerator(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, 'file', null);
        this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
        this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
    
      SourceMapGenerator.prototype._version = 3;
    
      /**
       * Creates a new SourceMapGenerator based on a SourceMapConsumer
       *
       * @param aSourceMapConsumer The SourceMap.
       */
      SourceMapGenerator.fromSourceMap =
        function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
          var sourceRoot = aSourceMapConsumer.sourceRoot;
          var generator = new SourceMapGenerator({
            file: aSourceMapConsumer.file,
            sourceRoot: sourceRoot
          });
          aSourceMapConsumer.eachMapping(function (mapping) {
            var newMapping = {
              generated: {
                line: mapping.generatedLine,
                column: mapping.generatedColumn
              }
            };
    
            if (mapping.source != null) {
              newMapping.source = mapping.source;
              if (sourceRoot != null) {
                newMapping.source = util.relative(sourceRoot, newMapping.source);
              }
    
              newMapping.original = {
                line: mapping.originalLine,
                column: mapping.originalColumn
              };
    
              if (mapping.name != null) {
                newMapping.name = mapping.name;
              }
            }
    
            generator.addMapping(newMapping);
          });
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              generator.setSourceContent(sourceFile, content);
            }
          });
          return generator;
        };
    
      /**
       * Add a single mapping from original source line and column to the generated
       * source's line and column for this source map being created. The mapping
       * object should have the following properties:
       *
       *   - generated: An object with the generated line and column positions.
       *   - original: An object with the original line and column positions.
       *   - source: The original source file (relative to the sourceRoot).
       *   - name: An optional original token name for this mapping.
       */
      SourceMapGenerator.prototype.addMapping =
        function SourceMapGenerator_addMapping(aArgs) {
          var generated = util.getArg(aArgs, 'generated');
          var original = util.getArg(aArgs, 'original', null);
          var source = util.getArg(aArgs, 'source', null);
          var name = util.getArg(aArgs, 'name', null);
    
          if (!this._skipValidation) {
            this._validateMapping(generated, original, source, name);
          }
    
          if (source != null && !this._sources.has(source)) {
            this._sources.add(source);
          }
    
          if (name != null && !this._names.has(name)) {
            this._names.add(name);
          }
    
          this._mappings.add({
            generatedLine: generated.line,
            generatedColumn: generated.column,
            originalLine: original != null && original.line,
            originalColumn: original != null && original.column,
            source: source,
            name: name
          });
        };
    
      /**
       * Set the source content for a source file.
       */
      SourceMapGenerator.prototype.setSourceContent =
        function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
          var source = aSourceFile;
          if (this._sourceRoot != null) {
            source = util.relative(this._sourceRoot, source);
          }
    
          if (aSourceContent != null) {
            // Add the source content to the _sourcesContents map.
            // Create a new _sourcesContents map if the property is null.
            if (!this._sourcesContents) {
              this._sourcesContents = {};
            }
            this._sourcesContents[util.toSetString(source)] = aSourceContent;
          } else if (this._sourcesContents) {
            // Remove the source file from the _sourcesContents map.
            // If the _sourcesContents map is empty, set the property to null.
            delete this._sourcesContents[util.toSetString(source)];
            if (Object.keys(this._sourcesContents).length === 0) {
              this._sourcesContents = null;
            }
          }
        };
    
      /**
       * Applies the mappings of a sub-source-map for a specific source file to the
       * source map being generated. Each mapping to the supplied source file is
       * rewritten using the supplied source map. Note: The resolution for the
       * resulting mappings is the minimium of this map and the supplied map.
       *
       * @param aSourceMapConsumer The source map to be applied.
       * @param aSourceFile Optional. The filename of the source file.
       *        If omitted, SourceMapConsumer's file property will be used.
       * @param aSourceMapPath Optional. The dirname of the path to the source map
       *        to be applied. If relative, it is relative to the SourceMapConsumer.
       *        This parameter is needed when the two source maps aren't in the same
       *        directory, and the source map to be applied contains relative source
       *        paths. If so, those relative source paths need to be rewritten
       *        relative to the SourceMapGenerator.
       */
      SourceMapGenerator.prototype.applySourceMap =
        function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
          var sourceFile = aSourceFile;
          // If aSourceFile is omitted, we will use the file property of the SourceMap
          if (aSourceFile == null) {
            if (aSourceMapConsumer.file == null) {
              throw new Error(
                'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
                'or the source map\'s "file" property. Both were omitted.'
              );
            }
            sourceFile = aSourceMapConsumer.file;
          }
          var sourceRoot = this._sourceRoot;
          // Make "sourceFile" relative if an absolute Url is passed.
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          // Applying the SourceMap can add and remove items from the sources and
          // the names array.
          var newSources = new ArraySet();
          var newNames = new ArraySet();
    
          // Find mappings for the "sourceFile"
          this._mappings.unsortedForEach(function (mapping) {
            if (mapping.source === sourceFile && mapping.originalLine != null) {
              // Check if it can be mapped by the source map, then update the mapping.
              var original = aSourceMapConsumer.originalPositionFor({
                line: mapping.originalLine,
                column: mapping.originalColumn
              });
              if (original.source != null) {
                // Copy mapping
                mapping.source = original.source;
                if (aSourceMapPath != null) {
                  mapping.source = util.join(aSourceMapPath, mapping.source)
                }
                if (sourceRoot != null) {
                  mapping.source = util.relative(sourceRoot, mapping.source);
                }
                mapping.originalLine = original.line;
                mapping.originalColumn = original.column;
                if (original.name != null) {
                  mapping.name = original.name;
                }
              }
            }
    
            var source = mapping.source;
            if (source != null && !newSources.has(source)) {
              newSources.add(source);
            }
    
            var name = mapping.name;
            if (name != null && !newNames.has(name)) {
              newNames.add(name);
            }
    
          }, this);
          this._sources = newSources;
          this._names = newNames;
    
          // Copy sourcesContents of applied map.
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              if (aSourceMapPath != null) {
                sourceFile = util.join(aSourceMapPath, sourceFile);
              }
              if (sourceRoot != null) {
                sourceFile = util.relative(sourceRoot, sourceFile);
              }
              this.setSourceContent(sourceFile, content);
            }
          }, this);
        };
    
      /**
       * A mapping can have one of the three levels of data:
       *
       *   1. Just the generated position.
       *   2. The Generated position, original position, and original source.
       *   3. Generated and original position, original source, as well as a name
       *      token.
       *
       * To maintain consistency, we validate that any new mapping being added falls
       * in to one of these categories.
       */
      SourceMapGenerator.prototype._validateMapping =
        function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                    aName) {
          if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
              && aGenerated.line > 0 && aGenerated.column >= 0
              && !aOriginal && !aSource && !aName) {
            // Case 1.
            return;
          }
          else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
                   && aOriginal && 'line' in aOriginal && 'column' in aOriginal
                   && aGenerated.line > 0 && aGenerated.column >= 0
                   && aOriginal.line > 0 && aOriginal.column >= 0
                   && aSource) {
            // Cases 2 and 3.
            return;
          }
          else {
            throw new Error('Invalid mapping: ' + JSON.stringify({
              generated: aGenerated,
              source: aSource,
              original: aOriginal,
              name: aName
            }));
          }
        };
    
      /**
       * Serialize the accumulated mappings in to the stream of base 64 VLQs
       * specified by the source map format.
       */
      SourceMapGenerator.prototype._serializeMappings =
        function SourceMapGenerator_serializeMappings() {
          var previousGeneratedColumn = 0;
          var previousGeneratedLine = 1;
          var previousOriginalColumn = 0;
          var previousOriginalLine = 0;
          var previousName = 0;
          var previousSource = 0;
          var result = '';
          var mapping;
    
          var mappings = this._mappings.toArray();
    
          for (var i = 0, len = mappings.length; i < len; i++) {
            mapping = mappings[i];
    
            if (mapping.generatedLine !== previousGeneratedLine) {
              previousGeneratedColumn = 0;
              while (mapping.generatedLine !== previousGeneratedLine) {
                result += ';';
                previousGeneratedLine++;
              }
            }
            else {
              if (i > 0) {
                if (!util.compareByGeneratedPositions(mapping, mappings[i - 1])) {
                  continue;
                }
                result += ',';
              }
            }
    
            result += base64VLQ.encode(mapping.generatedColumn
                                       - previousGeneratedColumn);
            previousGeneratedColumn = mapping.generatedColumn;
    
            if (mapping.source != null) {
              result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                         - previousSource);
              previousSource = this._sources.indexOf(mapping.source);
    
              // lines are stored 0-based in SourceMap spec version 3
              result += base64VLQ.encode(mapping.originalLine - 1
                                         - previousOriginalLine);
              previousOriginalLine = mapping.originalLine - 1;
    
              result += base64VLQ.encode(mapping.originalColumn
                                         - previousOriginalColumn);
              previousOriginalColumn = mapping.originalColumn;
    
              if (mapping.name != null) {
                result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                           - previousName);
                previousName = this._names.indexOf(mapping.name);
              }
            }
          }
    
          return result;
        };
    
      SourceMapGenerator.prototype._generateSourcesContent =
        function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
          return aSources.map(function (source) {
            if (!this._sourcesContents) {
              return null;
            }
            if (aSourceRoot != null) {
              source = util.relative(aSourceRoot, source);
            }
            var key = util.toSetString(source);
            return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                        key)
              ? this._sourcesContents[key]
              : null;
          }, this);
        };
    
      /**
       * Externalize the source map.
       */
      SourceMapGenerator.prototype.toJSON =
        function SourceMapGenerator_toJSON() {
          var map = {
            version: this._version,
            sources: this._sources.toArray(),
            names: this._names.toArray(),
            mappings: this._serializeMappings()
          };
          if (this._file != null) {
            map.file = this._file;
          }
          if (this._sourceRoot != null) {
            map.sourceRoot = this._sourceRoot;
          }
          if (this._sourcesContents) {
            map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
          }
    
          return map;
        };
    
      /**
       * Render the source map being generated to a string.
       */
      SourceMapGenerator.prototype.toString =
        function SourceMapGenerator_toString() {
          return JSON.stringify(this.toJSON());
        };
    
      exports.SourceMapGenerator = SourceMapGenerator;
    
    });
    
  provide("source-map/source-map/source-map-generator", module.exports);
}(global));

// pakmanager:source-map/source-map/source-map-consumer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var util =  require('source-map/source-map/util');
      var binarySearch =  require('source-map/source-map/binary-search');
      var ArraySet =  require('source-map/source-map/array-set').ArraySet;
      var base64VLQ =  require('source-map/source-map/base64-vlq');
      var quickSort =  require('source-map/source-map/quick-sort').quickSort;
    
      function SourceMapConsumer(aSourceMap) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
        }
    
        return sourceMap.sections != null
          ? new IndexedSourceMapConsumer(sourceMap)
          : new BasicSourceMapConsumer(sourceMap);
      }
    
      SourceMapConsumer.fromSourceMap = function(aSourceMap) {
        return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
      }
    
      /**
       * The version of the source mapping spec that we are consuming.
       */
      SourceMapConsumer.prototype._version = 3;
    
      // `__generatedMappings` and `__originalMappings` are arrays that hold the
      // parsed mapping coordinates from the source map's "mappings" attribute. They
      // are lazily instantiated, accessed via the `_generatedMappings` and
      // `_originalMappings` getters respectively, and we only parse the mappings
      // and create these arrays once queried for a source location. We jump through
      // these hoops because there can be many thousands of mappings, and parsing
      // them is expensive, so we only want to do it if we must.
      //
      // Each object in the arrays is of the form:
      //
      //     {
      //       generatedLine: The line number in the generated code,
      //       generatedColumn: The column number in the generated code,
      //       source: The path to the original source file that generated this
      //               chunk of code,
      //       originalLine: The line number in the original source that
      //                     corresponds to this chunk of generated code,
      //       originalColumn: The column number in the original source that
      //                       corresponds to this chunk of generated code,
      //       name: The name of the original symbol which generated this chunk of
      //             code.
      //     }
      //
      // All properties except for `generatedLine` and `generatedColumn` can be
      // `null`.
      //
      // `_generatedMappings` is ordered by the generated positions.
      //
      // `_originalMappings` is ordered by the original positions.
    
      SourceMapConsumer.prototype.__generatedMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
        get: function () {
          if (!this.__generatedMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
    
          return this.__generatedMappings;
        }
      });
    
      SourceMapConsumer.prototype.__originalMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
        get: function () {
          if (!this.__originalMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
    
          return this.__originalMappings;
        }
      });
    
      SourceMapConsumer.prototype._charIsMappingSeparator =
        function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
          var c = aStr.charAt(index);
          return c === ";" || c === ",";
        };
    
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      SourceMapConsumer.prototype._parseMappings =
        function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          throw new Error("Subclasses must implement _parseMappings");
        };
    
      SourceMapConsumer.GENERATED_ORDER = 1;
      SourceMapConsumer.ORIGINAL_ORDER = 2;
    
      SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
      SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    
      /**
       * Iterate over each mapping between an original source/line/column and a
       * generated line/column in this source map.
       *
       * @param Function aCallback
       *        The function that is called with each mapping.
       * @param Object aContext
       *        Optional. If specified, this object will be the value of `this` every
       *        time that `aCallback` is called.
       * @param aOrder
       *        Either `SourceMapConsumer.GENERATED_ORDER` or
       *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
       *        iterate over the mappings sorted by the generated file's line/column
       *        order or the original's source/line/column order, respectively. Defaults to
       *        `SourceMapConsumer.GENERATED_ORDER`.
       */
      SourceMapConsumer.prototype.eachMapping =
        function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
          var context = aContext || null;
          var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    
          var mappings;
          switch (order) {
          case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
          case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");
          }
    
          var sourceRoot = this.sourceRoot;
          mappings.map(function (mapping) {
            var source = mapping.source === null ? null : this._sources.at(mapping.source);
            if (source != null && sourceRoot != null) {
              source = util.join(sourceRoot, source);
            }
            return {
              source: source,
              generatedLine: mapping.generatedLine,
              generatedColumn: mapping.generatedColumn,
              originalLine: mapping.originalLine,
              originalColumn: mapping.originalColumn,
              name: mapping.name === null ? null : this._names.at(mapping.name)
            };
          }, this).forEach(aCallback, context);
        };
    
      /**
       * Returns all generated line and column information for the original source,
       * line, and column provided. If no column is provided, returns all mappings
       * corresponding to a either the line we are searching for or the next
       * closest line that has any mappings. Otherwise, returns all mappings
       * corresponding to the given line and either the column we are searching for
       * or the next closest column that has any offsets.
       *
       * The only argument is an object with the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.
       *   - column: Optional. the column number in the original source.
       *
       * and an array of objects is returned, each with the following properties:
       *
       *   - line: The line number in the generated source, or null.
       *   - column: The column number in the generated source, or null.
       */
      SourceMapConsumer.prototype.allGeneratedPositionsFor =
        function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
          var line = util.getArg(aArgs, 'line');
    
          // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
          // returns the index of the closest mapping less than the needle. By
          // setting needle.originalColumn to 0, we thus find the last mapping for
          // the given line, provided such a mapping exists.
          var needle = {
            source: util.getArg(aArgs, 'source'),
            originalLine: line,
            originalColumn: util.getArg(aArgs, 'column', 0)
          };
    
          if (this.sourceRoot != null) {
            needle.source = util.relative(this.sourceRoot, needle.source);
          }
          if (!this._sources.has(needle.source)) {
            return [];
          }
          needle.source = this._sources.indexOf(needle.source);
    
          var mappings = [];
    
          var index = this._findMapping(needle,
                                        this._originalMappings,
                                        "originalLine",
                                        "originalColumn",
                                        util.compareByOriginalPositions,
                                        binarySearch.LEAST_UPPER_BOUND);
          if (index >= 0) {
            var mapping = this._originalMappings[index];
    
            if (aArgs.column === undefined) {
              var originalLine = mapping.originalLine;
    
              // Iterate until either we run out of mappings, or we run into
              // a mapping for a different line than the one we found. Since
              // mappings are sorted, this is guaranteed to find all mappings for
              // the line we found.
              while (mapping && mapping.originalLine === originalLine) {
                mappings.push({
                  line: util.getArg(mapping, 'generatedLine', null),
                  column: util.getArg(mapping, 'generatedColumn', null),
                  lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
                });
    
                mapping = this._originalMappings[++index];
              }
            } else {
              var originalColumn = mapping.originalColumn;
    
              // Iterate until either we run out of mappings, or we run into
              // a mapping for a different line than the one we were searching for.
              // Since mappings are sorted, this is guaranteed to find all mappings for
              // the line we are searching for.
              while (mapping &&
                     mapping.originalLine === line &&
                     mapping.originalColumn == originalColumn) {
                mappings.push({
                  line: util.getArg(mapping, 'generatedLine', null),
                  column: util.getArg(mapping, 'generatedColumn', null),
                  lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
                });
    
                mapping = this._originalMappings[++index];
              }
            }
          }
    
          return mappings;
        };
    
      exports.SourceMapConsumer = SourceMapConsumer;
    
      /**
       * A BasicSourceMapConsumer instance represents a parsed source map which we can
       * query for information about the original file positions by giving it a file
       * position in the generated source.
       *
       * The only parameter is the raw source map (either as a JSON string, or
       * already parsed to an object). According to the spec, source maps have the
       * following attributes:
       *
       *   - version: Which version of the source map spec this map is following.
       *   - sources: An array of URLs to the original source files.
       *   - names: An array of identifiers which can be referrenced by individual mappings.
       *   - sourceRoot: Optional. The URL root from which all sources are relative.
       *   - sourcesContent: Optional. An array of contents of the original source files.
       *   - mappings: A string of base64 VLQs which contain the actual mappings.
       *   - file: Optional. The generated file this source map is associated with.
       *
       * Here is an example source map, taken from the source map spec[0]:
       *
       *     {
       *       version : 3,
       *       file: "out.js",
       *       sourceRoot : "",
       *       sources: ["foo.js", "bar.js"],
       *       names: ["src", "maps", "are", "fun"],
       *       mappings: "AA,AB;;ABCDE;"
       *     }
       *
       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
       */
      function BasicSourceMapConsumer(aSourceMap) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
        }
    
        var version = util.getArg(sourceMap, 'version');
        var sources = util.getArg(sourceMap, 'sources');
        // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
        // requires the array) to play nice here.
        var names = util.getArg(sourceMap, 'names', []);
        var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
        var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
        var mappings = util.getArg(sourceMap, 'mappings');
        var file = util.getArg(sourceMap, 'file', null);
    
        // Once again, Sass deviates from the spec and supplies the version as a
        // string rather than a number, so we use loose equality checking here.
        if (version != this._version) {
          throw new Error('Unsupported version: ' + version);
        }
    
        // Some source maps produce relative source paths like "./foo.js" instead of
        // "foo.js".  Normalize these first so that future comparisons will succeed.
        // See bugzil.la/1090768.
        sources = sources.map(util.normalize);
    
        // Pass `true` below to allow duplicate names and sources. While source maps
        // are intended to be compressed and deduplicated, the TypeScript compiler
        // sometimes generates source maps with duplicates in them. See Github issue
        // #72 and bugzil.la/889492.
        this._names = ArraySet.fromArray(names, true);
        this._sources = ArraySet.fromArray(sources, true);
    
        this.sourceRoot = sourceRoot;
        this.sourcesContent = sourcesContent;
        this._mappings = mappings;
        this.file = file;
      }
    
      BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    
      /**
       * Create a BasicSourceMapConsumer from a SourceMapGenerator.
       *
       * @param SourceMapGenerator aSourceMap
       *        The source map that will be consumed.
       * @returns BasicSourceMapConsumer
       */
      BasicSourceMapConsumer.fromSourceMap =
        function SourceMapConsumer_fromSourceMap(aSourceMap) {
          var smc = Object.create(BasicSourceMapConsumer.prototype);
    
          smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
          smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
          smc.sourceRoot = aSourceMap._sourceRoot;
          smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                                  smc.sourceRoot);
          smc.file = aSourceMap._file;
    
          smc.__generatedMappings = aSourceMap._mappings.toArray().slice();
          smc.__originalMappings = aSourceMap._mappings.toArray().slice().sort();
    
          smc.__generatedMappings.forEach(function (m) {
            if (m.source !== null) {
              m.source = smc._sources.indexOf(m.source);
    
              if (m.name !== null) {
                m.name = smc._names.indexOf(m.name);
              }
            }
          });
          return smc;
        };
    
      /**
       * The version of the source mapping spec that we are consuming.
       */
      BasicSourceMapConsumer.prototype._version = 3;
    
      /**
       * The list of original sources.
       */
      Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
        get: function () {
          return this._sources.toArray().map(function (s) {
            return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
          }, this);
        }
      });
    
      /**
       * Provide the JIT with a nice shape / hidden class.
       */
      function Mapping() {
        this.generatedLine = 0;
        this.generatedColumn = 0;
        this.source = null;
        this.originalLine = null;
        this.originalColumn = null;
        this.name = null;
      }
    
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      BasicSourceMapConsumer.prototype._parseMappings =
        function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          var generatedLine = 1;
          var previousGeneratedColumn = 0;
          var previousOriginalLine = 0;
          var previousOriginalColumn = 0;
          var previousSource = 0;
          var previousName = 0;
          var length = aStr.length;
          var index = 0;
          var cachedSegments = {};
          var temp = {};
          var originalMappings = [];
          var generatedMappings = [];
          var mapping, str, segment, end, value;
    
          while (index < length) {
            if (aStr.charAt(index) === ';') {
              generatedLine++;
              index++;
              previousGeneratedColumn = 0;
            }
            else if (aStr.charAt(index) === ',') {
              index++;
            }
            else {
              mapping = new Mapping();
              mapping.generatedLine = generatedLine;
    
              // Because each offset is encoded relative to the previous one,
              // many segments often have the same encoding. We can exploit this
              // fact by caching the parsed variable length fields of each segment,
              // allowing us to avoid a second parse if we encounter the same
              // segment again.
              for (end = index; end < length; end++) {
                if (this._charIsMappingSeparator(aStr, end)) {
                  break;
                }
              }
              str = aStr.slice(index, end);
    
              segment = cachedSegments[str];
              if (segment) {
                index += str.length;
              } else {
                segment = [];
                while (index < end) {
                  base64VLQ.decode(aStr, index, temp);
                  value = temp.value;
                  index = temp.rest;
                  segment.push(value);
                }
    
                if (segment.length === 2) {
                  throw new Error('Found a source, but no line and column');
                }
    
                if (segment.length === 3) {
                  throw new Error('Found a source and line, but no column');
                }
    
                cachedSegments[str] = segment;
              }
    
              // Generated column.
              mapping.generatedColumn = previousGeneratedColumn + segment[0];
              previousGeneratedColumn = mapping.generatedColumn;
    
              if (segment.length > 1) {
                // Original source.
                mapping.source = previousSource + segment[1];
                previousSource += segment[1];
    
                // Original line.
                mapping.originalLine = previousOriginalLine + segment[2];
                previousOriginalLine = mapping.originalLine;
                // Lines are stored 0-based
                mapping.originalLine += 1;
    
                // Original column.
                mapping.originalColumn = previousOriginalColumn + segment[3];
                previousOriginalColumn = mapping.originalColumn;
    
                if (segment.length > 4) {
                  // Original name.
                  mapping.name = previousName + segment[4];
                  previousName += segment[4];
                }
              }
    
              generatedMappings.push(mapping);
              if (typeof mapping.originalLine === 'number') {
                originalMappings.push(mapping);
              }
            }
          }
    
          quickSort(generatedMappings, util.compareByGeneratedPositions);
          this.__generatedMappings = generatedMappings;
    
          quickSort(originalMappings, util.compareByOriginalPositions);
          this.__originalMappings = originalMappings;
        };
    
      /**
       * Find the mapping that best matches the hypothetical "needle" mapping that
       * we are searching for in the given "haystack" of mappings.
       */
      BasicSourceMapConsumer.prototype._findMapping =
        function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                               aColumnName, aComparator, aBias) {
          // To return the position we are searching for, we must first find the
          // mapping for the given position and then return the opposite position it
          // points to. Because the mappings are sorted, we can use binary search to
          // find the best mapping.
    
          if (aNeedle[aLineName] <= 0) {
            throw new TypeError('Line must be greater than or equal to 1, got '
                                + aNeedle[aLineName]);
          }
          if (aNeedle[aColumnName] < 0) {
            throw new TypeError('Column must be greater than or equal to 0, got '
                                + aNeedle[aColumnName]);
          }
    
          return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
        };
    
      /**
       * Compute the last column for each generated mapping. The last column is
       * inclusive.
       */
      BasicSourceMapConsumer.prototype.computeColumnSpans =
        function SourceMapConsumer_computeColumnSpans() {
          for (var index = 0; index < this._generatedMappings.length; ++index) {
            var mapping = this._generatedMappings[index];
    
            // Mappings do not contain a field for the last generated columnt. We
            // can come up with an optimistic estimate, however, by assuming that
            // mappings are contiguous (i.e. given two consecutive mappings, the
            // first mapping ends where the second one starts).
            if (index + 1 < this._generatedMappings.length) {
              var nextMapping = this._generatedMappings[index + 1];
    
              if (mapping.generatedLine === nextMapping.generatedLine) {
                mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                continue;
              }
            }
    
            // The last mapping for each line spans the entire line.
            mapping.lastGeneratedColumn = Infinity;
          }
        };
    
      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.
       *   - column: The column number in the generated source.
       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.
       *   - column: The column number in the original source, or null.
       *   - name: The original identifier, or null.
       */
      BasicSourceMapConsumer.prototype.originalPositionFor =
        function SourceMapConsumer_originalPositionFor(aArgs) {
          var needle = {
            generatedLine: util.getArg(aArgs, 'line'),
            generatedColumn: util.getArg(aArgs, 'column')
          };
    
          var index = this._findMapping(
            needle,
            this._generatedMappings,
            "generatedLine",
            "generatedColumn",
            util.compareByGeneratedPositions,
            util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
          );
    
          if (index >= 0) {
            var mapping = this._generatedMappings[index];
    
            if (mapping.generatedLine === needle.generatedLine) {
              var source = util.getArg(mapping, 'source', null);
              if (source !== null) {
                source = this._sources.at(source);
                if (this.sourceRoot != null) {
                  source = util.join(this.sourceRoot, source);
                }
              }
              var name = util.getArg(mapping, 'name', null);
              if (name !== null) {
                name = this._names.at(name);
              }
              return {
                source: source,
                line: util.getArg(mapping, 'originalLine', null),
                column: util.getArg(mapping, 'originalColumn', null),
                name: name
              };
            }
          }
    
          return {
            source: null,
            line: null,
            column: null,
            name: null
          };
        };
    
      /**
       * Return true if we have the source content for every source in the source
       * map, false otherwise.
       */
      BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
        function BasicSourceMapConsumer_hasContentsOfAllSources() {
          if (!this.sourcesContent) {
            return false;
          }
          return this.sourcesContent.length >= this._sources.size() &&
            !this.sourcesContent.some(function (sc) { return sc == null; });
        };
    
      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * availible.
       */
      BasicSourceMapConsumer.prototype.sourceContentFor =
        function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
          if (!this.sourcesContent) {
            return null;
          }
    
          if (this.sourceRoot != null) {
            aSource = util.relative(this.sourceRoot, aSource);
          }
    
          if (this._sources.has(aSource)) {
            return this.sourcesContent[this._sources.indexOf(aSource)];
          }
    
          var url;
          if (this.sourceRoot != null
              && (url = util.urlParse(this.sourceRoot))) {
            // XXX: file:// URIs and absolute paths lead to unexpected behavior for
            // many users. We can help them out when they expect file:// URIs to
            // behave like it would if they were running a local HTTP server. See
            // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
            var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
            if (url.scheme == "file"
                && this._sources.has(fileUriAbsPath)) {
              return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
            }
    
            if ((!url.path || url.path == "/")
                && this._sources.has("/" + aSource)) {
              return this.sourcesContent[this._sources.indexOf("/" + aSource)];
            }
          }
    
          // This function is used recursively from
          // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
          // don't want to throw if we can't find the source - we just want to
          // return null, so we provide a flag to exit gracefully.
          if (nullOnMissing) {
            return null;
          }
          else {
            throw new Error('"' + aSource + '" is not in the SourceMap.');
          }
        };
    
      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.
       *   - column: The column number in the original source.
       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.
       *   - column: The column number in the generated source, or null.
       */
      BasicSourceMapConsumer.prototype.generatedPositionFor =
        function SourceMapConsumer_generatedPositionFor(aArgs) {
          var source = util.getArg(aArgs, 'source');
          if (this.sourceRoot != null) {
            source = util.relative(this.sourceRoot, source);
          }
          if (!this._sources.has(source)) {
            return {
              line: null,
              column: null,
              lastColumn: null
            };
          }
          source = this._sources.indexOf(source);
    
          var needle = {
            source: source,
            originalLine: util.getArg(aArgs, 'line'),
            originalColumn: util.getArg(aArgs, 'column')
          };
    
          var index = this._findMapping(
            needle,
            this._originalMappings,
            "originalLine",
            "originalColumn",
            util.compareByOriginalPositions,
            util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
          );
    
          if (index >= 0) {
            var mapping = this._originalMappings[index];
    
            if (mapping.source === needle.source) {
              return {
                line: util.getArg(mapping, 'generatedLine', null),
                column: util.getArg(mapping, 'generatedColumn', null),
                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
              };
            }
          }
    
          return {
            line: null,
            column: null,
            lastColumn: null
          };
        };
    
      exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    
      /**
       * An IndexedSourceMapConsumer instance represents a parsed source map which
       * we can query for information. It differs from BasicSourceMapConsumer in
       * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
       * input.
       *
       * The only parameter is a raw source map (either as a JSON string, or already
       * parsed to an object). According to the spec for indexed source maps, they
       * have the following attributes:
       *
       *   - version: Which version of the source map spec this map is following.
       *   - file: Optional. The generated file this source map is associated with.
       *   - sections: A list of section definitions.
       *
       * Each value under the "sections" field has two fields:
       *   - offset: The offset into the original specified at which this section
       *       begins to apply, defined as an object with a "line" and "column"
       *       field.
       *   - map: A source map definition. This source map could also be indexed,
       *       but doesn't have to be.
       *
       * Instead of the "map" field, it's also possible to have a "url" field
       * specifying a URL to retrieve a source map from, but that's currently
       * unsupported.
       *
       * Here's an example source map, taken from the source map spec[0], but
       * modified to omit a section which uses the "url" field.
       *
       *  {
       *    version : 3,
       *    file: "app.js",
       *    sections: [{
       *      offset: {line:100, column:10},
       *      map: {
       *        version : 3,
       *        file: "section.js",
       *        sources: ["foo.js", "bar.js"],
       *        names: ["src", "maps", "are", "fun"],
       *        mappings: "AAAA,E;;ABCDE;"
       *      }
       *    }],
       *  }
       *
       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
       */
      function IndexedSourceMapConsumer(aSourceMap) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
        }
    
        var version = util.getArg(sourceMap, 'version');
        var sections = util.getArg(sourceMap, 'sections');
    
        if (version != this._version) {
          throw new Error('Unsupported version: ' + version);
        }
    
        this._sources = new ArraySet();
        this._names = new ArraySet();
    
        var lastOffset = {
          line: -1,
          column: 0
        };
        this._sections = sections.map(function (s) {
          if (s.url) {
            // The url field will require support for asynchronicity.
            // See https://github.com/mozilla/source-map/issues/16
            throw new Error('Support for url field in sections not implemented.');
          }
          var offset = util.getArg(s, 'offset');
          var offsetLine = util.getArg(offset, 'line');
          var offsetColumn = util.getArg(offset, 'column');
    
          if (offsetLine < lastOffset.line ||
              (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
            throw new Error('Section offsets must be ordered and non-overlapping.');
          }
          lastOffset = offset;
    
          return {
            generatedOffset: {
              // The offset fields are 0-based, but we use 1-based indices when
              // encoding/decoding from VLQ.
              generatedLine: offsetLine + 1,
              generatedColumn: offsetColumn + 1
            },
            consumer: new SourceMapConsumer(util.getArg(s, 'map'))
          }
        });
      }
    
      IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    
      /**
       * The version of the source mapping spec that we are consuming.
       */
      IndexedSourceMapConsumer.prototype._version = 3;
    
      /**
       * The list of original sources.
       */
      Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
        get: function () {
          var sources = [];
          for (var i = 0; i < this._sections.length; i++) {
            for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
              sources.push(this._sections[i].consumer.sources[j]);
            }
          };
          return sources;
        }
      });
    
      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.
       *   - column: The column number in the generated source.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.
       *   - column: The column number in the original source, or null.
       *   - name: The original identifier, or null.
       */
      IndexedSourceMapConsumer.prototype.originalPositionFor =
        function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
          var needle = {
            generatedLine: util.getArg(aArgs, 'line'),
            generatedColumn: util.getArg(aArgs, 'column')
          };
    
          // Find the section containing the generated position we're trying to map
          // to an original position.
          var sectionIndex = binarySearch.search(needle, this._sections,
            function(needle, section) {
              var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
              if (cmp) {
                return cmp;
              }
    
              return (needle.generatedColumn -
                      section.generatedOffset.generatedColumn);
            });
          var section = this._sections[sectionIndex];
    
          if (!section) {
            return {
              source: null,
              line: null,
              column: null,
              name: null
            };
          }
    
          return section.consumer.originalPositionFor({
            line: needle.generatedLine -
              (section.generatedOffset.generatedLine - 1),
            column: needle.generatedColumn -
              (section.generatedOffset.generatedLine === needle.generatedLine
               ? section.generatedOffset.generatedColumn - 1
               : 0),
            bias: aArgs.bias
          });
        };
    
      /**
       * Return true if we have the source content for every source in the source
       * map, false otherwise.
       */
      IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
        function IndexedSourceMapConsumer_hasContentsOfAllSources() {
          return this._sections.every(function (s) {
            return s.consumer.hasContentsOfAllSources();
          });
        };
    
      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * available.
       */
      IndexedSourceMapConsumer.prototype.sourceContentFor =
        function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
    
            var content = section.consumer.sourceContentFor(aSource, true);
            if (content) {
              return content;
            }
          }
          if (nullOnMissing) {
            return null;
          }
          else {
            throw new Error('"' + aSource + '" is not in the SourceMap.');
          }
        };
    
      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.
       *   - column: The column number in the original source.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.
       *   - column: The column number in the generated source, or null.
       */
      IndexedSourceMapConsumer.prototype.generatedPositionFor =
        function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
    
            // Only consider this section if the requested source is in the list of
            // sources of the consumer.
            if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
              continue;
            }
            var generatedPosition = section.consumer.generatedPositionFor(aArgs);
            if (generatedPosition) {
              var ret = {
                line: generatedPosition.line +
                  (section.generatedOffset.generatedLine - 1),
                column: generatedPosition.column +
                  (section.generatedOffset.generatedLine === generatedPosition.line
                   ? section.generatedOffset.generatedColumn - 1
                   : 0)
              };
              return ret;
            }
          }
    
          return {
            line: null,
            column: null
          };
        };
    
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      IndexedSourceMapConsumer.prototype._parseMappings =
        function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          this.__generatedMappings = [];
          this.__originalMappings = [];
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
            var sectionMappings = section.consumer._generatedMappings;
            for (var j = 0; j < sectionMappings.length; j++) {
              var mapping = sectionMappings[i];
    
              var source = section.consumer._sources.at(mapping.source);
              if (section.consumer.sourceRoot !== null) {
                source = util.join(section.consumer.sourceRoot, source);
              }
              this._sources.add(source);
              source = this._sources.indexOf(source);
    
              var name = section.consumer._names.at(mapping.name);
              this._names.add(name);
              name = this._names.indexOf(name);
    
              // The mappings coming from the consumer for the section have
              // generated positions relative to the start of the section, so we
              // need to offset them to be relative to the start of the concatenated
              // generated file.
              var adjustedMapping = {
                source: source,
                generatedLine: mapping.generatedLine +
                  (section.generatedOffset.generatedLine - 1),
                generatedColumn: mapping.column +
                  (section.generatedOffset.generatedLine === mapping.generatedLine)
                  ? section.generatedOffset.generatedColumn - 1
                  : 0,
                originalLine: mapping.originalLine,
                originalColumn: mapping.originalColumn,
                name: name
              };
    
              this.__generatedMappings.push(adjustedMapping);
              if (typeof adjustedMapping.originalLine === 'number') {
                this.__originalMappings.push(adjustedMapping);
              }
            };
          };
    
          quickSort(this.__generatedMappings, util.compareByGeneratedPositions);
          quickSort(this.__originalMappings, util.compareByOriginalPositions);
        };
    
      exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
    
    });
    
  provide("source-map/source-map/source-map-consumer", module.exports);
}(global));

// pakmanager:source-map/source-map/source-node
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var SourceMapGenerator =  require('source-map/source-map/source-map-generator').SourceMapGenerator;
      var util =  require('source-map/source-map/util');
    
      // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
      // operating systems these days (capturing the result).
      var REGEX_NEWLINE = /(\r?\n)/;
    
      // Newline character code for charCodeAt() comparisons
      var NEWLINE_CODE = 10;
    
      // Private symbol for identifying `SourceNode`s when multiple versions of
      // the source-map library are loaded. This MUST NOT CHANGE across
      // versions!
      var isSourceNode = "$$$isSourceNode$$$";
    
      /**
       * SourceNodes provide a way to abstract over interpolating/concatenating
       * snippets of generated JavaScript source code while maintaining the line and
       * column information associated with the original source code.
       *
       * @param aLine The original line number.
       * @param aColumn The original column number.
       * @param aSource The original source's filename.
       * @param aChunks Optional. An array of strings which are snippets of
       *        generated JS, or other SourceNodes.
       * @param aName The original identifier.
       */
      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine == null ? null : aLine;
        this.column = aColumn == null ? null : aColumn;
        this.source = aSource == null ? null : aSource;
        this.name = aName == null ? null : aName;
        this[isSourceNode] = true;
        if (aChunks != null) this.add(aChunks);
      }
    
      /**
       * Creates a SourceNode from generated code and a SourceMapConsumer.
       *
       * @param aGeneratedCode The generated code
       * @param aSourceMapConsumer The SourceMap for the generated code
       * @param aRelativePath Optional. The path that relative sources in the
       *        SourceMapConsumer should be relative to.
       */
      SourceNode.fromStringWithSourceMap =
        function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
          // The SourceNode we want to fill with the generated code
          // and the SourceMap
          var node = new SourceNode();
    
          // All even indices of this array are one line of the generated code,
          // while all odd indices are the newlines between two adjacent lines
          // (since `REGEX_NEWLINE` captures its match).
          // Processed fragments are removed from this array, by calling `shiftNextLine`.
          var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
          var shiftNextLine = function() {
            var lineContents = remainingLines.shift();
            // The last line of a file might not have a newline.
            var newLine = remainingLines.shift() || "";
            return lineContents + newLine;
          };
    
          // We need to remember the position of "remainingLines"
          var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    
          // The generate SourceNodes we need a code range.
          // To extract it current and last mapping is used.
          // Here we store the last mapping.
          var lastMapping = null;
    
          aSourceMapConsumer.eachMapping(function (mapping) {
            if (lastMapping !== null) {
              // We add the code from "lastMapping" to "mapping":
              // First check if there is a new line in between.
              if (lastGeneratedLine < mapping.generatedLine) {
                var code = "";
                // Associate first line with "lastMapping"
                addMappingWithCode(lastMapping, shiftNextLine());
                lastGeneratedLine++;
                lastGeneratedColumn = 0;
                // The remaining code is added without mapping
              } else {
                // There is no new line in between.
                // Associate the code between "lastGeneratedColumn" and
                // "mapping.generatedColumn" with "lastMapping"
                var nextLine = remainingLines[0];
                var code = nextLine.substr(0, mapping.generatedColumn -
                                              lastGeneratedColumn);
                remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                    lastGeneratedColumn);
                lastGeneratedColumn = mapping.generatedColumn;
                addMappingWithCode(lastMapping, code);
                // No more remaining code, continue
                lastMapping = mapping;
                return;
              }
            }
            // We add the generated code until the first mapping
            // to the SourceNode without any mapping.
            // Each line is added as separate string.
            while (lastGeneratedLine < mapping.generatedLine) {
              node.add(shiftNextLine());
              lastGeneratedLine++;
            }
            if (lastGeneratedColumn < mapping.generatedColumn) {
              var nextLine = remainingLines[0];
              node.add(nextLine.substr(0, mapping.generatedColumn));
              remainingLines[0] = nextLine.substr(mapping.generatedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
            }
            lastMapping = mapping;
          }, this);
          // We have processed all mappings.
          if (remainingLines.length > 0) {
            if (lastMapping) {
              // Associate the remaining code in the current line with "lastMapping"
              addMappingWithCode(lastMapping, shiftNextLine());
            }
            // and add the remaining lines without any mapping
            node.add(remainingLines.join(""));
          }
    
          // Copy sourcesContent into SourceNode
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              if (aRelativePath != null) {
                sourceFile = util.join(aRelativePath, sourceFile);
              }
              node.setSourceContent(sourceFile, content);
            }
          });
    
          return node;
    
          function addMappingWithCode(mapping, code) {
            if (mapping === null || mapping.source === undefined) {
              node.add(code);
            } else {
              var source = aRelativePath
                ? util.join(aRelativePath, mapping.source)
                : mapping.source;
              node.add(new SourceNode(mapping.originalLine,
                                      mapping.originalColumn,
                                      source,
                                      code,
                                      mapping.name));
            }
          }
        };
    
      /**
       * Add a chunk of generated JS to this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      SourceNode.prototype.add = function SourceNode_add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function (chunk) {
            this.add(chunk);
          }, this);
        }
        else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          if (aChunk) {
            this.children.push(aChunk);
          }
        }
        else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
    
      /**
       * Add a chunk of generated JS to the beginning of this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (var i = aChunk.length-1; i >= 0; i--) {
            this.prepend(aChunk[i]);
          }
        }
        else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          this.children.unshift(aChunk);
        }
        else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
    
      /**
       * Walk over the tree of JS snippets in this node and its children. The
       * walking function is called once for each snippet of JS and is passed that
       * snippet and the its original associated source's line/column location.
       *
       * @param aFn The traversal function.
       */
      SourceNode.prototype.walk = function SourceNode_walk(aFn) {
        var chunk;
        for (var i = 0, len = this.children.length; i < len; i++) {
          chunk = this.children[i];
          if (chunk[isSourceNode]) {
            chunk.walk(aFn);
          }
          else {
            if (chunk !== '') {
              aFn(chunk, { source: this.source,
                           line: this.line,
                           column: this.column,
                           name: this.name });
            }
          }
        }
      };
    
      /**
       * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
       * each of `this.children`.
       *
       * @param aSep The separator.
       */
      SourceNode.prototype.join = function SourceNode_join(aSep) {
        var newChildren;
        var i;
        var len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i = 0; i < len-1; i++) {
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i]);
          this.children = newChildren;
        }
        return this;
      };
    
      /**
       * Call String.prototype.replace on the very right-most source snippet. Useful
       * for trimming whitespace from the end of a source node, etc.
       *
       * @param aPattern The pattern to replace.
       * @param aReplacement The thing to replace the pattern with.
       */
      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
        var lastChild = this.children[this.children.length - 1];
        if (lastChild[isSourceNode]) {
          lastChild.replaceRight(aPattern, aReplacement);
        }
        else if (typeof lastChild === 'string') {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        }
        else {
          this.children.push(''.replace(aPattern, aReplacement));
        }
        return this;
      };
    
      /**
       * Set the source content for a source file. This will be added to the SourceMapGenerator
       * in the sourcesContent field.
       *
       * @param aSourceFile The filename of the source file
       * @param aSourceContent The content of the source file
       */
      SourceNode.prototype.setSourceContent =
        function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
          this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
        };
    
      /**
       * Walk over the tree of SourceNodes. The walking function is called for each
       * source file content and is passed the filename and source content.
       *
       * @param aFn The traversal function.
       */
      SourceNode.prototype.walkSourceContents =
        function SourceNode_walkSourceContents(aFn) {
          for (var i = 0, len = this.children.length; i < len; i++) {
            if (this.children[i][isSourceNode]) {
              this.children[i].walkSourceContents(aFn);
            }
          }
    
          var sources = Object.keys(this.sourceContents);
          for (var i = 0, len = sources.length; i < len; i++) {
            aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
          }
        };
    
      /**
       * Return the string representation of this source node. Walks over the tree
       * and concatenates all the various snippets together to one string.
       */
      SourceNode.prototype.toString = function SourceNode_toString() {
        var str = "";
        this.walk(function (chunk) {
          str += chunk;
        });
        return str;
      };
    
      /**
       * Returns the string representation of this source node along with a source
       * map.
       */
      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
        var generated = {
          code: "",
          line: 1,
          column: 0
        };
        var map = new SourceMapGenerator(aArgs);
        var sourceMappingActive = false;
        var lastOriginalSource = null;
        var lastOriginalLine = null;
        var lastOriginalColumn = null;
        var lastOriginalName = null;
        this.walk(function (chunk, original) {
          generated.code += chunk;
          if (original.source !== null
              && original.line !== null
              && original.column !== null) {
            if(lastOriginalSource !== original.source
               || lastOriginalLine !== original.line
               || lastOriginalColumn !== original.column
               || lastOriginalName !== original.name) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map.addMapping({
              generated: {
                line: generated.line,
                column: generated.column
              }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          for (var idx = 0, length = chunk.length; idx < length; idx++) {
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
              generated.line++;
              generated.column = 0;
              // Mappings end at eol
              if (idx + 1 === length) {
                lastOriginalSource = null;
                sourceMappingActive = false;
              } else if (sourceMappingActive) {
                map.addMapping({
                  source: original.source,
                  original: {
                    line: original.line,
                    column: original.column
                  },
                  generated: {
                    line: generated.line,
                    column: generated.column
                  },
                  name: original.name
                });
              }
            } else {
              generated.column++;
            }
          }
        });
        this.walkSourceContents(function (sourceFile, sourceContent) {
          map.setSourceContent(sourceFile, sourceContent);
        });
    
        return { code: generated.code, map: map };
      };
    
      exports.SourceNode = SourceNode;
    
    });
    
  provide("source-map/source-map/source-node", module.exports);
}(global));

// pakmanager:source-map
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * Copyright 2009-2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE.txt or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    exports.SourceMapGenerator =  require('source-map/source-map/source-map-generator').SourceMapGenerator;
    exports.SourceMapConsumer =  require('source-map/source-map/source-map-consumer').SourceMapConsumer;
    exports.SourceNode =  require('source-map/source-map/source-node').SourceNode;
    
  provide("source-map", module.exports);
}(global));

// pakmanager:uglify-to-browserify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var fs = require('fs')
    var PassThrough = require('stream').PassThrough
    var Transform = require('stream').Transform
    
    if (typeof Transform === 'undefined') {
      throw new Error('UglifyJS only supports browserify when using node >= 0.10.x')
    }
    
    var cache = {}
    module.exports = transform
    function transform(file) {
      if (!/tools\/node\.js$/.test(file.replace(/\\/g,'/'))) return new PassThrough();
      if (cache[file]) return makeStream(cache[file])
      var uglify = require(file)
      var src = 'var sys = require("util");\nvar MOZ_SourceMap = require("source-map");\nvar UglifyJS = exports;\n' + uglify.FILES.map(function (path) { return fs.readFileSync(path, 'utf8') }).join('\n')
    
      var ast = uglify.parse(src)
      ast.figure_out_scope()
    
      var variables = ast.variables
        .map(function (node, name) {
          return name
        })
    
      src += '\n\n' + variables.map(function (v) { return 'exports.' + v + ' = ' + v + ';' }).join('\n') + '\n\n'
    
      src += 'exports.AST_Node.warn_function = function (txt) { if (typeof console != "undefined" && typeof console.warn === "function") console.warn(txt) }\n\n'
    
      src += 'exports.minify = ' + uglify.minify.toString() + ';\n\n'
      src += 'exports.describe_ast = ' + uglify.describe_ast.toString() + ';'
    
      // TODO: remove once https://github.com/substack/node-browserify/issues/631 is resolved
      src = src.replace(/"for"/g, '"fo" + "r"')
    
      cache[file] = src
      return makeStream(src);
    }
    
    function makeStream(src) {
      var res = new Transform();
      res._transform = function (chunk, encoding, callback) { callback() }
      res._flush = function (callback) {
        res.push(src)
        callback()
      }
      return res;
    }
    
  provide("uglify-to-browserify", module.exports);
}(global));

// pakmanager:yargs/lib/completion
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs')
    var path = require('path')
    
    // add bash completions to your
    //  yargs-powered applications.
    module.exports = function (yargs, usage) {
      var self = {
        completionKey: 'get-yargs-completions'
      }
    
      // get a list of completion commands.
      self.getCompletion = function (done) {
        var completions = []
        var current = process.argv[process.argv.length - 1]
        var previous = process.argv.slice(process.argv.indexOf('--' + self.completionKey) + 1)
        var argv = yargs.parse(previous)
    
        // a custom completion function can be provided
        // to completion().
        if (completionFunction) {
          if (completionFunction.length < 3) {
            // synchronous completion function.
            return done(completionFunction(current, argv))
          } else {
            // asynchronous completion function
            return completionFunction(current, argv, function (completions) {
              done(completions)
            })
          }
        }
    
        var handlers = yargs.getCommandHandlers()
        for (var i = 0, ii = previous.length; i < ii; ++i) {
          if (handlers[previous[i]]) {
            return handlers[previous[i]](yargs.reset())
          }
        }
    
        if (!current.match(/^-/)) {
          usage.getCommands().forEach(function (command) {
            if (previous.indexOf(command[0]) === -1) {
              completions.push(command[0])
            }
          })
        }
    
        if (current.match(/^-/)) {
          Object.keys(yargs.getOptions().key).forEach(function (key) {
            completions.push('--' + key)
          })
        }
    
        done(completions)
      }
    
      // generate the completion script to add to your .bashrc.
      self.generateCompletionScript = function ($0) {
        var script = fs.readFileSync(
          path.resolve(__dirname, '../completion.sh.hbs'),
          'utf-8'
        )
        var name = path.basename($0)
    
        // add ./to applications not yet installed as bin.
        if ($0.match(/\.js$/)) $0 = './' + $0
    
        script = script.replace(/{{app_name}}/g, name)
        return script.replace(/{{app_path}}/g, $0)
      }
    
      // register a function to perform your own custom
      // completions., this function can be either
      // synchrnous or asynchronous.
      var completionFunction = null
      self.registerFunction = function (fn) {
        completionFunction = fn
      }
    
      return self
    }
    
  provide("yargs/lib/completion", module.exports);
}(global));

// pakmanager:yargs/lib/parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // fancy-pants parsing of argv, originally forked
    // from minimist: https://www.npmjs.com/package/minimist
    var camelCase = require('camelcase')
    var path = require('path')
    
    function increment (orig) {
      return orig !== undefined ? orig + 1 : 0
    }
    
    module.exports = function (args, opts) {
      if (!opts) opts = {}
    
      var error = null
      var flags = { arrays: {}, bools: {}, strings: {}, counts: {}, normalize: {}, configs: {} }
    
      ;[].concat(opts['array']).filter(Boolean).forEach(function (key) {
        flags.arrays[key] = true
      })
    
      ;[].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
        flags.bools[key] = true
      })
    
      ;[].concat(opts.string).filter(Boolean).forEach(function (key) {
        flags.strings[key] = true
      })
    
      ;[].concat(opts.count).filter(Boolean).forEach(function (key) {
        flags.counts[key] = true
      })
    
      ;[].concat(opts.normalize).filter(Boolean).forEach(function (key) {
        flags.normalize[key] = true
      })
    
      ;[].concat(opts.config).filter(Boolean).forEach(function (key) {
        flags.configs[key] = true
      })
    
      var aliases = {}
      var newAliases = {}
    
      extendAliases(opts.key)
      extendAliases(opts.alias)
    
      var defaults = opts['default'] || {}
      Object.keys(defaults).forEach(function (key) {
        if (/-/.test(key) && !opts.alias[key]) {
          aliases[key] = aliases[key] || []
        }
        (aliases[key] || []).forEach(function (alias) {
          defaults[alias] = defaults[key]
        })
      })
    
      var argv = { _: [] }
    
      Object.keys(flags.bools).forEach(function (key) {
        setArg(key, !(key in defaults) ? false : defaults[key])
      })
    
      var notFlags = []
      if (args.indexOf('--') !== -1) {
        notFlags = args.slice(args.indexOf('--') + 1)
        args = args.slice(0, args.indexOf('--'))
      }
    
      for (var i = 0; i < args.length; i++) {
        var arg = args[i]
        var broken
        var key
        var letters
        var m
        var next
        var value
    
        // -- seperated by =
        if (arg.match(/^--.+=/)) {
          // Using [\s\S] instead of . because js doesn't support the
          // 'dotall' regex modifier. See:
          // http://stackoverflow.com/a/1068308/13216
          m = arg.match(/^--([^=]+)=([\s\S]*)$/)
    
          // nargs format = '--f=monkey washing cat'
          if (checkAllAliases(m[1], opts.narg)) {
            args.splice(i + 1, m[1], m[2])
            i = eatNargs(i, m[1], args)
          // arrays format = '--f=a b c'
          } else if (checkAllAliases(m[1], flags.arrays) && args.length > i + 1) {
            args.splice(i + 1, m[1], m[2])
            i = eatArray(i, m[1], args)
          } else {
            setArg(m[1], m[2])
          }
        } else if (arg.match(/^--no-.+/)) {
          key = arg.match(/^--no-(.+)/)[1]
          setArg(key, false)
    
        // -- seperated by space.
        } else if (arg.match(/^--.+/)) {
          key = arg.match(/^--(.+)/)[1]
    
          // nargs format = '--foo a b c'
          if (checkAllAliases(key, opts.narg)) {
            i = eatNargs(i, key, args)
          // array format = '--foo a b c'
          } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {
            i = eatArray(i, key, args)
          } else {
            next = args[i + 1]
    
            if (next !== undefined && !next.match(/^-/) &&
              !checkAllAliases(key, flags.bools) &&
              !checkAllAliases(key, flags.counts)) {
              setArg(key, next)
              i++
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next)
              i++
            } else {
              setArg(key, defaultForType(guessType(key, flags)))
            }
          }
    
        // dot-notation flag seperated by '='.
        } else if (arg.match(/^-.\..+=/)) {
          m = arg.match(/^-([^=]+)=([\s\S]*)$/)
          setArg(m[1], m[2])
    
        // dot-notation flag seperated by space.
        } else if (arg.match(/^-.\..+/)) {
          next = args[i + 1]
          key = arg.match(/^-(.\..+)/)[1]
    
          if (next !== undefined && !next.match(/^-/) &&
            !checkAllAliases(key, flags.bools) &&
            !checkAllAliases(key, flags.counts)) {
            setArg(key, next)
            i++
          } else {
            setArg(key, defaultForType(guessType(key, flags)))
          }
        } else if (arg.match(/^-[^-]+/)) {
          letters = arg.slice(1, -1).split('')
          broken = false
    
          for (var j = 0; j < letters.length; j++) {
            next = arg.slice(j + 2)
    
            if (letters[j + 1] && letters[j + 1] === '=') {
              value = arg.slice(j + 3)
              key = letters[j]
    
              // nargs format = '-f=monkey washing cat'
              if (checkAllAliases(letters[j], opts.narg)) {
                args.splice(i + 1, 0, value)
                i = eatNargs(i, key, args)
              // array format = '-f=a b c'
              } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {
                args.splice(i + 1, 0, value)
                i = eatArray(i, key, args)
              } else {
                setArg(key, value)
              }
    
              broken = true
              break
            }
    
            if (next === '-') {
              setArg(letters[j], next)
              continue
            }
    
            if (/[A-Za-z]/.test(letters[j]) &&
              /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
              setArg(letters[j], next)
              broken = true
              break
            }
    
            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], arg.slice(j + 2))
              broken = true
              break
            } else {
              setArg(letters[j], defaultForType(guessType(letters[j], flags)))
            }
          }
    
          key = arg.slice(-1)[0]
    
          if (!broken && key !== '-') {
            // nargs format = '-f a b c'
            if (checkAllAliases(key, opts.narg)) {
              i = eatNargs(i, key, args)
            // array format = '-f a b c'
            } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {
              i = eatArray(i, key, args)
            } else {
              if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) &&
                !checkAllAliases(key, flags.bools) &&
                !checkAllAliases(key, flags.counts)) {
                setArg(key, args[i + 1])
                i++
              } else if (args[i + 1] && /true|false/.test(args[i + 1])) {
                setArg(key, args[i + 1])
                i++
              } else {
                setArg(key, defaultForType(guessType(key, flags)))
              }
            }
          }
        } else {
          argv._.push(
            flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
          )
        }
      }
    
      setConfig(argv)
      applyDefaultsAndAliases(argv, aliases, defaults)
    
      Object.keys(flags.counts).forEach(function (key) {
        setArg(key, defaults[key])
      })
    
      notFlags.forEach(function (key) {
        argv._.push(key)
      })
    
      // how many arguments should we consume, based
      // on the nargs option?
      function eatNargs (i, key, args) {
        var toEat = checkAllAliases(key, opts.narg)
    
        if (args.length - (i + 1) < toEat) error = Error('not enough arguments following: ' + key)
    
        for (var ii = i + 1; ii < (toEat + i + 1); ii++) {
          setArg(key, args[ii])
        }
    
        return (i + toEat)
      }
    
      // if an option is an array, eat all non-hyphenated arguments
      // following it... YUM!
      // e.g., --foo apple banana cat becomes ["apple", "banana", "cat"]
      function eatArray (i, key, args) {
        for (var ii = i + 1; ii < args.length; ii++) {
          if (/^-/.test(args[ii])) break
          i = ii
          setArg(key, args[ii])
        }
    
        return i
      }
    
      function setArg (key, val) {
        // handle parsing boolean arguments --foo=true --bar false.
        if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
          if (typeof val === 'string') val = val === 'true'
        }
    
        if (/-/.test(key) && !(aliases[key] && aliases[key].length)) {
          var c = camelCase(key)
          aliases[key] = [c]
          newAliases[c] = true
        }
    
        var value = !checkAllAliases(key, flags.strings) && isNumber(val) ? Number(val) : val
    
        if (checkAllAliases(key, flags.counts)) {
          value = increment
        }
    
        var splitKey = key.split('.')
        setKey(argv, splitKey, value)
    
        ;(aliases[splitKey[0]] || []).forEach(function (x) {
          x = x.split('.')
    
          // handle populating dot notation for both
          // the key and its aliases.
          if (splitKey.length > 1) {
            var a = [].concat(splitKey)
            a.shift() // nuke the old key.
            x = x.concat(a)
          }
    
          setKey(argv, x, value)
        })
    
        var keys = [key].concat(aliases[key] || [])
        for (var i = 0, l = keys.length; i < l; i++) {
          if (flags.normalize[keys[i]]) {
            keys.forEach(function (key) {
              argv.__defineSetter__(key, function (v) {
                val = path.normalize(v)
              })
    
              argv.__defineGetter__(key, function () {
                return typeof val === 'string' ?
                path.normalize(val) : val
              })
            })
            break
          }
        }
      }
    
      // set args from config.json file, this should be
      // applied last so that defaults can be applied.
      function setConfig (argv) {
        var configLookup = {}
    
        // expand defaults/aliases, in-case any happen to reference
        // the config.json file.
        applyDefaultsAndAliases(configLookup, aliases, defaults)
    
        Object.keys(flags.configs).forEach(function (configKey) {
          var configPath = argv[configKey] || configLookup[configKey]
          if (configPath) {
            try {
              var config = require(path.resolve(process.cwd(), configPath))
    
              Object.keys(config).forEach(function (key) {
                // setting arguments via CLI takes precedence over
                // values within the config file.
                if (argv[key] === undefined) {
                  delete argv[key]
                  setArg(key, config[key])
                }
              })
            } catch (ex) {
              if (argv[configKey]) error = Error('invalid json config file: ' + configPath)
            }
          }
        })
      }
    
      function applyDefaultsAndAliases (obj, aliases, defaults) {
        Object.keys(defaults).forEach(function (key) {
          if (!hasKey(obj, key.split('.'))) {
            setKey(obj, key.split('.'), defaults[key])
    
            ;(aliases[key] || []).forEach(function (x) {
              setKey(obj, x.split('.'), defaults[key])
            })
          }
        })
      }
    
      function hasKey (obj, keys) {
        var o = obj
        keys.slice(0, -1).forEach(function (key) {
          o = (o[key] || {})
        })
    
        var key = keys[keys.length - 1]
        return key in o
      }
    
      function setKey (obj, keys, value) {
        var o = obj
        keys.slice(0, -1).forEach(function (key) {
          if (o[key] === undefined) o[key] = {}
          o = o[key]
        })
    
        var key = keys[keys.length - 1]
        if (value === increment) {
          o[key] = increment(o[key])
        } else if (o[key] === undefined && checkAllAliases(key, flags.arrays)) {
          o[key] = Array.isArray(value) ? value : [value]
        } else if (o[key] === undefined || typeof o[key] === 'boolean') {
          o[key] = value
        } else if (Array.isArray(o[key])) {
          o[key].push(value)
        } else {
          o[key] = [ o[key], value ]
        }
      }
    
      // extend the aliases list with inferred aliases.
      function extendAliases (obj) {
        Object.keys(obj || {}).forEach(function (key) {
          aliases[key] = [].concat(opts.alias[key] || [])
          // For "--option-name", also set argv.optionName
          aliases[key].concat(key).forEach(function (x) {
            if (/-/.test(x)) {
              var c = camelCase(x)
              aliases[key].push(c)
              newAliases[c] = true
            }
          })
          aliases[key].forEach(function (x) {
            aliases[x] = [key].concat(aliases[key].filter(function (y) {
              return x !== y
            }))
          })
        })
      }
    
      // check if a flag is set for any of a key's aliases.
      function checkAllAliases (key, flag) {
        var isSet = false
        var toCheck = [].concat(aliases[key] || [], key)
    
        toCheck.forEach(function (key) {
          if (flag[key]) isSet = flag[key]
        })
    
        return isSet
      }
    
      // return a default value, given the type of a flag.,
      // e.g., key of type 'string' will default to '', rather than 'true'.
      function defaultForType (type) {
        var def = {
          boolean: true,
          string: '',
          array: []
        }
    
        return def[type]
      }
    
      // given a flag, enforce a default type.
      function guessType (key, flags) {
        var type = 'boolean'
    
        if (flags.strings && flags.strings[key]) type = 'string'
        else if (flags.arrays && flags.arrays[key]) type = 'array'
    
        return type
      }
    
      function isNumber (x) {
        if (typeof x === 'number') return true
        if (/^0x[0-9a-f]+$/i.test(x)) return true
        return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x)
      }
    
      return {
        argv: argv,
        aliases: aliases,
        error: error,
        newAliases: newAliases
      }
    }
    
  provide("yargs/lib/parser", module.exports);
}(global));

// pakmanager:yargs/lib/usage
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // this file handles outputting usage instructions,
    // failures, etc. keeps logging in one place.
    var cliui = require('cliui')
    var decamelize = require('decamelize')
    var wsize = require('window-size')
    
    module.exports = function (yargs) {
      var self = {}
    
      // methods for ouputting/building failure message.
      var fails = []
      self.failFn = function (f) {
        fails.push(f)
      }
    
      var failMessage = null
      var showHelpOnFail = true
      self.showHelpOnFail = function (enabled, message) {
        if (typeof enabled === 'string') {
          message = enabled
          enabled = true
        } else if (typeof enabled === 'undefined') {
          enabled = true
        }
        failMessage = message
        showHelpOnFail = enabled
        return self
      }
    
      self.fail = function (msg) {
        if (fails.length) {
          fails.forEach(function (f) {
            f(msg)
          })
        } else {
          if (showHelpOnFail) yargs.showHelp('error')
          if (msg) console.error(msg)
          if (failMessage) {
            if (msg) console.error('')
            console.error(failMessage)
          }
          if (yargs.getExitProcess()) {
            process.exit(1)
          } else {
            throw new Error(msg)
          }
        }
      }
    
      // methods for ouputting/building help (usage) message.
      var usage
      self.usage = function (msg) {
        usage = msg
      }
    
      var examples = []
      self.example = function (cmd, description) {
        examples.push([cmd, description || ''])
      }
    
      var commands = []
      self.command = function (cmd, description) {
        commands.push([cmd, description || ''])
      }
      self.getCommands = function () {
        return commands
      }
    
      var descriptions = {}
      self.describe = function (key, desc) {
        if (typeof key === 'object') {
          Object.keys(key).forEach(function (k) {
            self.describe(k, key[k])
          })
        } else {
          descriptions[key] = desc
        }
      }
      self.getDescriptions = function () {
        return descriptions
      }
    
      var epilog
      self.epilog = function (msg) {
        epilog = msg
      }
    
      var wrap = windowWidth()
      self.wrap = function (cols) {
        wrap = cols
      }
    
      self.help = function () {
        normalizeAliases()
    
        var demanded = yargs.getDemanded()
        var options = yargs.getOptions()
        var keys = Object.keys(
          Object.keys(descriptions)
          .concat(Object.keys(demanded))
          .concat(Object.keys(options.default))
          .reduce(function (acc, key) {
            if (key !== '_') acc[key] = true
            return acc
          }, {})
        )
        var ui = cliui({
          width: wrap,
          wrap: !!wrap
        })
    
        // the usage string.
        if (usage) {
          var u = usage.replace(/\$0/g, yargs.$0)
          ui.div(u + '\n')
        }
    
        // your application's commands, i.e., non-option
        // arguments populated in '_'.
        if (commands.length) {
          ui.div('Commands:')
    
          commands.forEach(function (command) {
            ui.div(
              {text: command[0], padding: [0, 2, 0, 2], width: maxWidth(commands) + 4},
              {text: command[1]}
            )
          })
    
          ui.div()
        }
    
        // the options table.
        var aliasKeys = (Object.keys(options.alias) || [])
          .concat(Object.keys(yargs.parsed.newAliases) || [])
    
        keys = keys.filter(function (key) {
          return !yargs.parsed.newAliases[key] && aliasKeys.every(function (alias) {
            return (options.alias[alias] || []).indexOf(key) === -1
          })
        })
    
        var switches = keys.reduce(function (acc, key) {
          acc[key] = [ key ].concat(options.alias[key] || [])
          .map(function (sw) {
            return (sw.length > 1 ? '--' : '-') + sw
          })
          .join(', ')
    
          return acc
        }, {})
    
        if (keys.length) {
          ui.div('Options:')
    
          keys.forEach(function (key) {
            var kswitch = switches[key]
            var desc = descriptions[key] || ''
            var type = null
    
            if (~options.boolean.indexOf(key)) type = '[boolean]'
            if (~options.count.indexOf(key)) type = '[count]'
            if (~options.string.indexOf(key)) type = '[string]'
            if (~options.normalize.indexOf(key)) type = '[string]'
            if (~options.array.indexOf(key)) type = '[array]'
    
            var extra = [
                type,
                demanded[key] ? '[required]' : null,
                defaultString(options.default[key], options.defaultDescription[key])
              ].filter(Boolean).join(' ')
    
            ui.span(
              {text: kswitch, padding: [0, 2, 0, 2], width: maxWidth(switches) + 4},
              desc
            )
    
            if (extra) ui.div({text: extra, padding: [0, 0, 0, 2], align: 'right'})
            else ui.div()
          })
    
          ui.div()
        }
    
        // describe some common use-cases for your application.
        if (examples.length) {
          ui.div('Examples:')
    
          examples.forEach(function (example) {
            example[0] = example[0].replace(/\$0/g, yargs.$0)
          })
    
          examples.forEach(function (example) {
            ui.div(
              {text: example[0], padding: [0, 2, 0, 2], width: maxWidth(examples) + 4},
              example[1]
            )
          })
    
          ui.div()
        }
    
        // the usage string.
        if (epilog) {
          var e = epilog.replace(/\$0/g, yargs.$0)
          ui.div(e + '\n')
        }
    
        return ui.toString()
      }
    
      // return the maximum width of a string
      // in the left-hand column of a table.
      function maxWidth (table) {
        var width = 0
    
        // table might be of the form [leftColumn],
        // or {key: leftColumn}}
        if (!Array.isArray(table)) {
          table = Object.keys(table).map(function (key) {
            return [table[key]]
          })
        }
    
        table.forEach(function (v) {
          width = Math.max(v[0].length, width)
        })
    
        // if we've enabled 'wrap' we should limit
        // the max-width of the left-column.
        if (wrap) width = Math.min(width, parseInt(wrap * 0.5, 10))
    
        return width
      }
    
      // make sure any options set for aliases,
      // are copied to the keys being aliased.
      function normalizeAliases () {
        var demanded = yargs.getDemanded()
        var options = yargs.getOptions()
    
        ;(Object.keys(options.alias) || []).forEach(function (key) {
          options.alias[key].forEach(function (alias) {
            // copy descriptions.
            if (descriptions[alias]) self.describe(key, descriptions[alias])
            // copy demanded.
            if (demanded[alias]) yargs.demand(key, demanded[alias].msg)
    
            // type messages.
            if (~options.boolean.indexOf(alias)) yargs.boolean(key)
            if (~options.count.indexOf(alias)) yargs.count(key)
            if (~options.string.indexOf(alias)) yargs.string(key)
            if (~options.normalize.indexOf(alias)) yargs.normalize(key)
            if (~options.array.indexOf(alias)) yargs.array(key)
          })
        })
      }
    
      self.showHelp = function (level) {
        level = level || 'error'
        console[level](self.help())
      }
    
      self.functionDescription = function (fn, defaultDescription) {
        if (defaultDescription) {
          return defaultDescription
        }
        var description = fn.name ? decamelize(fn.name, '-') : 'generated-value'
        return ['(', description, ')'].join('')
      }
    
      // format the default-value-string displayed in
      // the right-hand column.
      function defaultString (value, defaultDescription) {
        var string = '[default: '
    
        if (value === undefined) return null
    
        if (defaultDescription) {
          string += defaultDescription
        } else {
          switch (typeof value) {
            case 'string':
              string += JSON.stringify(value)
              break
            case 'object':
              string += JSON.stringify(value)
              break
            default:
              string += value
          }
        }
    
        return string + ']'
      }
    
      // guess the width of the console window, max-width 80.
      function windowWidth () {
        return wsize.width ? Math.min(80, wsize.width) : null
      }
    
      // logic for displaying application version.
      var version = null
      self.version = function (ver, opt, msg) {
        version = ver
      }
    
      self.showVersion = function () {
        if (typeof version === 'function') console.log(version())
        else console.log(version)
      }
    
      return self
    }
    
  provide("yargs/lib/usage", module.exports);
}(global));

// pakmanager:yargs/lib/validation
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // validation-type-stuff, missing params,
    // bad implications, custom checks.
    module.exports = function (yargs, usage) {
      var self = {}
    
      // validate appropriate # of non-option
      // arguments were provided, i.e., '_'.
      self.nonOptionCount = function (argv) {
        var demanded = yargs.getDemanded()
        var _s = argv._.length
    
        if (demanded._ && (_s < demanded._.count || _s > demanded._.max)) {
          if (demanded._.msg !== undefined) {
            usage.fail(demanded._.msg)
          } else if (_s < demanded._.count) {
            usage.fail('Not enough non-option arguments: got ' +
              argv._.length + ', need at least ' + demanded._.count
            )
          } else {
            usage.fail('Too many non-option arguments: got ' +
              argv._.length + ', maximum of ' + demanded._.max
            )
          }
        }
      }
    
      // make sure that any args that require an
      // value (--foo=bar), have a value.
      self.missingArgumentValue = function (argv) {
        var defaultValues = [true, false, '']
        var options = yargs.getOptions()
    
        if (options.requiresArg.length > 0) {
          var missingRequiredArgs = []
    
          options.requiresArg.forEach(function (key) {
            var value = argv[key]
    
            // if a value is explicitly requested,
            // flag argument as missing if it does not
            // look like foo=bar was entered.
            if (~defaultValues.indexOf(value) ||
              (Array.isArray(value) && !value.length)) {
              missingRequiredArgs.push(key)
            }
          })
    
          if (missingRequiredArgs.length === 1) {
            usage.fail('Missing argument value: ' + missingRequiredArgs[0])
          } else if (missingRequiredArgs.length > 1) {
            var message = 'Missing argument values: ' + missingRequiredArgs.join(', ')
            usage.fail(message)
          }
        }
      }
    
      // make sure all the required arguments are present.
      self.requiredArguments = function (argv) {
        var demanded = yargs.getDemanded()
        var missing = null
    
        Object.keys(demanded).forEach(function (key) {
          if (!argv.hasOwnProperty(key)) {
            missing = missing || {}
            missing[key] = demanded[key]
          }
        })
    
        if (missing) {
          var customMsgs = []
          Object.keys(missing).forEach(function (key) {
            var msg = missing[key].msg
            if (msg && customMsgs.indexOf(msg) < 0) {
              customMsgs.push(msg)
            }
          })
    
          var customMsg = customMsgs.length ? '\n' + customMsgs.join('\n') : ''
          usage.fail('Missing required arguments: ' + Object.keys(missing).join(', ') + customMsg)
        }
      }
    
      // check for unknown arguments (strict-mode).
      self.unknownArguments = function (argv, aliases) {
        var aliasLookup = {}
        var descriptions = usage.getDescriptions()
        var demanded = yargs.getDemanded()
        var unknown = []
    
        Object.keys(aliases).forEach(function (key) {
          aliases[key].forEach(function (alias) {
            aliasLookup[alias] = key
          })
        })
    
        Object.keys(argv).forEach(function (key) {
          if (key !== '$0' && key !== '_' &&
            !descriptions.hasOwnProperty(key) &&
            !demanded.hasOwnProperty(key) &&
            !aliasLookup.hasOwnProperty(key)) {
            unknown.push(key)
          }
        })
    
        if (unknown.length === 1) {
          usage.fail('Unknown argument: ' + unknown[0])
        } else if (unknown.length > 1) {
          usage.fail('Unknown arguments: ' + unknown.join(', '))
        }
      }
    
      // custom checks, added using the `check` option on yargs.
      var checks = []
      self.check = function (f) {
        checks.push(f)
      }
    
      self.customChecks = function (argv, aliases) {
        checks.forEach(function (f) {
          try {
            var result = f(argv, aliases)
            if (!result) {
              usage.fail('Argument check failed: ' + f.toString())
            } else if (typeof result === 'string') {
              usage.fail(result)
            }
          } catch (err) {
            usage.fail(err.message ? err.message : err)
          }
        })
      }
    
      // check implications, argument foo implies => argument bar.
      var implied = {}
      self.implies = function (key, value) {
        if (typeof key === 'object') {
          Object.keys(key).forEach(function (k) {
            self.implies(k, key[k])
          })
        } else {
          implied[key] = value
        }
      }
      self.getImplied = function () {
        return implied
      }
    
      self.implications = function (argv) {
        var implyFail = []
    
        Object.keys(implied).forEach(function (key) {
          var num
          var origKey = key
          var value = implied[key]
    
          // convert string '1' to number 1
          num = Number(key)
          key = isNaN(num) ? key : num
    
          if (typeof key === 'number') {
            // check length of argv._
            key = argv._.length >= key
          } else if (key.match(/^--no-.+/)) {
            // check if key doesn't exist
            key = key.match(/^--no-(.+)/)[1]
            key = !argv[key]
          } else {
            // check if key exists
            key = argv[key]
          }
    
          num = Number(value)
          value = isNaN(num) ? value : num
    
          if (typeof value === 'number') {
            value = argv._.length >= value
          } else if (value.match(/^--no-.+/)) {
            value = value.match(/^--no-(.+)/)[1]
            value = !argv[value]
          } else {
            value = argv[value]
          }
    
          if (key && !value) {
            implyFail.push(origKey)
          }
        })
    
        if (implyFail.length) {
          var msg = 'Implications failed:\n'
    
          implyFail.forEach(function (key) {
            msg += ('  ' + key + ' -> ' + implied[key])
          })
    
          usage.fail(msg)
        }
      }
    
      return self
    }
    
  provide("yargs/lib/validation", module.exports);
}(global));

// pakmanager:yargs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var assert = require('assert')
    var Completion =  require('yargs/lib/completion')
    var Parser =  require('yargs/lib/parser')
    var path = require('path')
    var Usage =  require('yargs/lib/usage')
    var Validation =  require('yargs/lib/validation')
    
    Argv(process.argv.slice(2))
    
    var exports = module.exports = Argv
    function Argv (processArgs, cwd) {
      processArgs = processArgs || [] // handle calling yargs().
    
      var self = {}
      var completion = null
      var usage = null
      var validation = null
    
      if (!cwd) cwd = process.cwd()
    
      self.$0 = process.argv
        .slice(0, 2)
        .map(function (x, i) {
          // ignore the node bin, specify this in your
          // bin file with #!/usr/bin/env node
          if (i === 0 && /\b(node|iojs)$/.test(x)) return
          var b = rebase(cwd, x)
          return x.match(/^\//) && b.length < x.length
          ? b : x
        })
        .join(' ').trim()
    
      if (process.env._ !== undefined && process.argv[1] === process.env._) {
        self.$0 = process.env._.replace(
          path.dirname(process.execPath) + '/', ''
        )
      }
    
      var options
      self.resetOptions = self.reset = function () {
        // put yargs back into its initial
        // state, this is useful for creating a
        // nested CLI.
        options = {
          array: [],
          boolean: [],
          string: [],
          narg: {},
          key: {},
          alias: {},
          default: {},
          defaultDescription: {},
          requiresArg: [],
          count: [],
          normalize: [],
          config: []
        }
    
        usage = Usage(self) // handle usage output.
        validation = Validation(self, usage) // handle arg validation.
        completion = Completion(self, usage)
    
        demanded = {}
    
        exitProcess = true
        strict = false
        helpOpt = null
        versionOpt = null
        commandHandlers = {}
        self.parsed = false
    
        return self
      }
      self.resetOptions()
    
      self.boolean = function (bools) {
        options.boolean.push.apply(options.boolean, [].concat(bools))
        return self
      }
    
      self.array = function (arrays) {
        options.array.push.apply(options.array, [].concat(arrays))
        return self
      }
    
      self.nargs = function (key, n) {
        if (typeof key === 'object') {
          Object.keys(key).forEach(function (k) {
            self.nargs(k, key[k])
          })
        } else {
          options.narg[key] = n
        }
        return self
      }
    
      self.normalize = function (strings) {
        options.normalize.push.apply(options.normalize, [].concat(strings))
        return self
      }
    
      self.config = function (key, msg) {
        self.describe(key, msg || 'Path to JSON config file')
        options.config.push.apply(options.config, [].concat(key))
        return self
      }
    
      self.example = function (cmd, description) {
        usage.example(cmd, description)
        return self
      }
    
      self.command = function (cmd, description, fn) {
        if (description !== false) {
          usage.command(cmd, description)
        }
        if (fn) commandHandlers[cmd] = fn
        return self
      }
    
      var commandHandlers = {}
      self.getCommandHandlers = function () {
        return commandHandlers
      }
    
      self.string = function (strings) {
        options.string.push.apply(options.string, [].concat(strings))
        return self
      }
    
      self.default = function (key, value, defaultDescription) {
        if (typeof key === 'object') {
          Object.keys(key).forEach(function (k) {
            self.default(k, key[k])
          })
        } else {
          if (typeof value === 'function') {
            defaultDescription = usage.functionDescription(value, defaultDescription)
            value = value.call()
          }
          options.defaultDescription[key] = defaultDescription
          options.default[key] = value
        }
        return self
      }
    
      self.alias = function (x, y) {
        if (typeof x === 'object') {
          Object.keys(x).forEach(function (key) {
            self.alias(key, x[key])
          })
        } else {
          options.alias[x] = (options.alias[x] || []).concat(y)
        }
        return self
      }
    
      self.count = function (counts) {
        options.count.push.apply(options.count, [].concat(counts))
        return self
      }
    
      var demanded = {}
      self.demand = self.required = self.require = function (keys, max, msg) {
        // you can optionally provide a 'max' key,
        // which will raise an exception if too many '_'
        // options are provided.
        if (typeof max !== 'number') {
          msg = max
          max = Infinity
        }
    
        if (typeof keys === 'number') {
          if (!demanded._) demanded._ = { count: 0, msg: null, max: max }
          demanded._.count = keys
          demanded._.msg = msg
        } else if (Array.isArray(keys)) {
          keys.forEach(function (key) {
            self.demand(key, msg)
          })
        } else {
          if (typeof msg === 'string') {
            demanded[keys] = { msg: msg }
          } else if (msg === true || typeof msg === 'undefined') {
            demanded[keys] = { msg: undefined }
          }
        }
    
        return self
      }
      self.getDemanded = function () {
        return demanded
      }
    
      self.requiresArg = function (requiresArgs) {
        options.requiresArg.push.apply(options.requiresArg, [].concat(requiresArgs))
        return self
      }
    
      self.implies = function (key, value) {
        validation.implies(key, value)
        return self
      }
    
      self.usage = function (msg, opts) {
        if (!opts && typeof msg === 'object') {
          opts = msg
          msg = null
        }
    
        usage.usage(msg)
    
        if (opts) self.options(opts)
    
        return self
      }
    
      self.epilogue = self.epilog = function (msg) {
        usage.epilog(msg)
        return self
      }
    
      self.fail = function (f) {
        usage.failFn(f)
        return self
      }
    
      self.check = function (f) {
        validation.check(f)
        return self
      }
    
      self.defaults = self.default
    
      self.describe = function (key, desc) {
        options.key[key] = true
        usage.describe(key, desc)
        return self
      }
    
      self.parse = function (args) {
        return parseArgs(args)
      }
    
      self.option = self.options = function (key, opt) {
        if (typeof key === 'object') {
          Object.keys(key).forEach(function (k) {
            self.options(k, key[k])
          })
        } else {
          assert(typeof opt === 'object', 'second argument to option must be an object')
    
          options.key[key] = true // track manually set keys.
    
          if (opt.alias) self.alias(key, opt.alias)
    
          var demand = opt.demand || opt.required || opt.require
    
          if (demand) {
            self.demand(key, demand)
          } if ('default' in opt) {
            self.default(key, opt.default)
          } if ('nargs' in opt) {
            self.nargs(key, opt.nargs)
          } if (opt.boolean || opt.type === 'boolean') {
            self.boolean(key)
            if (opt.alias) self.boolean(opt.alias)
          } if (opt.array || opt.type === 'array') {
            self.array(key)
            if (opt.alias) self.array(opt.alias)
          } if (opt.string || opt.type === 'string') {
            self.string(key)
            if (opt.alias) self.string(opt.alias)
          } if (opt.count || opt.type === 'count') {
            self.count(key)
          }
    
          var desc = opt.describe || opt.description || opt.desc
          if (desc) {
            self.describe(key, desc)
          }
    
          if (opt.requiresArg) {
            self.requiresArg(key)
          }
        }
    
        return self
      }
      self.getOptions = function () {
        return options
      }
    
      self.wrap = function (cols) {
        usage.wrap(cols)
        return self
      }
    
      var strict = false
      self.strict = function () {
        strict = true
        return self
      }
      self.getStrict = function () {
        return strict
      }
    
      self.showHelp = function (level) {
        if (!self.parsed) parseArgs(processArgs) // run parser, if it has not already been executed.
        usage.showHelp(level)
        return self
      }
    
      var versionOpt = null
      self.version = function (ver, opt, msg) {
        versionOpt = opt || 'version'
        usage.version(ver)
        self.boolean(versionOpt)
        self.describe(versionOpt, msg || 'Show version number')
        return self
      }
    
      var helpOpt = null
      self.addHelpOpt = function (opt, msg) {
        helpOpt = opt
        self.boolean(opt)
        self.describe(opt, msg || 'Show help')
        return self
      }
    
      self.showHelpOnFail = function (enabled, message) {
        usage.showHelpOnFail(enabled, message)
        return self
      }
    
      var exitProcess = true
      self.exitProcess = function (enabled) {
        if (typeof enabled !== 'boolean') {
          enabled = true
        }
        exitProcess = enabled
        return self
      }
      self.getExitProcess = function () {
        return exitProcess
      }
    
      self.help = function () {
        if (arguments.length > 0) return self.addHelpOpt.apply(self, arguments)
    
        if (!self.parsed) parseArgs(processArgs) // run parser, if it has not already been executed.
    
        return usage.help()
      }
    
      var completionCommand = null
      self.completion = function (cmd, desc, fn) {
        // a function to execute when generating
        // completions can be provided as the second
        // or third argument to completion.
        if (typeof desc === 'function') {
          fn = desc
          desc = null
        }
    
        // register the completion command.
        completionCommand = cmd || 'completion'
        if (!desc && desc !== false) {
          desc = 'generate bash completion script'
        }
        self.command(completionCommand, desc)
    
        // a function can be provided
        if (fn) completion.registerFunction(fn)
    
        return self
      }
    
      self.showCompletionScript = function ($0) {
        $0 = $0 || self.$0
        console.log(completion.generateCompletionScript($0))
        return self
      }
    
      self.getUsageInstance = function () {
        return usage
      }
    
      self.getValidationInstance = function () {
        return validation
      }
    
      self.terminalWidth = function () {
        return require('window-size').width
      }
    
      Object.defineProperty(self, 'argv', {
        get: function () {
          var args = null
    
          try {
            args = parseArgs(processArgs)
          } catch (err) {
            usage.fail(err.message)
          }
    
          return args
        },
        enumerable: true
      })
    
      function parseArgs (args) {
        var parsed = Parser(args, options)
        var argv = parsed.argv
        var aliases = parsed.aliases
    
        argv.$0 = self.$0
    
        self.parsed = parsed
    
        // while building up the argv object, there
        // are two passes through the parser. If completion
        // is being performed short-circuit on the first pass.
        if (completionCommand &&
          (process.argv.join(' ')).indexOf(completion.completionKey) !== -1 &&
          !argv[completion.completionKey]) {
          return argv
        }
    
        // if there's a handler associated with a
        // command defer processing to it.
        var handlerKeys = Object.keys(self.getCommandHandlers())
        for (var i = 0, command; (command = handlerKeys[i]) !== undefined; i++) {
          if (~argv._.indexOf(command)) {
            self.getCommandHandlers()[command](self.reset())
            return self.argv
          }
        }
    
        // generate a completion script for adding to ~/.bashrc.
        if (completionCommand && ~argv._.indexOf(completionCommand) && !argv[completion.completionKey]) {
          self.showCompletionScript()
          if (exitProcess) {
            process.exit(0)
          }
        }
    
        // we must run completions first, a user might
        // want to complete the --help or --version option.
        if (completion.completionKey in argv) {
          // we allow for asynchronous completions,
          // e.g., loading in a list of commands from an API.
          completion.getCompletion(function (completions) {
            ;(completions || []).forEach(function (completion) {
              console.log(completion)
            })
    
            if (exitProcess) {
              process.exit(0)
            }
          })
          return
        }
    
        Object.keys(argv).forEach(function (key) {
          if (key === helpOpt && argv[key]) {
            self.showHelp('log')
            if (exitProcess) {
              process.exit(0)
            }
          } else if (key === versionOpt && argv[key]) {
            usage.showVersion()
            if (exitProcess) {
              process.exit(0)
            }
          }
        })
    
        if (parsed.error) throw parsed.error
    
        // if we're executed via bash completion, don't
        // bother with validation.
        if (!argv[completion.completionKey]) {
          validation.nonOptionCount(argv)
          validation.missingArgumentValue(argv)
          validation.requiredArguments(argv)
          if (strict) validation.unknownArguments(argv, aliases)
          validation.customChecks(argv, aliases)
          validation.implications(argv)
        }
    
        setPlaceholderKeys(argv)
    
        return argv
      }
    
      function setPlaceholderKeys (argv) {
        Object.keys(options.key).forEach(function (key) {
          if (typeof argv[key] === 'undefined') argv[key] = undefined
        })
      }
    
      sigletonify(self)
      return self
    }
    
    // rebase an absolute path to a relative one with respect to a base directory
    // exported for tests
    exports.rebase = rebase
    function rebase (base, dir) {
      return path.relative(base, dir)
    }
    
    /*  Hack an instance of Argv with process.argv into Argv
        so people can do
         require('yargs')(['--beeble=1','-z','zizzle']).argv
        to parse a list of args and
         require('yargs').argv
        to get a parsed version of process.argv.
    */
    function sigletonify (inst) {
      Object.keys(inst).forEach(function (key) {
        if (key === 'argv') {
          Argv.__defineGetter__(key, inst.__lookupGetter__(key))
        } else {
          Argv[key] = typeof inst[key] === 'function'
          ? inst[key].bind(inst)
          : inst[key]
        }
      })
    }
    
  provide("yargs", module.exports);
}(global));

// pakmanager:joi/lib/language
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.errors = {
        root: 'value',
        key: '"{{!key}}" ',
        messages: {
            wrapArrays: true
        },
        any: {
            unknown: 'is not allowed',
            invalid: 'contains an invalid value',
            empty: 'is not allowed to be empty',
            required: 'is required',
            allowOnly: 'must be one of {{valids}}',
            default: 'threw an error when running default method'
        },
        alternatives: {
            base: 'not matching any of the allowed alternatives'
        },
        array: {
            base: 'must be an array',
            includes: 'at position {{pos}} does not match any of the allowed types',
            includesSingle: 'single value of "{{!key}}" does not match any of the allowed types',
            includesOne: 'at position {{pos}} fails because {{reason}}',
            includesOneSingle: 'single value of "{{!key}}" fails because {{reason}}',
            includesRequiredUnknowns: 'does not contain {{unknownMisses}} required value(s)',
            includesRequiredKnowns: 'does not contain {{knownMisses}}',
            includesRequiredBoth: 'does not contain {{knownMisses}} and {{unknownMisses}} other required value(s)',
            excludes: 'at position {{pos}} contains an excluded value',
            excludesSingle: 'single value of "{{!key}}" contains an excluded value',
            min: 'must contain at least {{limit}} items',
            max: 'must contain less than or equal to {{limit}} items',
            length: 'must contain {{limit}} items',
            sparse: 'must not be a sparse array',
            unique: 'position {{pos}} contains a duplicate value'
        },
        boolean: {
            base: 'must be a boolean'
        },
        binary: {
            base: 'must be a buffer or a string',
            min: 'must be at least {{limit}} bytes',
            max: 'must be less than or equal to {{limit}} bytes',
            length: 'must be {{limit}} bytes'
        },
        date: {
            base: 'must be a number of milliseconds or valid date string',
            min: 'must be larger than or equal to "{{limit}}"',
            max: 'must be less than or equal to "{{limit}}"',
            isoDate: 'must be a valid ISO 8601 date',
            ref: 'references "{{ref}}" which is not a date'
        },
        function: {
            base: 'must be a Function'
        },
        object: {
            base: 'must be an object',
            child: 'child "{{!key}}" fails because {{reason}}',
            min: 'must have at least {{limit}} children',
            max: 'must have less than or equal to {{limit}} children',
            length: 'must have {{limit}} children',
            allowUnknown: 'is not allowed',
            with: 'missing required peer "{{peer}}"',
            without: 'conflict with forbidden peer "{{peer}}"',
            missing: 'must contain at least one of {{peers}}',
            xor: 'contains a conflict between exclusive peers {{peers}}',
            or: 'must contain at least one of {{peers}}',
            and: 'contains {{present}} without its required peers {{missing}}',
            nand: '!!"{{main}}" must not exist simultaneously with {{peers}}',
            assert: '!!"{{ref}}" validation failed because "{{ref}}" failed to {{message}}',
            rename: {
                multiple: 'cannot rename child "{{from}}" because multiple renames are disabled and another key was already renamed to "{{to}}"',
                override: 'cannot rename child "{{from}}" because override is disabled and target "{{to}}" exists'
            },
            type: 'must be an instance of "{{type}}"'
        },
        number: {
            base: 'must be a number',
            min: 'must be larger than or equal to {{limit}}',
            max: 'must be less than or equal to {{limit}}',
            less: 'must be less than {{limit}}',
            greater: 'must be greater than {{limit}}',
            float: 'must be a float or double',
            integer: 'must be an integer',
            negative: 'must be a negative number',
            positive: 'must be a positive number',
            precision: 'must have no more than {{limit}} decimal places',
            ref: 'references "{{ref}}" which is not a number',
            multiple: 'must be a multiple of {{multiple}}'
        },
        string: {
            base: 'must be a string',
            min: 'length must be at least {{limit}} characters long',
            max: 'length must be less than or equal to {{limit}} characters long',
            length: 'length must be {{limit}} characters long',
            alphanum: 'must only contain alpha-numeric characters',
            token: 'must only contain alpha-numeric and underscore characters',
            regex: {
                base: 'with value "{{!value}}" fails to match the required pattern: {{pattern}}',
                name: 'with value "{{!value}}" fails to match the {{name}} pattern'
            },
            email: 'must be a valid email',
            uri: 'must be a valid uri',
            uriCustomScheme: 'must be a valid uri with a scheme matching the {{scheme}} pattern',
            isoDate: 'must be a valid ISO 8601 date',
            guid: 'must be a valid GUID',
            hex: 'must only contain hexadecimal characters',
            hostname: 'must be a valid hostname',
            lowercase: 'must only contain lowercase characters',
            uppercase: 'must only contain uppercase characters',
            trim: 'must not have leading or trailing whitespace',
            creditCard: 'must be a credit card',
            ref: 'references "{{ref}}" which is not a number',
            ip: 'must be a valid ip address with a {{cidr}} CIDR',
            ipVersion: 'must be a valid ip address of one of the following versions {{version}} with a {{cidr}} CIDR'
        }
    };
    
  provide("joi/lib/language", module.exports);
}(global));

// pakmanager:joi/lib/errors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Hoek = require('hoek');
    var Language =  require('joi/lib/language');
    
    
    // Declare internals
    
    var internals = {};
    
    internals.stringify = function (value, wrapArrays) {
    
        var type = typeof value;
    
        if (value === null) {
            return 'null';
        }
    
        if (type === 'string') {
            return value;
        }
    
        if (value instanceof internals.Err || type === 'function') {
            return value.toString();
        }
    
        if (type === 'object') {
            if (Array.isArray(value)) {
                var partial = '';
    
                for (var i = 0, il = value.length; i < il; ++i) {
                    partial += (partial.length ? ', ' : '') + internals.stringify(value[i], wrapArrays);
                }
    
                return wrapArrays ? '[' + partial + ']' : partial;
            }
    
            return value.toString();
        }
    
        return JSON.stringify(value);
    };
    
    internals.Err = function (type, context, state, options) {
    
        this.type = type;
        this.context = context || {};
        this.context.key = state.key;
        this.path = state.path;
        this.options = options;
    };
    
    
    internals.Err.prototype.toString = function () {
    
        var self = this;
    
        var localized = this.options.language;
    
        if (localized.label) {
            this.context.key = localized.label;
        }
        else if (this.context.key === '' || this.context.key === null) {
            this.context.key = localized.root || Language.errors.root;
        }
    
        var format = Hoek.reach(localized, this.type) || Hoek.reach(Language.errors, this.type);
        var hasKey = /\{\{\!?key\}\}/.test(format);
        var skipKey = format.length > 2 && format[0] === '!' && format[1] === '!';
    
        if (skipKey) {
            format = format.slice(2);
        }
    
        if (!hasKey && !skipKey) {
            format = (Hoek.reach(localized, 'key') || Hoek.reach(Language.errors, 'key')) + format;
        }
    
        var wrapArrays = Hoek.reach(localized, 'messages.wrapArrays');
        if (typeof wrapArrays !== 'boolean') {
            wrapArrays = Language.errors.messages.wrapArrays;
        }
    
        var message = format.replace(/\{\{(\!?)([^}]+)\}\}/g, function ($0, isSecure, name) {
    
            var value = Hoek.reach(self.context, name);
            var normalized = internals.stringify(value, wrapArrays);
            return (isSecure ? Hoek.escapeHtml(normalized) : normalized);
        });
    
        return message;
    };
    
    
    exports.create = function (type, context, state, options) {
    
        return new internals.Err(type, context, state, options);
    };
    
    
    exports.process = function (errors, object) {
    
        if (!errors || !errors.length) {
            return null;
        }
    
        // Construct error
    
        var message = '';
        var details = [];
    
        var processErrors = function (errors, parent) {
    
            for (var i = 0, il = errors.length; i < il; ++i) {
                var item = errors[i];
    
                var detail = {
                    message: item.toString(),
                    path: internals.getPath(item),
                    type: item.type,
                    context: item.context
                };
    
                if (!parent) {
                    message += (message ? '. ' : '') + detail.message;
                }
    
                // Do not push intermediate errors, we're only interested in leafs
                if (item.context.reason && item.context.reason.length) {
                    processErrors(item.context.reason, item.path);
                }
                else {
                    details.push(detail);
                }
            }
        };
    
        processErrors(errors);
    
        var error = new Error(message);
        error.name = 'ValidationError';
        error.details = details;
        error._object = object;
        error.annotate = internals.annotate;
        return error;
    };
    
    
    internals.getPath = function (item) {
    
        var recursePath = function (it) {
    
            var reachedItem = Hoek.reach(it, 'context.reason.0');
            if (reachedItem && reachedItem.context) {
                return recursePath(reachedItem);
            }
    
            return it.path;
        };
    
        return recursePath(item) || item.context.key;
    };
    
    
    // Inspired by json-stringify-safe
    internals.safeStringify = function (obj, spaces) {
    
        return JSON.stringify(obj, internals.serializer(), spaces);
    };
    
    internals.serializer = function () {
    
        var cycleReplacer = function (key, value) {
    
            if (stack[0] === value) {
                return '[Circular ~]';
            }
    
            return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';
        };
    
        var keys = [], stack = [];
    
        return function (key, value) {
    
            if (stack.length > 0) {
                var thisPos = stack.indexOf(this);
                if (~thisPos) {
                    stack.length = thisPos + 1;
                    keys.length = thisPos + 1;
                    keys[thisPos] = key;
                }
                else {
                    stack.push(this);
                    keys.push(key);
                }
    
                if (~stack.indexOf(value)) {
                    value = cycleReplacer.call(this, key, value);
                }
            }
            else {
                stack.push(value);
            }
    
            return value;
        };
    };
    
    
    internals.annotate = function () {
    
        var obj = Hoek.clone(this._object || {});
    
        var lookup = {};
        var el = this.details.length;
        for (var e = el - 1; e >= 0; --e) {        // Reverse order to process deepest child first
            var pos = el - e;
            var error = this.details[e];
            var path = error.path.split('.');
            var ref = obj;
            for (var i = 0, il = path.length; i < il && ref; ++i) {
                var seg = path[i];
                if (i + 1 < il) {
                    ref = ref[seg];
                }
                else {
                    var value = ref[seg];
                    if (value !== undefined) {
                        delete ref[seg];
                        var label = seg + '_$key$_' + pos + '_$end$_';
                        ref[label] = value;
                        lookup[error.path] = label;
                    }
                    else if (lookup[error.path]) {
                        var replacement = lookup[error.path];
                        var appended = replacement.replace('_$end$_', ', ' + pos + '_$end$_');
                        ref[appended] = ref[replacement];
                        lookup[error.path] = appended;
                        delete ref[replacement];
                    }
                    else {
                        ref['_$miss$_' + seg + '|' + pos + '_$end$_'] = '__missing__';
                    }
                }
            }
        }
    
        var message = internals.safeStringify(obj, 2)
            .replace(/\[Circular (.*?)_\$key\$_([, \d]+)_\$end\$_\]/g, function ($0, $1) {
    
                return '[Circular ' + $1 + ']';
            }).replace(/_\$key\$_([, \d]+)_\$end\$_\"/g, function ($0, $1) {
    
                return '" \u001b[31m[' + $1 + ']\u001b[0m';
            }).replace(/\"_\$miss\$_([^\|]+)\|(\d+)_\$end\$_\"\: \"__missing__\"/g, function ($0, $1, $2) {
    
                return '\u001b[41m"' + $1 + '"\u001b[0m\u001b[31m [' + $2 + ']: -- missing --\u001b[0m';
            });
    
        message += '\n\u001b[31m';
    
        for (e = 0; e < el; ++e) {
            message += '\n[' + (e + 1) + '] ' + this.details[e].message;
        }
    
        message += '\u001b[0m';
    
        return message;
    };
    
  provide("joi/lib/errors", module.exports);
}(global));

// pakmanager:joi/lib/ref
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.create = function (key, options) {
    
        Hoek.assert(typeof key === 'string', 'Invalid reference key:', key);
    
        var settings = Hoek.clone(options);         // options can be reused and modified
    
        var ref = function (value, validationOptions) {
    
            return Hoek.reach(ref.isContext ? validationOptions.context : value, ref.key, settings);
        };
    
        ref.isContext = (key[0] === ((settings && settings.contextPrefix) || '$'));
        ref.key = (ref.isContext ? key.slice(1) : key);
        ref.path = ref.key.split((settings && settings.separator) || '.');
        ref.depth = ref.path.length;
        ref.root = ref.path[0];
        ref.isJoi = true;
    
        ref.toString = function () {
    
            return (ref.isContext ? 'context:' : 'ref:') + ref.key;
        };
    
        return ref;
    };
    
    
    exports.isRef = function (ref) {
    
        return typeof ref === 'function' && ref.isJoi;
    };
    
    
    exports.push = function (array, ref) {
    
        if (exports.isRef(ref) &&
            !ref.isContext) {
    
            array.push(ref.root);
        }
    };
    
  provide("joi/lib/ref", module.exports);
}(global));

// pakmanager:joi/lib/string/rfc3986
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var internals = {
        rfc3986: {}
    };
    
    /**
     * elements separated by forward slash ("/") are alternatives.
     */
    var or = '|';
    
    /**
     * DIGIT = %x30-39 ; 0-9
     */
    var digit = '0-9';
    var digitOnly = '[' + digit + ']';
    
    /**
     * ALPHA = %x41-5A / %x61-7A   ; A-Z / a-z
     */
    var alpha = 'a-zA-Z';
    var alphaOnly = '[' + alpha + ']';
    
    /**
     * cidr       = DIGIT                ; 0-9
     *            / %x31-32 DIGIT         ; 10-29
     *            / "3" %x30-32           ; 30-32
     */
    internals.rfc3986.cidr = digitOnly + or + '[1-2]' + digitOnly + or + '3' + '[0-2]';
    
    /**
     * HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
     */
    var hexDigit = digit + 'A-Fa-f',
        hexDigitOnly = '[' + hexDigit + ']';
    
    /**
     * unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
     */
    var unreserved = alpha + digit + '-\\._~';
    
    /**
     * sub-delims = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
     */
    var subDelims = '!\\$&\'\\(\\)\\*\\+,;=';
    
    /**
     * pct-encoded = "%" HEXDIG HEXDIG
     */
    var pctEncoded = '%' + hexDigit;
    
    /**
     * pchar = unreserved / pct-encoded / sub-delims / ":" / "@"
     */
    var pchar = unreserved + pctEncoded + subDelims + ':@';
    var pcharOnly = '[' + pchar + ']';
    
    /**
     * Rule to support zero-padded addresses.
     */
    var zeroPad = '0?';
    
    /**
     * dec-octet   = DIGIT                 ; 0-9
     *            / %x31-39 DIGIT         ; 10-99
     *            / "1" 2DIGIT            ; 100-199
     *            / "2" %x30-34 DIGIT     ; 200-249
     *            / "25" %x30-35          ; 250-255
     */
    var decOctect = '(?:' + zeroPad + zeroPad + digitOnly + or + zeroPad + '[1-9]' + digitOnly + or + '1' + digitOnly + digitOnly + or + '2' + '[0-4]' + digitOnly + or + '25' + '[0-5])';
    
    /**
     * IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet
     */
    internals.rfc3986.IPv4address = '(?:' + decOctect + '\\.){3}' + decOctect;
    
    /**
     * h16 = 1*4HEXDIG ; 16 bits of address represented in hexadecimal
     * ls32 = ( h16 ":" h16 ) / IPv4address ; least-significant 32 bits of address
     * IPv6address =                            6( h16 ":" ) ls32
     *             /                       "::" 5( h16 ":" ) ls32
     *             / [               h16 ] "::" 4( h16 ":" ) ls32
     *             / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
     *             / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
     *             / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
     *             / [ *4( h16 ":" ) h16 ] "::"              ls32
     *             / [ *5( h16 ":" ) h16 ] "::"              h16
     *             / [ *6( h16 ":" ) h16 ] "::"
     */
    var h16 = hexDigitOnly + '{1,4}';
    var ls32 = '(?:' + h16 + ':' + h16 + '|' + internals.rfc3986.IPv4address + ')';
    var IPv6SixHex = '(?:' + h16 + ':){6}' + ls32;
    var IPv6FiveHex = '::(?:' + h16 + ':){5}' + ls32;
    var IPv6FourHex = h16 + '::(?:' + h16 + ':){4}' + ls32;
    var IPv6ThreeHex = '(?:' + h16 + ':){0,1}' + h16 + '::(?:' + h16 + ':){3}' + ls32;
    var IPv6TwoHex = '(?:' + h16 + ':){0,2}' + h16 + '::(?:' + h16 + ':){2}' + ls32;
    var IPv6OneHex = '(?:' + h16 + ':){0,3}' + h16 + '::' + h16 + ':' + ls32;
    var IPv6NoneHex = '(?:' + h16 + ':){0,4}' + h16 + '::' + ls32;
    var IPv6NoneHex2 = '(?:' + h16 + ':){0,5}' + h16 + '::' + h16;
    var IPv6NoneHex3 = '(?:' + h16 + ':){0,6}' + h16 + '::';
    internals.rfc3986.IPv6address = '(?:' + IPv6SixHex + or + IPv6FiveHex + or + IPv6FourHex + or + IPv6ThreeHex + or + IPv6TwoHex + or + IPv6OneHex + or + IPv6NoneHex + or + IPv6NoneHex2 + or + IPv6NoneHex3 + ')';
    
    /**
     * IPvFuture = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
     */
    internals.rfc3986.IPvFuture = 'v' + hexDigitOnly + '+\\.[' + unreserved + subDelims + ':]+';
    
    /**
     * scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
     */
    internals.rfc3986.scheme = alphaOnly + '[' + alpha + digit + '+-\\.]*';
    
    /**
     * userinfo = *( unreserved / pct-encoded / sub-delims / ":" )
     */
    var userinfo = '[' + unreserved + pctEncoded + subDelims + ':]*';
    
    /**
     * IP-literal = "[" ( IPv6address / IPvFuture  ) "]"
     */
    var IPLiteral = '\\[(?:' + internals.rfc3986.IPv6address + or + internals.rfc3986.IPvFuture + ')\\]';
    
    /**
     * reg-name = *( unreserved / pct-encoded / sub-delims )
     */
    var regName = '[' + unreserved + pctEncoded + subDelims + ']{0,255}';
    
    /**
     * host = IP-literal / IPv4address / reg-name
     */
    var host = '(?:' + IPLiteral + or + internals.rfc3986.IPv4address + or + regName + ')';
    
    /**
     * port = *DIGIT
     */
    var port = digitOnly + '*';
    
    /**
     * authority   = [ userinfo "@" ] host [ ":" port ]
     */
    var authority = '(?:' + userinfo + '@)?' + host + '(?::' + port + ')?';
    
    /**
     * segment       = *pchar
     * segment-nz    = 1*pchar
     * path          = path-abempty    ; begins with "/" or is empty
     *               / path-absolute   ; begins with "/" but not "//"
     *               / path-noscheme   ; begins with a non-colon segment
     *               / path-rootless   ; begins with a segment
     *               / path-empty      ; zero characters
     * path-abempty  = *( "/" segment )
     * path-absolute = "/" [ segment-nz *( "/" segment ) ]
     * path-rootless = segment-nz *( "/" segment )
     */
    var segment = pcharOnly + '*';
    var segmentNz = pcharOnly + '+';
    var pathAbEmpty = '(?:\\/' + segment + ')*';
    var pathAbsolute = '\\/(?:' + segmentNz + pathAbEmpty + ')?';
    var pathRootless = segmentNz + pathAbEmpty;
    
    /**
     * hier-part = "//" authority path
     */
    internals.rfc3986.hierPart = '(?:\\/\\/' + authority + pathAbEmpty + or + pathAbsolute + or + pathRootless + ')';
    
    /**
     * query = *( pchar / "/" / "?" )
     */
    internals.rfc3986.query = '[' + pchar + '\\/\\?]*(?=#|$)'; //Finish matching either at the fragment part or end of the line.
    
    /**
     * fragment = *( pchar / "/" / "?" )
     */
    internals.rfc3986.fragment = '[' + pchar + '\\/\\?]*';
    
    module.exports = internals.rfc3986;
    
  provide("joi/lib/string/rfc3986", module.exports);
}(global));

// pakmanager:joi/lib/date
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Any =  require('joi/lib/any');
    var Errors =  require('joi/lib/errors');
    var Ref =  require('joi/lib/ref');
    var Hoek = require('hoek');
    var Moment = require('moment');
    
    
    // Declare internals
    
    var internals = {};
    
    internals.isoDate = /^(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/;
    internals.invalidDate = new Date('');
    internals.isIsoDate = (function () {
    
        var isoString = internals.isoDate.toString();
    
        return function (date) {
    
            return date && (date.toString() === isoString);
        };
    })();
    
    internals.Date = function () {
    
        Any.call(this);
        this._type = 'date';
    };
    
    Hoek.inherits(internals.Date, Any);
    
    
    internals.Date.prototype._base = function (value, state, options) {
    
        var result = {
            value: (options.convert && internals.toDate(value, this._flags.format)) || value
        };
    
        if (result.value instanceof Date && !isNaN(result.value.getTime())) {
            result.errors = null;
        }
        else {
            result.errors = Errors.create(internals.isIsoDate(this._flags.format) ? 'date.isoDate' : 'date.base', null, state, options);
        }
    
        return result;
    };
    
    
    internals.toDate = function (value, format) {
    
        if (value instanceof Date) {
            return value;
        }
    
        if (typeof value === 'string' ||
            Hoek.isInteger(value)) {
    
            if (typeof value === 'string' &&
                /^[+-]?\d+$/.test(value)) {
    
                value = parseInt(value, 10);
            }
    
            var date;
            if (format) {
                if (internals.isIsoDate(format)) {
                    date = format.test(value) ? new Date(value) : internals.invalidDate;
                }
                else {
                    date = Moment(value, format, true);
                    date = date.isValid() ? date.toDate() : internals.invalidDate;
                }
            }
            else {
                date = new Date(value);
            }
    
            if (!isNaN(date.getTime())) {
                return date;
            }
        }
    
        return null;
    };
    
    
    internals.compare = function (type, compare) {
    
        return function (date) {
    
            var isNow = date === 'now';
            var isRef = Ref.isRef(date);
    
            if (!isNow && !isRef) {
                date = internals.toDate(date);
            }
    
            Hoek.assert(date, 'Invalid date format');
    
            return this._test(type, date, function (value, state, options) {
    
                var compareTo;
                if (isNow) {
                    compareTo = Date.now();
                }
                else if (isRef) {
                    compareTo = internals.toDate(date(state.parent, options));
    
                    if (!compareTo) {
                        return Errors.create('date.ref', { ref: date.key }, state, options);
                    }
    
                    compareTo = compareTo.getTime();
                }
                else {
                    compareTo = date.getTime();
                }
    
                if (compare(value.getTime(), compareTo)) {
                    return null;
                }
    
                return Errors.create('date.' + type, { limit: new Date(compareTo) }, state, options);
            });
        };
    };
    
    
    internals.Date.prototype.min = internals.compare('min', function (value, date) {
    
        return value >= date;
    });
    
    
    internals.Date.prototype.max = internals.compare('max', function (value, date) {
    
        return value <= date;
    });
    
    
    internals.Date.prototype.format = function (format) {
    
        Hoek.assert(typeof format === 'string' || (Array.isArray(format) && format.every(function (f) {
    
            return typeof f === 'string';
        })), 'Invalid format.');
    
        var obj = this.clone();
        obj._flags.format = format;
        return obj;
    };
    
    internals.Date.prototype.iso = function () {
    
        var obj = this.clone();
        obj._flags.format = internals.isoDate;
        return obj;
    };
    
    internals.Date.prototype._isIsoDate = function (value) {
    
        return internals.isoDate.test(value);
    };
    
    module.exports = new internals.Date();
    
  provide("joi/lib/date", module.exports);
}(global));

// pakmanager:joi/lib/string/uri
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var RFC3986 =  require('joi/lib/string/rfc3986');
    
    var internals = {
        Uri: {
            createUriRegex: function (optionalScheme) {
    
                var scheme = RFC3986.scheme;
    
                // If we were passed a scheme, use it instead of the generic one
                if (optionalScheme) {
    
                    // Have to put this in a non-capturing group to handle the OR statements
                    scheme = '(?:' + optionalScheme + ')';
                }
    
                /**
                 * URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
                 */
                return new RegExp('^' + scheme + ':' + RFC3986.hierPart + '(?:\\?' + RFC3986.query + ')?' + '(?:#' + RFC3986.fragment + ')?$');
            }
        }
    };
    
    module.exports = internals.Uri;
    
  provide("joi/lib/string/uri", module.exports);
}(global));

// pakmanager:joi/lib/string/ip
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var RFC3986 =  require('joi/lib/string/rfc3986');
    
    var internals = {
        Ip: {
            cidrs: {
                required: '\\/(?:' + RFC3986.cidr + ')',
                optional: '(?:\\/(?:' + RFC3986.cidr + '))?',
                forbidden: ''
            },
            versions: {
                ipv4: RFC3986.IPv4address,
                ipv6: RFC3986.IPv6address,
                ipvfuture: RFC3986.IPvFuture
            }
        }
    };
    
    internals.Ip.createIpRegex = function (versions, cidr) {
    
        var regex;
        for (var i = 0, il = versions.length; i < il; ++i) {
            var version = versions[i];
            if (!regex) {
                regex = '^(?:' + internals.Ip.versions[version];
            }
            regex += '|' + internals.Ip.versions[version];
        }
    
        return new RegExp(regex + ')' + internals.Ip.cidrs[cidr] + '$');
    };
    
    module.exports = internals.Ip;
    
  provide("joi/lib/string/ip", module.exports);
}(global));

// pakmanager:joi/lib/alternatives
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Hoek = require('hoek');
    var Any =  require('joi/lib/any');
    var Cast =  require('joi/lib/cast');
    var Ref =  require('joi/lib/ref');
    var Errors =  require('joi/lib/errors');
    
    
    // Declare internals
    
    var internals = {};
    
    
    internals.Alternatives = function () {
    
        Any.call(this);
        this._type = 'alternatives';
        this._invalids.remove(null);
    
        this._inner.matches = [];
    };
    
    Hoek.inherits(internals.Alternatives, Any);
    
    
    internals.Alternatives.prototype._base = function (value, state, options) {
    
        var errors = [];
        for (var i = 0, il = this._inner.matches.length; i < il; ++i) {
            var item = this._inner.matches[i];
            var schema = item.schema;
            if (!schema) {
                var failed = item.is._validate(item.ref(state.parent, options), null, options, state.parent).errors;
                schema = failed ? item.otherwise : item.then;
                if (!schema) {
                    continue;
                }
            }
    
            var result = schema._validate(value, state, options);
            if (!result.errors) {     // Found a valid match
                return result;
            }
    
            errors = errors.concat(result.errors);
        }
    
        return { errors: errors.length ? errors : Errors.create('alternatives.base', null, state, options) };
    };
    
    
    internals.Alternatives.prototype.try = function (/* schemas */) {
    
    
        var schemas = Hoek.flatten(Array.prototype.slice.call(arguments));
        Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');
    
        var obj = this.clone();
    
        for (var i = 0, il = schemas.length; i < il; ++i) {
            var cast = Cast.schema(schemas[i]);
            if (cast._refs.length) {
                obj._refs = obj._refs.concat(cast._refs);
            }
            obj._inner.matches.push({ schema: cast });
        }
    
        return obj;
    };
    
    
    internals.Alternatives.prototype.when = function (ref, options) {
    
        Hoek.assert(Ref.isRef(ref) || typeof ref === 'string', 'Invalid reference:', ref);
        Hoek.assert(options, 'Missing options');
        Hoek.assert(typeof options === 'object', 'Invalid options');
        Hoek.assert(options.hasOwnProperty('is'), 'Missing "is" directive');
        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of "then" or "otherwise"');
    
        var obj = this.clone();
        var is = Cast.schema(options.is);
    
        if (options.is === null || !options.is.isJoi) {
    
            // Only apply required if this wasn't already a schema, we'll suppose people know what they're doing
            is = is.required();
        }
    
        var item = {
            ref: Cast.ref(ref),
            is: is,
            then: options.then !== undefined ? Cast.schema(options.then) : undefined,
            otherwise: options.otherwise !== undefined ? Cast.schema(options.otherwise) : undefined
        };
    
        Ref.push(obj._refs, item.ref);
        obj._refs = obj._refs.concat(item.is._refs);
    
        if (item.then && item.then._refs) {
            obj._refs = obj._refs.concat(item.then._refs);
        }
    
        if (item.otherwise && item.otherwise._refs) {
            obj._refs = obj._refs.concat(item.otherwise._refs);
        }
    
        obj._inner.matches.push(item);
    
        return obj;
    };
    
    
    internals.Alternatives.prototype.describe = function () {
    
        var description = Any.prototype.describe.call(this);
        var alternatives = [];
        for (var i = 0, il = this._inner.matches.length; i < il; ++i) {
            var item = this._inner.matches[i];
            if (item.schema) {
    
                // try()
    
                alternatives.push(item.schema.describe());
            }
            else {
    
                // when()
    
                var when = {
                    ref: item.ref.toString(),
                    is: item.is.describe()
                };
    
                if (item.then) {
                    when.then = item.then.describe();
                }
    
                if (item.otherwise) {
                    when.otherwise = item.otherwise.describe();
                }
    
                alternatives.push(when);
            }
        }
    
        description.alternatives = alternatives;
        return description;
    };
    
    
    module.exports = new internals.Alternatives();
    
  provide("joi/lib/alternatives", module.exports);
}(global));

// pakmanager:joi/lib/number
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Any =  require('joi/lib/any');
    var Ref =  require('joi/lib/ref');
    var Errors =  require('joi/lib/errors');
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    
    internals.Number = function () {
    
        Any.call(this);
        this._type = 'number';
        this._invalids.add(Infinity);
        this._invalids.add(-Infinity);
    };
    
    Hoek.inherits(internals.Number, Any);
    
    internals.compare = function (type, compare) {
    
        return function (limit) {
    
            var isRef = Ref.isRef(limit);
            var isNumber = typeof limit === 'number' && !isNaN(limit);
    
            Hoek.assert(isNumber || isRef, 'limit must be a number or reference');
    
            return this._test(type, limit, function (value, state, options) {
    
                var compareTo;
                if (isRef) {
                    compareTo = limit(state.parent, options);
    
                    if (!(typeof compareTo === 'number' && !isNaN(compareTo))) {
                        return Errors.create('number.ref', { ref: limit.key }, state, options);
                    }
                }
                else {
                    compareTo = limit;
                }
    
                if (compare(value, compareTo)) {
                    return null;
                }
    
                return Errors.create('number.' + type, { limit: compareTo, value: value }, state, options);
            });
        };
    };
    
    
    internals.Number.prototype._base = function (value, state, options) {
    
        var result = {
            errors: null,
            value: value
        };
    
        if (typeof value === 'string' &&
            options.convert) {
    
            var number = parseFloat(value);
            result.value = (isNaN(number) || !isFinite(value)) ? NaN : number;
        }
    
        var isNumber = typeof result.value === 'number' && !isNaN(result.value);
    
        if (options.convert && 'precision' in this._flags && isNumber) {
    
            // This is conceptually equivalent to using toFixed but it should be much faster
            var precision = Math.pow(10, this._flags.precision);
            result.value = Math.round(result.value * precision) / precision;
        }
    
        result.errors = isNumber ? null : Errors.create('number.base', null, state, options);
        return result;
    };
    
    
    internals.Number.prototype.min = internals.compare('min', function (value, limit) {
    
        return value >= limit;
    });
    
    
    internals.Number.prototype.max = internals.compare('max', function (value, limit) {
    
        return value <= limit;
    });
    
    
    internals.Number.prototype.greater = internals.compare('greater', function (value, limit) {
    
        return value > limit;
    });
    
    
    internals.Number.prototype.less = internals.compare('less', function (value, limit) {
    
        return value < limit;
    });
    
    
    internals.Number.prototype.multiple = function (base) {
    
        Hoek.assert(Hoek.isInteger(base), 'multiple must be an integer');
        Hoek.assert(base > 0, 'multiple must be greater than 0');
    
        return this._test('multiple', base, function (value, state, options) {
    
            if (value % base === 0) {
                return null;
            }
    
            return Errors.create('number.multiple', { multiple: base, value: value }, state, options);
        });
    };
    
    
    internals.Number.prototype.integer = function () {
    
        return this._test('integer', undefined, function (value, state, options) {
    
            return Hoek.isInteger(value) ? null : Errors.create('number.integer', { value: value }, state, options);
        });
    };
    
    
    internals.Number.prototype.negative = function () {
    
        return this._test('negative', undefined, function (value, state, options) {
    
            if (value < 0) {
                return null;
            }
    
            return Errors.create('number.negative', { value: value }, state, options);
        });
    };
    
    
    internals.Number.prototype.positive = function () {
    
        return this._test('positive', undefined, function (value, state, options) {
    
            if (value > 0) {
                return null;
            }
    
            return Errors.create('number.positive', { value: value }, state, options);
        });
    };
    
    
    internals.precisionRx = /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/;
    
    
    internals.Number.prototype.precision = function (limit) {
    
        Hoek.assert(Hoek.isInteger(limit), 'limit must be an integer');
        Hoek.assert(!('precision' in this._flags), 'precision already set');
    
        var obj = this._test('precision', limit, function (value, state, options){
    
            var places = value.toString().match(internals.precisionRx);
            var decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
            if (decimals <= limit) {
                return null;
            }
    
            return Errors.create('number.precision', { limit: limit, value: value }, state, options);
        });
    
        obj._flags.precision = limit;
        return obj;
    };
    
    
    module.exports = new internals.Number();
    
  provide("joi/lib/number", module.exports);
}(global));

// pakmanager:joi/lib/boolean
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Any =  require('joi/lib/any');
    var Errors =  require('joi/lib/errors');
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    
    internals.Boolean = function () {
    
        Any.call(this);
        this._type = 'boolean';
    };
    
    Hoek.inherits(internals.Boolean, Any);
    
    
    internals.Boolean.prototype._base = function (value, state, options) {
    
        var result = {
            value: value
        };
    
        if (typeof value === 'string' &&
            options.convert) {
    
            var lower = value.toLowerCase();
            result.value = (lower === 'true' || lower === 'yes' || lower === 'on' ? true
                                                                                  : (lower === 'false' || lower === 'no' || lower === 'off' ? false : value));
        }
    
        result.errors = (typeof result.value === 'boolean') ? null : Errors.create('boolean.base', null, state, options);
        return result;
    };
    
    
    module.exports = new internals.Boolean();
    
  provide("joi/lib/boolean", module.exports);
}(global));

// pakmanager:joi/lib/object
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Hoek = require('hoek');
    var Topo = require('topo');
    var Any =  require('joi/lib/any');
    var Cast =  require('joi/lib/cast');
    var Errors =  require('joi/lib/errors');
    
    
    // Declare internals
    
    var internals = {};
    
    
    internals.Object = function () {
    
        Any.call(this);
        this._type = 'object';
        this._inner.children = null;
        this._inner.renames = [];
        this._inner.dependencies = [];
        this._inner.patterns = [];
    };
    
    Hoek.inherits(internals.Object, Any);
    
    
    internals.Object.prototype._base = function (value, state, options) {
    
        var item, key, localState, result;
        var target = value;
        var errors = [];
        var finish = function () {
    
            return {
                value: target,
                errors: errors.length ? errors : null
            };
        };
    
        if (typeof value === 'string' &&
            options.convert) {
    
            try {
                value = JSON.parse(value);
            }
            catch (parseErr) { }
        }
    
        if (!value ||
            typeof value !== 'object' ||
            Array.isArray(value)) {
    
            errors.push(Errors.create('object.base', null, state, options));
            return finish();
        }
    
        // Skip if there are no other rules to test
    
        if (!this._inner.renames.length &&
            !this._inner.dependencies.length &&
            !this._inner.children &&                    // null allows any keys
            !this._inner.patterns.length) {
    
            target = value;
            return finish();
        }
    
        // Ensure target is a local copy (parsed) or shallow copy
    
        if (target === value) {
            target = Object.create(Object.getPrototypeOf(value));
            var valueKeys = Object.keys(value);
            for (var t = 0, tl = valueKeys.length; t < tl; ++t) {
                target[valueKeys[t]] = value[valueKeys[t]];
            }
        }
        else {
            target = value;
        }
    
        // Rename keys
    
        var renamed = {};
        for (var r = 0, rl = this._inner.renames.length; r < rl; ++r) {
            item = this._inner.renames[r];
    
            if (item.options.ignoreUndefined && target[item.from] === undefined) {
                continue;
            }
    
            if (!item.options.multiple &&
                renamed[item.to]) {
    
                errors.push(Errors.create('object.rename.multiple', { from: item.from, to: item.to }, state, options));
                if (options.abortEarly) {
                    return finish();
                }
            }
    
            if (target.hasOwnProperty(item.to) &&
                !item.options.override &&
                !renamed[item.to]) {
    
                errors.push(Errors.create('object.rename.override', { from: item.from, to: item.to }, state, options));
                if (options.abortEarly) {
                    return finish();
                }
            }
    
            if (target[item.from] === undefined) {
                delete target[item.to];
            }
            else {
                target[item.to] = target[item.from];
            }
    
            renamed[item.to] = true;
    
            if (!item.options.alias) {
                delete target[item.from];
            }
        }
    
        // Validate schema
    
        if (!this._inner.children &&            // null allows any keys
            !this._inner.patterns.length &&
            !this._inner.dependencies.length) {
    
            return finish();
        }
    
        var unprocessed = Hoek.mapToObject(Object.keys(target));
    
        if (this._inner.children) {
            for (var i = 0, il = this._inner.children.length; i < il; ++i) {
                var child = this._inner.children[i];
                key = child.key;
                item = target[key];
    
                delete unprocessed[key];
    
                localState = { key: key, path: (state.path ? state.path + '.' : '') + key, parent: target, reference: state.reference };
                result = child.schema._validate(item, localState, options);
                if (result.errors) {
                    errors.push(Errors.create('object.child', { key: key, reason: result.errors }, localState, options));
    
                    if (options.abortEarly) {
                        return finish();
                    }
                }
    
                if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {
                    delete target[key];
                }
                else if (result.value !== undefined) {
                    target[key] = result.value;
                }
            }
        }
    
        // Unknown keys
    
        var unprocessedKeys = Object.keys(unprocessed);
        if (unprocessedKeys.length &&
            this._inner.patterns.length) {
    
            for (i = 0, il = unprocessedKeys.length; i < il; ++i) {
                key = unprocessedKeys[i];
    
                for (var p = 0, pl = this._inner.patterns.length; p < pl; ++p) {
                    var pattern = this._inner.patterns[p];
    
                    if (pattern.regex.test(key)) {
                        delete unprocessed[key];
    
                        item = target[key];
                        localState = { key: key, path: (state.path ? state.path + '.' : '') + key, parent: target, reference: state.reference };
                        result = pattern.rule._validate(item, localState, options);
                        if (result.errors) {
                            errors.push(Errors.create('object.child', { key: key, reason: result.errors }, localState, options));
    
                            if (options.abortEarly) {
                                return finish();
                            }
                        }
    
                        if (result.value !== undefined) {
                            target[key] = result.value;
                        }
                    }
                }
            }
    
            unprocessedKeys = Object.keys(unprocessed);
        }
    
        if ((this._inner.children || this._inner.patterns.length) && unprocessedKeys.length) {
            if (options.stripUnknown ||
                options.skipFunctions) {
    
                var hasFunctions = false;
                for (var k = 0, kl = unprocessedKeys.length; k < kl; ++k) {
                    key = unprocessedKeys[k];
    
                    if (options.stripUnknown) {
                        delete target[key];
                    }
                    else if (typeof target[key] === 'function') {
                        delete unprocessed[key];
                        hasFunctions = true;
                    }
                }
    
                if (options.stripUnknown) {
                    return finish();
                }
    
                if (hasFunctions) {
                    unprocessedKeys = Object.keys(unprocessed);
                }
            }
    
            if (unprocessedKeys.length &&
                (this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {
    
                for (var e = 0, el = unprocessedKeys.length; e < el; ++e) {
                    errors.push(Errors.create('object.allowUnknown', null, { key: unprocessedKeys[e], path: state.path }, options));
                }
            }
        }
    
        // Validate dependencies
    
        for (var d = 0, dl = this._inner.dependencies.length; d < dl; ++d) {
            var dep = this._inner.dependencies[d];
            var err = internals[dep.type](dep.key !== null && value[dep.key], dep.peers, target, { key: dep.key, path: (state.path ? state.path + '.' : '') + (dep.key || '') }, options);
            if (err) {
                errors.push(err);
                if (options.abortEarly) {
                    return finish();
                }
            }
        }
    
        return finish();
    };
    
    
    internals.Object.prototype.keys = function (schema) {
    
        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');
        Hoek.assert(!schema || !schema.isJoi, 'Object schema cannot be a joi schema');
    
        var obj = this.clone();
    
        if (!schema) {
            obj._inner.children = null;
            return obj;
        }
    
        var children = Object.keys(schema);
    
        if (!children.length) {
            obj._inner.children = [];
            return obj;
        }
    
        var topo = new Topo();
        var child;
        if (obj._inner.children) {
            for (var i = 0, il = obj._inner.children.length; i < il; ++i) {
                child = obj._inner.children[i];
                topo.add(child, { after: child._refs, group: child.key });
            }
        }
    
        for (var c = 0, cl = children.length; c < cl; ++c) {
            var key = children[c];
            child = schema[key];
            var cast = Cast.schema(child);
            topo.add({ key: key, schema: cast }, { after: cast._refs, group: key });
        }
    
        obj._inner.children = topo.nodes;
    
        return obj;
    };
    
    
    internals.Object.prototype.unknown = function (allow) {
    
        var obj = this.clone();
        obj._flags.allowUnknown = (allow !== false);
        return obj;
    };
    
    
    internals.Object.prototype.length = function (limit) {
    
        Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');
    
        return this._test('length', limit, function (value, state, options) {
    
            if (Object.keys(value).length === limit) {
                return null;
            }
    
            return Errors.create('object.length', { limit: limit }, state, options);
        });
    };
    
    
    internals.Object.prototype.min = function (limit) {
    
        Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');
    
        return this._test('min', limit, function (value, state, options) {
    
            if (Object.keys(value).length >= limit) {
                return null;
            }
    
            return Errors.create('object.min', { limit: limit }, state, options);
        });
    };
    
    
    internals.Object.prototype.max = function (limit) {
    
        Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');
    
        return this._test('max', limit, function (value, state, options) {
    
            if (Object.keys(value).length <= limit) {
                return null;
            }
    
            return Errors.create('object.max', { limit: limit }, state, options);
        });
    };
    
    
    internals.Object.prototype.pattern = function (pattern, schema) {
    
        Hoek.assert(pattern instanceof RegExp, 'Invalid regular expression');
        Hoek.assert(schema !== undefined, 'Invalid rule');
    
        pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags
    
        var obj = this.clone();
        obj._inner.patterns.push({ regex: pattern, rule: Cast.schema(schema) });
        return obj;
    };
    
    
    internals.Object.prototype.with = function (key, peers) {
    
        return this._dependency('with', key, peers);
    };
    
    
    internals.Object.prototype.without = function (key, peers) {
    
        return this._dependency('without', key, peers);
    };
    
    
    internals.Object.prototype.xor = function () {
    
        var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
        return this._dependency('xor', null, peers);
    };
    
    
    internals.Object.prototype.or = function () {
    
        var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
        return this._dependency('or', null, peers);
    };
    
    
    internals.Object.prototype.and = function () {
    
        var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
        return this._dependency('and', null, peers);
    };
    
    
    internals.Object.prototype.nand = function () {
    
        var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
        return this._dependency('nand', null, peers);
    };
    
    
    internals.Object.prototype.requiredKeys = function (children) {
    
        children = Hoek.flatten(Array.prototype.slice.call(arguments));
        return this.applyFunctionToChildren(children, 'required');
    };
    
    
    internals.Object.prototype.optionalKeys = function (children) {
    
        children = Hoek.flatten(Array.prototype.slice.call(arguments));
        return this.applyFunctionToChildren(children, 'optional');
    };
    
    
    internals.renameDefaults = {
        alias: false,                   // Keep old value in place
        multiple: false,                // Allow renaming multiple keys into the same target
        override: false                 // Overrides an existing key
    };
    
    
    internals.Object.prototype.rename = function (from, to, options) {
    
        Hoek.assert(typeof from === 'string', 'Rename missing the from argument');
        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');
        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);
    
        for (var i = 0, il = this._inner.renames.length; i < il; ++i) {
            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');
        }
    
        var obj = this.clone();
    
        obj._inner.renames.push({
            from: from,
            to: to,
            options: Hoek.applyToDefaults(internals.renameDefaults, options || {})
        });
    
        return obj;
    };
    
    
    internals.groupChildren = function (children) {
    
        children.sort();
    
        var grouped = {};
    
        for (var c = 0, lc = children.length; c < lc; c++) {
            var child = children[c];
            Hoek.assert(typeof child === 'string', 'children must be strings');
            var group = child.split('.')[0];
            var childGroup = grouped[group] = (grouped[group] || []);
            childGroup.push(child.substring(group.length + 1));
        }
    
        return grouped;
    };
    
    
    internals.Object.prototype.applyFunctionToChildren = function (children, fn, args, root) {
    
        children = [].concat(children);
        Hoek.assert(children.length > 0, 'expected at least one children');
    
        var groupedChildren = internals.groupChildren(children);
        var obj;
    
        if ('' in groupedChildren) {
            obj = this[fn].apply(this, args);
            delete groupedChildren[''];
        }
        else {
            obj = this.clone();
        }
    
        if (obj._inner.children) {
            root = root ? (root + '.') : '';
    
            for (var i = 0, il = obj._inner.children.length; i < il; ++i) {
                var child = obj._inner.children[i];
                var group = groupedChildren[child.key];
    
                if (group) {
                    obj._inner.children[i] = {
                        key: child.key,
                        _refs: child._refs,
                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)
                    };
    
                    delete groupedChildren[child.key];
                }
            }
        }
    
        var remaining = Object.keys(groupedChildren);
        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));
    
        return obj;
    };
    
    
    internals.Object.prototype._dependency = function (type, key, peers) {
    
        peers = [].concat(peers);
        for (var i = 0, li = peers.length; i < li; i++) {
            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');
        }
    
        var obj = this.clone();
        obj._inner.dependencies.push({ type: type, key: key, peers: peers });
        return obj;
    };
    
    
    internals.with = function (value, peers, parent, state, options) {
    
        if (value === undefined) {
            return null;
        }
    
        for (var i = 0, il = peers.length; i < il; ++i) {
            var peer = peers[i];
            if (!parent.hasOwnProperty(peer) ||
                parent[peer] === undefined) {
    
                return Errors.create('object.with', { peer: peer }, state, options);
            }
        }
    
        return null;
    };
    
    
    internals.without = function (value, peers, parent, state, options) {
    
        if (value === undefined) {
            return null;
        }
    
        for (var i = 0, il = peers.length; i < il; ++i) {
            var peer = peers[i];
            if (parent.hasOwnProperty(peer) &&
                parent[peer] !== undefined) {
    
                return Errors.create('object.without', { peer: peer }, state, options);
            }
        }
    
        return null;
    };
    
    
    internals.xor = function (value, peers, parent, state, options) {
    
        var present = [];
        for (var i = 0, il = peers.length; i < il; ++i) {
            var peer = peers[i];
            if (parent.hasOwnProperty(peer) &&
                parent[peer] !== undefined) {
    
                present.push(peer);
            }
        }
    
        if (present.length === 1) {
            return null;
        }
    
        if (present.length === 0) {
            return Errors.create('object.missing', { peers: peers }, state, options);
        }
    
        return Errors.create('object.xor', { peers: peers }, state, options);
    };
    
    
    internals.or = function (value, peers, parent, state, options) {
    
        for (var i = 0, il = peers.length; i < il; ++i) {
            var peer = peers[i];
            if (parent.hasOwnProperty(peer) &&
                parent[peer] !== undefined) {
                return null;
            }
        }
    
        return Errors.create('object.missing', { peers: peers }, state, options);
    };
    
    
    internals.and = function (value, peers, parent, state, options) {
    
        var missing = [];
        var present = [];
        var count = peers.length;
        for (var i = 0; i < count; ++i) {
            var peer = peers[i];
            if (!parent.hasOwnProperty(peer) ||
                parent[peer] === undefined) {
    
                missing.push(peer);
            }
            else {
                present.push(peer);
            }
        }
    
        var aon = (missing.length === count || present.length === count);
        return !aon ? Errors.create('object.and', { present: present, missing: missing }, state, options) : null;
    };
    
    
    internals.nand = function (value, peers, parent, state, options) {
    
        var present = [];
        for (var i = 0, il = peers.length; i < il; ++i) {
            var peer = peers[i];
            if (parent.hasOwnProperty(peer) &&
                parent[peer] !== undefined) {
    
                present.push(peer);
            }
        }
    
        var values = Hoek.clone(peers);
        var main = values.splice(0, 1)[0];
        var allPresent = (present.length === peers.length);
        return allPresent ? Errors.create('object.nand', { main: main, peers: values }, state, options) : null;
    };
    
    
    internals.Object.prototype.describe = function (shallow) {
    
        var description = Any.prototype.describe.call(this);
    
        if (this._inner.children &&
            !shallow) {
    
            description.children = {};
            for (var i = 0, il = this._inner.children.length; i < il; ++i) {
                var child = this._inner.children[i];
                description.children[child.key] = child.schema.describe();
            }
        }
    
        if (this._inner.dependencies.length) {
            description.dependencies = Hoek.clone(this._inner.dependencies);
        }
    
        if (this._inner.patterns.length) {
            description.patterns = [];
    
            for (var p = 0, pl = this._inner.patterns.length; p < pl; ++p) {
                var pattern = this._inner.patterns[p];
                description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });
            }
        }
    
        return description;
    };
    
    
    internals.Object.prototype.assert = function (ref, schema, message) {
    
        ref = Cast.ref(ref);
        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');
        message = message || 'pass the assertion test';
    
        var cast = Cast.schema(schema);
        var key = ref.path[ref.path.length - 1];
        var path = ref.path.join('.');
    
        return this._test('assert', { cast: cast, ref: ref }, function (value, state, options) {
    
            var result = cast._validate(ref(value), null, options, value);
            if (!result.errors) {
                return null;
            }
    
            var localState = Hoek.merge({}, state);
            localState.key = key;
            localState.path = path;
            return Errors.create('object.assert', { ref: localState.path, message: message }, localState, options);
        });
    };
    
    
    internals.Object.prototype.type = function (constructor, name) {
    
        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');
        name = name || constructor.name;
    
        return this._test('type', name, function (value, state, options) {
    
            if (value instanceof constructor) {
                return null;
            }
    
            return Errors.create('object.type', { type: name }, state, options);
        });
    };
    
    
    module.exports = new internals.Object();
    
  provide("joi/lib/object", module.exports);
}(global));

// pakmanager:joi/lib/any
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Hoek = require('hoek');
    var Ref =  require('joi/lib/ref');
    var Errors =  require('joi/lib/errors');
    var Alternatives = null;                // Delay-loaded to prevent circular dependencies
    var Cast = null;
    
    
    // Declare internals
    
    var internals = {};
    
    
    internals.defaults = {
        abortEarly: true,
        convert: true,
        allowUnknown: false,
        skipFunctions: false,
        stripUnknown: false,
        language: {},
        presence: 'optional',
        raw: false,
        strip: false
    
        // context: null
    };
    
    
    internals.checkOptions = function (options) {
    
        var optionType = {
            abortEarly: 'boolean',
            convert: 'boolean',
            allowUnknown: 'boolean',
            skipFunctions: 'boolean',
            stripUnknown: 'boolean',
            language: 'object',
            presence: ['string', 'required', 'optional', 'forbidden', 'ignore'],
            raw: 'boolean',
            context: 'object',
            strip: 'boolean'
        };
    
        var keys = Object.keys(options);
        for (var k = 0, kl = keys.length; k < kl; ++k) {
            var key = keys[k];
            var opt = optionType[key];
            var type = opt;
            var values = null;
    
            if (Array.isArray(opt)) {
                type = opt[0];
                values = opt.slice(1);
            }
    
            Hoek.assert(type, 'unknown key ' + key);
            Hoek.assert(typeof options[key] === type, key + ' should be of type ' + type);
            if (values) {
                Hoek.assert(values.indexOf(options[key]) >= 0, key + ' should be one of ' + values.join(', '));
            }
        }
    };
    
    
    module.exports = internals.Any = function () {
    
        Cast = Cast ||  require('joi/lib/cast');
    
        this.isJoi = true;
        this._type = 'any';
        this._settings = null;
        this._valids = new internals.Set();
        this._invalids = new internals.Set();
        this._tests = [];
        this._refs = [];
        this._flags = { /*
            presence: 'optional',                   // optional, required, forbidden, ignore
            allowOnly: false,
            allowUnknown: undefined,
            default: undefined,
            forbidden: false,
            encoding: undefined,
            insensitive: false,
            trim: false,
            case: undefined,                        // upper, lower
            empty: undefined
        */ };
    
        this._description = null;
        this._unit = null;
        this._notes = [];
        this._tags = [];
        this._examples = [];
        this._meta = [];
    
        this._inner = {};                           // Hash of arrays of immutable objects
    };
    
    
    internals.Any.prototype.isImmutable = true;     // Prevents Hoek from deep cloning schema objects
    
    
    internals.Any.prototype.clone = function () {
    
        var obj = Object.create(Object.getPrototypeOf(this));
    
        obj.isJoi = true;
        obj._type = this._type;
        obj._settings = internals.concatSettings(this._settings);
        obj._valids = Hoek.clone(this._valids);
        obj._invalids = Hoek.clone(this._invalids);
        obj._tests = this._tests.slice();
        obj._refs = this._refs.slice();
        obj._flags = Hoek.clone(this._flags);
    
        obj._description = this._description;
        obj._unit = this._unit;
        obj._notes = this._notes.slice();
        obj._tags = this._tags.slice();
        obj._examples = this._examples.slice();
        obj._meta = this._meta.slice();
    
        obj._inner = {};
        var inners = Object.keys(this._inner);
        for (var i = 0, il = inners.length; i < il; ++i) {
            var key = inners[i];
            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;
        }
    
        return obj;
    };
    
    
    internals.Any.prototype.concat = function (schema) {
    
        Hoek.assert(schema && schema.isJoi, 'Invalid schema object');
        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);
    
        var obj = this.clone();
    
        if (this._type === 'any' && schema._type !== 'any') {
    
            // Reset values as if we were "this"
            var tmpObj = schema.clone();
            var keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',
                '_notes', '_tags', '_examples', '_meta', '_inner'];
    
            for (var j = 0, jl = keysToRestore.length; j < jl; ++j) {
                tmpObj[keysToRestore[j]] = obj[keysToRestore[j]];
            }
    
            obj = tmpObj;
        }
    
        obj._settings = obj._settings ? internals.concatSettings(obj._settings, schema._settings) : schema._settings;
        obj._valids.merge(schema._valids, schema._invalids);
        obj._invalids.merge(schema._invalids, schema._valids);
        obj._tests = obj._tests.concat(schema._tests);
        obj._refs = obj._refs.concat(schema._refs);
        Hoek.merge(obj._flags, schema._flags);
    
        obj._description = schema._description || obj._description;
        obj._unit = schema._unit || obj._unit;
        obj._notes = obj._notes.concat(schema._notes);
        obj._tags = obj._tags.concat(schema._tags);
        obj._examples = obj._examples.concat(schema._examples);
        obj._meta = obj._meta.concat(schema._meta);
    
        var inners = Object.keys(schema._inner);
        var isObject = obj._type === 'object';
        for (var i = 0, il = inners.length; i < il; ++i) {
            var key = inners[i];
            var source = schema._inner[key];
            if (source) {
                var target = obj._inner[key];
                if (target) {
                    if (isObject && key === 'children') {
                        var keys = {};
    
                        for (var k = 0, kl = target.length; k < kl; ++k) {
                            keys[target[k].key] = k;
                        }
    
                        for (k = 0, kl = source.length; k < kl; ++k) {
                            var sourceKey = source[k].key;
                            if (keys[sourceKey] >= 0) {
                                target[keys[sourceKey]] = {
                                    key: sourceKey,
                                    schema: target[keys[sourceKey]].schema.concat(source[k].schema)
                                };
                            }
                            else {
                                target.push(source[k]);
                            }
                        }
                    }
                    else {
                        obj._inner[key] = obj._inner[key].concat(source);
                    }
                }
                else {
                    obj._inner[key] = source.slice();
                }
            }
        }
    
        return obj;
    };
    
    
    internals.Any.prototype._test = function (name, arg, func) {
    
        Hoek.assert(!this._flags.allowOnly, 'Cannot define rules when valid values specified');
    
        var obj = this.clone();
        obj._tests.push({ func: func, name: name, arg: arg });
        return obj;
    };
    
    
    internals.Any.prototype.options = function (options) {
    
        Hoek.assert(!options.context, 'Cannot override context');
        internals.checkOptions(options);
    
        var obj = this.clone();
        obj._settings = internals.concatSettings(obj._settings, options);
        return obj;
    };
    
    
    internals.Any.prototype.strict = function (isStrict) {
    
        var obj = this.clone();
        obj._settings = obj._settings || {};
        obj._settings.convert = isStrict === undefined ? false : !isStrict;
        return obj;
    };
    
    
    internals.Any.prototype.raw = function (isRaw) {
    
        var obj = this.clone();
        obj._settings = obj._settings || {};
        obj._settings.raw = isRaw === undefined ? true : isRaw;
        return obj;
    };
    
    
    internals.Any.prototype._allow = function () {
    
        var values = Hoek.flatten(Array.prototype.slice.call(arguments));
        for (var i = 0, il = values.length; i < il; ++i) {
            var value = values[i];
            this._invalids.remove(value);
            this._valids.add(value, this._refs);
        }
    };
    
    
    internals.Any.prototype.allow = function () {
    
        var obj = this.clone();
        obj._allow.apply(obj, arguments);
        return obj;
    };
    
    
    internals.Any.prototype.valid = internals.Any.prototype.only = internals.Any.prototype.equal = function () {
    
        Hoek.assert(!this._tests.length, 'Cannot set valid values when rules specified');
    
        var obj = this.allow.apply(this, arguments);
        obj._flags.allowOnly = true;
        return obj;
    };
    
    
    internals.Any.prototype.invalid = internals.Any.prototype.disallow = internals.Any.prototype.not = function (value) {
    
        var obj = this.clone();
        var values = Hoek.flatten(Array.prototype.slice.call(arguments));
        for (var i = 0, il = values.length; i < il; ++i) {
            value = values[i];
            obj._valids.remove(value);
            obj._invalids.add(value, this._refs);
        }
    
        return obj;
    };
    
    
    internals.Any.prototype.required = internals.Any.prototype.exist = function () {
    
        var obj = this.clone();
        obj._flags.presence = 'required';
        return obj;
    };
    
    
    internals.Any.prototype.optional = function () {
    
        var obj = this.clone();
        obj._flags.presence = 'optional';
        return obj;
    };
    
    
    internals.Any.prototype.forbidden = function () {
    
        var obj = this.clone();
        obj._flags.presence = 'forbidden';
        return obj;
    };
    
    
    internals.Any.prototype.strip = function () {
    
        var obj = this.clone();
        obj._flags.strip = true;
        return obj;
    };
    
    
    internals.Any.prototype.applyFunctionToChildren = function (children, fn, args, root) {
    
        children = [].concat(children);
    
        if (children.length !== 1 || children[0] !== '') {
            root = root ? (root + '.') : '';
    
            var extraChildren = (children[0] === '' ? children.slice(1) : children).map(function (child) {
    
                return root + child;
            });
    
            throw new Error('unknown key(s) ' + extraChildren.join(', '));
        }
    
        return this[fn].apply(this, args);
    };
    
    
    internals.Any.prototype.default = function (value, description) {
    
        if (typeof value === 'function' &&
            !Ref.isRef(value)) {
    
            if (!value.description &&
                description) {
    
                value.description = description;
            }
    
            if (this._type !== 'func') {
                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');
            }
        }
    
        var obj = this.clone();
        obj._flags.default = value;
        Ref.push(obj._refs, value);
        return obj;
    };
    
    
    internals.Any.prototype.empty = function (schema) {
    
        var obj;
        if (schema === undefined) {
            obj = this.clone();
            obj._flags.empty = undefined;
        }
        else {
            schema = Cast.schema(schema);
    
            obj = this.clone();
            obj._flags.empty = schema;
        }
    
        return obj;
    };
    
    
    internals.Any.prototype.when = function (ref, options) {
    
        Hoek.assert(options && typeof options === 'object', 'Invalid options');
        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of "then" or "otherwise"');
    
        var then = options.then ? this.concat(Cast.schema(options.then)) : this;
        var otherwise = options.otherwise ? this.concat(Cast.schema(options.otherwise)) : this;
    
        Alternatives = Alternatives ||  require('joi/lib/alternatives');
        var obj = Alternatives.when(ref, { is: options.is, then: then, otherwise: otherwise });
        obj._flags.presence = 'ignore';
        return obj;
    };
    
    
    internals.Any.prototype.description = function (desc) {
    
        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');
    
        var obj = this.clone();
        obj._description = desc;
        return obj;
    };
    
    
    internals.Any.prototype.notes = function (notes) {
    
        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');
    
        var obj = this.clone();
        obj._notes = obj._notes.concat(notes);
        return obj;
    };
    
    
    internals.Any.prototype.tags = function (tags) {
    
        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');
    
        var obj = this.clone();
        obj._tags = obj._tags.concat(tags);
        return obj;
    };
    
    internals.Any.prototype.meta = function (meta) {
    
        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');
    
        var obj = this.clone();
        obj._meta = obj._meta.concat(meta);
        return obj;
    };
    
    
    internals.Any.prototype.example = function (value) {
    
        Hoek.assert(arguments.length, 'Missing example');
        var result = this._validate(value, null, internals.defaults);
        Hoek.assert(!result.errors, 'Bad example:', result.errors && Errors.process(result.errors, value));
    
        var obj = this.clone();
        obj._examples = obj._examples.concat(value);
        return obj;
    };
    
    
    internals.Any.prototype.unit = function (name) {
    
        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');
    
        var obj = this.clone();
        obj._unit = name;
        return obj;
    };
    
    
    internals._try = function (fn, arg) {
    
        var err;
        var result;
    
        try {
            result = fn.call(null, arg);
        } catch (e) {
            err = e;
        }
    
        return {
            value: result,
            error: err
        };
    };
    
    
    internals.Any.prototype._validate = function (value, state, options, reference) {
    
        var self = this;
        var originalValue = value;
    
        // Setup state and settings
    
        state = state || { key: '', path: '', parent: null, reference: reference };
    
        if (this._settings) {
            options = internals.concatSettings(options, this._settings);
        }
    
        var errors = [];
        var finish = function () {
    
            var finalValue;
    
            if (!self._flags.strip) {
                if (value !== undefined) {
                    finalValue = options.raw ? originalValue : value;
                }
                else if (Ref.isRef(self._flags.default)) {
                    finalValue = self._flags.default(state.parent, options);
                }
                else if (typeof self._flags.default === 'function' &&
                        !(self._type === 'func' && !self._flags.default.description)) {
    
                    var arg;
    
                    if (state.parent !== null &&
                        self._flags.default.length > 0) {
    
                        arg = Hoek.clone(state.parent);
                    }
    
                    var defaultValue = internals._try(self._flags.default, arg);
                    finalValue = defaultValue.value;
                    if (defaultValue.error) {
                        errors.push(Errors.create('any.default', defaultValue.error, state, options));
                    }
                }
                else {
                    finalValue = self._flags.default;
                }
            }
    
            return {
                value: finalValue,
                errors: errors.length ? errors : null
            };
        };
    
        // Check presence requirements
    
        var presence = this._flags.presence || options.presence;
        if (presence === 'optional') {
            if (value === undefined) {
                var isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;
                if (isDeepDefault && this._type === 'object') {
                    value = {};
                }
                else {
                    return finish();
                }
            }
        }
        else if (presence === 'required' &&
                value === undefined) {
    
            errors.push(Errors.create('any.required', null, state, options));
            return finish();
        }
        else if (presence === 'forbidden') {
            if (value === undefined) {
                return finish();
            }
    
            errors.push(Errors.create('any.unknown', null, state, options));
            return finish();
        }
    
        if (this._flags.empty && !this._flags.empty._validate(value, null, internals.defaults).errors) {
            value = undefined;
            return finish();
        }
    
        // Check allowed and denied values using the original value
    
        if (this._valids.has(value, state, options, this._flags.insensitive)) {
            return finish();
        }
    
        if (this._invalids.has(value, state, options, this._flags.insensitive)) {
            errors.push(Errors.create(value === '' ? 'any.empty' : 'any.invalid', null, state, options));
            if (options.abortEarly ||
                value === undefined) {          // No reason to keep validating missing value
    
                return finish();
            }
        }
    
        // Convert value and validate type
    
        if (this._base) {
            var base = this._base.call(this, value, state, options);
            if (base.errors) {
                value = base.value;
                errors = errors.concat(base.errors);
                return finish();                            // Base error always aborts early
            }
    
            if (base.value !== value) {
                value = base.value;
    
                // Check allowed and denied values using the converted value
    
                if (this._valids.has(value, state, options, this._flags.insensitive)) {
                    return finish();
                }
    
                if (this._invalids.has(value, state, options, this._flags.insensitive)) {
                    errors.push(Errors.create('any.invalid', null, state, options));
                    if (options.abortEarly) {
                        return finish();
                    }
                }
            }
        }
    
        // Required values did not match
    
        if (this._flags.allowOnly) {
            errors.push(Errors.create('any.allowOnly', { valids: this._valids.values({ stripUndefined: true }) }, state, options));
            if (options.abortEarly) {
                return finish();
            }
        }
    
        // Helper.validate tests
    
        for (var i = 0, il = this._tests.length; i < il; ++i) {
            var test = this._tests[i];
            var err = test.func.call(this, value, state, options);
            if (err) {
                errors.push(err);
                if (options.abortEarly) {
                    return finish();
                }
            }
        }
    
        return finish();
    };
    
    
    internals.Any.prototype._validateWithOptions = function (value, options, callback) {
    
        if (options) {
            internals.checkOptions(options);
        }
    
        var settings = internals.concatSettings(internals.defaults, options);
        var result = this._validate(value, null, settings);
        var errors = Errors.process(result.errors, value);
    
        if (callback) {
            return callback(errors, result.value);
        }
    
        return { error: errors, value: result.value };
    };
    
    
    internals.Any.prototype.validate = function (value, callback) {
    
        var result = this._validate(value, null, internals.defaults);
        var errors = Errors.process(result.errors, value);
    
        if (callback) {
            return callback(errors, result.value);
        }
    
        return { error: errors, value: result.value };
    };
    
    
    internals.Any.prototype.describe = function () {
    
        var description = {
            type: this._type
        };
    
        var flags = Object.keys(this._flags);
        if (flags.length) {
            if (this._flags.empty) {
                description.flags = {};
                for (var f = 0, fl = flags.length; f < fl; ++f) {
                    var flag = flags[f];
                    description.flags[flag] = flag === 'empty' ? this._flags[flag].describe() : this._flags[flag];
                }
            }
            else {
                description.flags = this._flags;
            }
        }
    
        if (this._description) {
            description.description = this._description;
        }
    
        if (this._notes.length) {
            description.notes = this._notes;
        }
    
        if (this._tags.length) {
            description.tags = this._tags;
        }
    
        if (this._meta.length) {
            description.meta = this._meta;
        }
    
        if (this._examples.length) {
            description.examples = this._examples;
        }
    
        if (this._unit) {
            description.unit = this._unit;
        }
    
        var valids = this._valids.values();
        if (valids.length) {
            description.valids = valids;
        }
    
        var invalids = this._invalids.values();
        if (invalids.length) {
            description.invalids = invalids;
        }
    
        description.rules = [];
    
        for (var i = 0, il = this._tests.length; i < il; ++i) {
            var validator = this._tests[i];
            var item = { name: validator.name };
            if (validator.arg !== void 0) {
                item.arg = validator.arg;
            }
            description.rules.push(item);
        }
    
        if (!description.rules.length) {
            delete description.rules;
        }
    
        var label = Hoek.reach(this._settings, 'language.label');
        if (label) {
            description.label = label;
        }
    
        return description;
    };
    
    internals.Any.prototype.label = function (name) {
    
        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');
    
        var obj = this.clone();
        var options = { language: { label: name } };
    
        // If language.label is set, it should override this label
        obj._settings = internals.concatSettings(options, obj._settings);
        return obj;
    };
    
    
    // Set
    
    internals.Set = function () {
    
        this._set = [];
    };
    
    
    internals.Set.prototype.add = function (value, refs) {
    
        Hoek.assert(value === null || value === undefined || value instanceof Date || Buffer.isBuffer(value) || Ref.isRef(value) || (typeof value !== 'function' && typeof value !== 'object'), 'Value cannot be an object or function');
    
        if (typeof value !== 'function' &&
            this.has(value, null, null, false)) {
    
            return;
        }
    
        Ref.push(refs, value);
        this._set.push(value);
    };
    
    
    internals.Set.prototype.merge = function (add, remove) {
    
        for (var i = 0, il = add._set.length; i < il; ++i) {
            this.add(add._set[i]);
        }
    
        for (i = 0, il = remove._set.length; i < il; ++i) {
            this.remove(remove._set[i]);
        }
    };
    
    
    internals.Set.prototype.remove = function (value) {
    
        this._set = this._set.filter(function (item) {
    
            return value !== item;
        });
    };
    
    
    internals.Set.prototype.has = function (value, state, options, insensitive) {
    
        for (var i = 0, il = this._set.length; i < il; ++i) {
            var items = this._set[i];
    
            if (Ref.isRef(items)) {
                items = items(state.reference || state.parent, options);
            }
    
            if (!Array.isArray(items)) {
                items = [items];
            }
    
            for (var j = 0, jl = items.length; j < jl; ++j) {
                var item = items[j];
                if (typeof value !== typeof item) {
                    continue;
                }
    
                if (value === item ||
                    (value instanceof Date && item instanceof Date && value.getTime() === item.getTime()) ||
                    (insensitive && typeof value === 'string' && value.toLowerCase() === item.toLowerCase()) ||
                    (Buffer.isBuffer(value) && Buffer.isBuffer(item) && value.length === item.length && value.toString('binary') === item.toString('binary'))) {
    
                    return true;
                }
            }
        }
    
        return false;
    };
    
    
    internals.Set.prototype.values = function (options) {
    
        if (options && options.stripUndefined) {
            var values = [];
    
            for (var i = 0, il = this._set.length; i < il; ++i) {
                var item = this._set[i];
                if (item !== undefined) {
                    values.push(item);
                }
            }
    
            return values;
        }
    
        return this._set.slice();
    };
    
    
    internals.concatSettings = function (target, source) {
    
        // Used to avoid cloning context
    
        if (!target &&
            !source) {
    
            return null;
        }
    
        var key, obj = {};
    
        if (target) {
            var tKeys = Object.keys(target);
            for (var i = 0, il = tKeys.length; i < il; ++i) {
                key = tKeys[i];
                obj[key] = target[key];
            }
        }
    
        if (source) {
            var sKeys = Object.keys(source);
            for (var j = 0, jl = sKeys.length; j < jl; ++j) {
                key = sKeys[j];
                if (key !== 'language' ||
                    !obj.hasOwnProperty(key)) {
    
                    obj[key] = source[key];
                }
                else {
                    obj[key] = Hoek.applyToDefaults(obj[key], source[key]);
                }
            }
        }
    
        return obj;
    };
    
  provide("joi/lib/any", module.exports);
}(global));

// pakmanager:joi/lib/string
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Net = require('net');
    var Hoek = require('hoek');
    var Isemail = require('isemail');
    var Any =  require('joi/lib/any');
    var Ref =  require('joi/lib/ref');
    var JoiDate =  require('joi/lib/date');
    var Errors =  require('joi/lib/errors');
    var Uri =  require('joi/lib/string/uri');
    var Ip =  require('joi/lib/string/ip');
    
    // Declare internals
    
    var internals = {
        uriRegex: Uri.createUriRegex(),
        ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional')
    };
    
    internals.String = function () {
    
        Any.call(this);
        this._type = 'string';
        this._invalids.add('');
    };
    
    Hoek.inherits(internals.String, Any);
    
    internals.compare = function (type, compare) {
    
        return function (limit, encoding) {
    
            var isRef = Ref.isRef(limit);
    
            Hoek.assert((Hoek.isInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');
            Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);
    
            return this._test(type, limit, function (value, state, options) {
    
                var compareTo;
                if (isRef) {
                    compareTo = limit(state.parent, options);
    
                    if (!Hoek.isInteger(compareTo)) {
                        return Errors.create('string.ref', { ref: limit.key }, state, options);
                    }
                }
                else {
                    compareTo = limit;
                }
    
                if (compare(value, compareTo, encoding)) {
                    return null;
                }
    
                return Errors.create('string.' + type, { limit: compareTo, value: value, encoding: encoding }, state, options);
            });
        };
    };
    
    internals.String.prototype._base = function (value, state, options) {
    
        if (typeof value === 'string' &&
            options.convert) {
    
            if (this._flags.case) {
                value = (this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase());
            }
    
            if (this._flags.trim) {
                value = value.trim();
            }
    
            if (this._inner.replacements) {
    
                for (var r = 0, rl = this._inner.replacements.length; r < rl; ++r) {
                    var replacement = this._inner.replacements[r];
                    value = value.replace(replacement.pattern, replacement.replacement);
                }
            }
        }
    
        return {
            value: value,
            errors: (typeof value === 'string') ? null : Errors.create('string.base', { value: value }, state, options)
        };
    };
    
    
    internals.String.prototype.insensitive = function () {
    
        var obj = this.clone();
        obj._flags.insensitive = true;
        return obj;
    };
    
    
    internals.String.prototype.min = internals.compare('min', function (value, limit, encoding) {
    
        var length = encoding ? Buffer.byteLength(value, encoding) : value.length;
        return length >= limit;
    });
    
    
    internals.String.prototype.max = internals.compare('max', function (value, limit, encoding) {
    
        var length = encoding ? Buffer.byteLength(value, encoding) : value.length;
        return length <= limit;
    });
    
    
    internals.String.prototype.creditCard = function () {
    
        return this._test('creditCard', undefined, function (value, state, options) {
    
            var i = value.length;
            var sum = 0;
            var mul = 1;
            var char;
    
            while (i--) {
                char = value.charAt(i) * mul;
                sum += char - (char > 9) * 9;
                mul ^= 3;
            }
    
            var check = (sum % 10 === 0) && (sum > 0);
            return check ? null : Errors.create('string.creditCard', { value: value }, state, options);
        });
    };
    
    internals.String.prototype.length = internals.compare('length', function (value, limit, encoding) {
    
        var length = encoding ? Buffer.byteLength(value, encoding) : value.length;
        return length === limit;
    });
    
    
    internals.String.prototype.regex = function (pattern, name) {
    
        Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');
    
        pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags
    
        return this._test('regex', pattern, function (value, state, options) {
    
            if (pattern.test(value)) {
                return null;
            }
    
            return Errors.create((name ? 'string.regex.name' : 'string.regex.base'), { name: name, pattern: pattern, value: value }, state, options);
        });
    };
    
    
    internals.String.prototype.alphanum = function () {
    
        return this._test('alphanum', undefined, function (value, state, options) {
    
            if (/^[a-zA-Z0-9]+$/.test(value)) {
                return null;
            }
    
            return Errors.create('string.alphanum', { value: value }, state, options);
        });
    };
    
    
    internals.String.prototype.token = function () {
    
        return this._test('token', undefined, function (value, state, options) {
    
            if (/^\w+$/.test(value)) {
                return null;
            }
    
            return Errors.create('string.token', { value: value }, state, options);
        });
    };
    
    
    internals.String.prototype.email = function (isEmailOptions) {
    
        if (isEmailOptions) {
            Hoek.assert(typeof isEmailOptions === 'object', 'email options must be an object');
            Hoek.assert(typeof isEmailOptions.checkDNS === 'undefined', 'checkDNS option is not supported');
            Hoek.assert(typeof isEmailOptions.tldWhitelist === 'undefined' ||
                typeof isEmailOptions.tldWhitelist === 'object', 'tldWhitelist must be an array or object');
            Hoek.assert(typeof isEmailOptions.minDomainAtoms === 'undefined' ||
                Hoek.isInteger(isEmailOptions.minDomainAtoms) && isEmailOptions.minDomainAtoms > 0,
                'minDomainAtoms must be a positive integer');
            Hoek.assert(typeof isEmailOptions.errorLevel === 'undefined' || typeof isEmailOptions.errorLevel === 'boolean' ||
                (Hoek.isInteger(isEmailOptions.errorLevel) && isEmailOptions.errorLevel >= 0),
                'errorLevel must be a non-negative integer or boolean');
        }
    
        return this._test('email', isEmailOptions, function (value, state, options) {
    
            try {
                var result = Isemail(value, isEmailOptions);
                if (result === true || result === 0) {
                    return null;
                }
            }
            catch (e) {}
    
            return Errors.create('string.email', { value: value }, state, options);
        });
    };
    
    
    internals.String.prototype.ip = function (ipOptions) {
    
        var regex = internals.ipRegex;
        ipOptions = ipOptions || {};
        Hoek.assert(typeof ipOptions === 'object', 'options must be an object');
    
        if (ipOptions.cidr) {
            Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');
            ipOptions.cidr = ipOptions.cidr.toLowerCase();
    
            Hoek.assert(ipOptions.cidr in Ip.cidrs, 'cidr must be one of ' + Object.keys(Ip.cidrs).join(', '));
    
            // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is "optional" since that is the default
            if (!ipOptions.version && ipOptions.cidr !== 'optional') {
                regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);
            }
        }
        else {
    
            // Set our default cidr strategy
            ipOptions.cidr = 'optional';
        }
    
        if (ipOptions.version) {
            if (!Array.isArray(ipOptions.version)) {
                ipOptions.version = [ipOptions.version];
            }
    
            Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');
    
            var versions = [];
            for (var i = 0, il = ipOptions.version.length; i < il; ++i) {
                var version = ipOptions.version[i];
                Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');
                version = version.toLowerCase();
                Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));
                versions.push(version);
            }
    
            // Make sure we have a set of versions
            versions = Hoek.unique(versions);
    
            regex = Ip.createIpRegex(versions, ipOptions.cidr);
        }
    
        return this._test('ip', ipOptions, function (value, state, options) {
    
            if (regex.test(value)) {
                return null;
            }
    
            if (versions) {
                return Errors.create('string.ipVersion', { value: value, cidr: ipOptions.cidr, version: versions }, state, options);
            }
    
            return Errors.create('string.ip', { value: value, cidr: ipOptions.cidr }, state, options);
        });
    };
    
    
    internals.String.prototype.uri = function (uriOptions) {
    
        var customScheme = '',
            regex = internals.uriRegex;
    
        if (uriOptions) {
            Hoek.assert(typeof uriOptions === 'object', 'options must be an object');
    
            if (uriOptions.scheme) {
                Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');
    
                if (!Array.isArray(uriOptions.scheme)) {
                    uriOptions.scheme = [uriOptions.scheme];
                }
    
                Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified');
    
                // Flatten the array into a string to be used to match the schemes.
                for (var i = 0, il = uriOptions.scheme.length; i < il; ++i) {
                    var scheme = uriOptions.scheme[i];
                    Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String');
    
                    // Add OR separators if a value already exists
                    customScheme += customScheme ? '|' : '';
    
                    // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.
                    if (scheme instanceof RegExp) {
                        customScheme += scheme.source;
                    }
                    else {
                        Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');
                        customScheme += Hoek.escapeRegex(scheme);
                    }
                }
            }
        }
    
        if (customScheme) {
            regex = Uri.createUriRegex(customScheme);
        }
    
        return this._test('uri', uriOptions, function (value, state, options) {
    
            if (regex.test(value)) {
                return null;
            }
    
            if (customScheme) {
                return Errors.create('string.uriCustomScheme', { scheme: customScheme, value: value }, state, options);
            }
    
            return Errors.create('string.uri', { value: value }, state, options);
        });
    };
    
    
    internals.String.prototype.isoDate = function () {
    
        return this._test('isoDate', undefined, function (value, state, options) {
    
            if (JoiDate._isIsoDate(value)) {
                return null;
            }
    
            return Errors.create('string.isoDate', { value: value }, state, options);
        });
    };
    
    
    internals.String.prototype.guid = function () {
    
        var regex = /^[A-F0-9]{8}(?:-?[A-F0-9]{4}){3}-?[A-F0-9]{12}$/i;
        var regex2 = /^\{[A-F0-9]{8}(?:-?[A-F0-9]{4}){3}-?[A-F0-9]{12}\}$/i;
    
        return this._test('guid', undefined, function (value, state, options) {
    
            if (regex.test(value) || regex2.test(value)) {
                return null;
            }
    
            return Errors.create('string.guid', { value: value }, state, options);
        });
    };
    
    
    internals.String.prototype.hex = function () {
    
        var regex = /^[a-f0-9]+$/i;
    
        return this._test('hex', regex, function (value, state, options) {
    
            if (regex.test(value)) {
                return null;
            }
    
            return Errors.create('string.hex', { value: value }, state, options);
        });
    };
    
    
    internals.String.prototype.hostname = function () {
    
        var regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$/;
    
        return this._test('hostname', undefined, function (value, state, options) {
    
            if ((value.length <= 255 && regex.test(value)) ||
                Net.isIPv6(value)) {
    
                return null;
            }
    
            return Errors.create('string.hostname', { value: value }, state, options);
        });
    };
    
    
    internals.String.prototype.lowercase = function () {
    
        var obj = this._test('lowercase', undefined, function (value, state, options) {
    
            if (options.convert ||
                value === value.toLocaleLowerCase()) {
    
                return null;
            }
    
            return Errors.create('string.lowercase', { value: value }, state, options);
        });
    
        obj._flags.case = 'lower';
        return obj;
    };
    
    
    internals.String.prototype.uppercase = function (options) {
    
        var obj = this._test('uppercase', undefined, function (value, state, options) {
    
            if (options.convert ||
                value === value.toLocaleUpperCase()) {
    
                return null;
            }
    
            return Errors.create('string.uppercase', { value: value }, state, options);
        });
    
        obj._flags.case = 'upper';
        return obj;
    };
    
    
    internals.String.prototype.trim = function () {
    
        var obj = this._test('trim', undefined, function (value, state, options) {
    
            if (options.convert ||
                value === value.trim()) {
    
                return null;
            }
    
            return Errors.create('string.trim', { value: value }, state, options);
        });
    
        obj._flags.trim = true;
        return obj;
    };
    
    
    internals.String.prototype.replace = function (pattern, replacement) {
    
        if (typeof pattern === 'string') {
            pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');
        }
    
        Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');
        Hoek.assert(typeof replacement === 'string', 'replacement must be a String');
    
        // This can not be considere a test like trim, we can't "reject"
        // anything from this rule, so just clone the current object
        var obj = this.clone();
    
        if (!obj._inner.replacements) {
            obj._inner.replacements = [];
        }
    
        obj._inner.replacements.push({
            pattern: pattern,
            replacement: replacement
        });
    
        return obj;
    };
    
    module.exports = new internals.String();
    
  provide("joi/lib/string", module.exports);
}(global));

// pakmanager:joi/lib/cast
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Hoek = require('hoek');
    var Ref =  require('joi/lib/ref');
    
    // Type modules are delay-loaded to prevent circular dependencies
    
    
    // Declare internals
    
    var internals = {
        any: null,
        date:  require('joi/lib/date'),
        string:  require('joi/lib/string'),
        number:  require('joi/lib/number'),
        boolean:  require('joi/lib/boolean'),
        alt: null,
        object: null
    };
    
    
    exports.schema = function (config) {
    
        internals.any = internals.any || new ( require('joi/lib/any'))();
        internals.alt = internals.alt ||  require('joi/lib/alternatives');
        internals.object = internals.object ||  require('joi/lib/object');
    
        if (config &&
            typeof config === 'object') {
    
            if (config.isJoi) {
                return config;
            }
    
            if (Array.isArray(config)) {
                return internals.alt.try(config);
            }
    
            if (config instanceof RegExp) {
                return internals.string.regex(config);
            }
    
            if (config instanceof Date) {
                return internals.date.valid(config);
            }
    
            return internals.object.keys(config);
        }
    
        if (typeof config === 'string') {
            return internals.string.valid(config);
        }
    
        if (typeof config === 'number') {
            return internals.number.valid(config);
        }
    
        if (typeof config === 'boolean') {
            return internals.boolean.valid(config);
        }
    
        if (Ref.isRef(config)) {
            return internals.any.valid(config);
        }
    
        Hoek.assert(config === null, 'Invalid schema content:', config);
    
        return internals.any.valid(null);
    };
    
    
    exports.ref = function (id) {
    
        return Ref.isRef(id) ? id : Ref.create(id);
    };
    
  provide("joi/lib/cast", module.exports);
}(global));

// pakmanager:joi/lib/array
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Any =  require('joi/lib/any');
    var Cast =  require('joi/lib/cast');
    var Errors =  require('joi/lib/errors');
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    
    internals.fastSplice = function (arr, i) {
    
        var il = arr.length;
        var pos = i;
    
        while (pos < il) {
            arr[pos++] = arr[pos];
        }
    
        --arr.length;
    };
    
    
    internals.Array = function () {
    
        Any.call(this);
        this._type = 'array';
        this._inner.items = [];
        this._inner.inclusions = [];
        this._inner.exclusions = [];
        this._inner.requireds = [];
        this._flags.sparse = false;
    };
    
    Hoek.inherits(internals.Array, Any);
    
    
    internals.Array.prototype._base = function (value, state, options) {
    
        var result = {
            value: value
        };
    
        if (typeof value === 'string' &&
            options.convert) {
    
            try {
                var converted = JSON.parse(value);
                if (Array.isArray(converted)) {
                    result.value = converted;
                }
            }
            catch (e) { }
        }
    
        var isArray = Array.isArray(result.value);
        var wasArray = isArray;
        if (options.convert && this._flags.single && !isArray) {
            result.value = [result.value];
            isArray = true;
        }
    
        if (!isArray) {
            result.errors = Errors.create('array.base', null, state, options);
            return result;
        }
    
        if (this._inner.inclusions.length ||
            this._inner.exclusions.length ||
            !this._flags.sparse) {
    
            // Clone the array so that we don't modify the original
            if (wasArray) {
                result.value = result.value.slice(0);
            }
    
            result.errors = internals.checkItems.call(this, result.value, wasArray, state, options);
    
            if (result.errors && wasArray && options.convert && this._flags.single) {
    
                // Attempt a 2nd pass by putting the array inside one.
                var previousErrors = result.errors;
    
                result.value = [result.value];
                result.errors = internals.checkItems.call(this, result.value, wasArray, state, options);
    
                if (result.errors) {
    
                    // Restore previous errors and value since this didn't validate either.
                    result.errors = previousErrors;
                    result.value = result.value[0];
                }
            }
        }
    
        return result;
    };
    
    
    internals.checkItems = function (items, wasArray, state, options) {
    
        var errors = [];
        var errored;
    
        var requireds = this._inner.requireds.slice();
        var inclusions = this._inner.inclusions.concat(requireds);
    
        for (var v = 0, vl = items.length; v < vl; ++v) {
            errored = false;
            var item = items[v];
            var isValid = false;
            var localState = { key: v, path: (state.path ? state.path + '.' : '') + v, parent: items, reference: state.reference };
            var res;
    
            // Sparse
    
            if (!this._flags.sparse && item === undefined) {
                errors.push(Errors.create('array.sparse', null, { key: state.key, path: localState.path }, options));
    
                if (options.abortEarly) {
                    return errors;
                }
    
                continue;
            }
    
            // Exclusions
    
            for (var i = 0, il = this._inner.exclusions.length; i < il; ++i) {
                res = this._inner.exclusions[i]._validate(item, localState, {});                // Not passing options to use defaults
                if (!res.errors) {
                    errors.push(Errors.create(wasArray ? 'array.excludes' : 'array.excludesSingle', { pos: v, value: item }, { key: state.key, path: localState.path }, options));
                    errored = true;
    
                    if (options.abortEarly) {
                        return errors;
                    }
    
                    break;
                }
            }
    
            if (errored) {
                continue;
            }
    
            // Requireds
    
            var requiredChecks = [];
            for (i = 0, il = requireds.length; i < il; ++i) {
                res = requiredChecks[i] = requireds[i]._validate(item, localState, options);
                if (!res.errors) {
                    items[v] = res.value;
                    isValid = true;
                    internals.fastSplice(requireds, i);
                    --i;
                    --il;
                    break;
                }
            }
    
            if (isValid) {
                continue;
            }
    
            // Inclusions
    
            for (i = 0, il = inclusions.length; i < il; ++i) {
                var inclusion = inclusions[i];
    
                // Avoid re-running requireds that already didn't match in the previous loop
                var previousCheck = requireds.indexOf(inclusion);
                if (previousCheck !== -1) {
                    res = requiredChecks[previousCheck];
                }
                else {
                    res = inclusion._validate(item, localState, options);
    
                    if (!res.errors) {
                        if (inclusion._flags.strip) {
                            internals.fastSplice(items, v);
                            --v;
                            --vl;
                        }
                        else {
                            items[v] = res.value;
                        }
                        isValid = true;
                        break;
                    }
                }
    
                // Return the actual error if only one inclusion defined
                if (il === 1) {
                    if (options.stripUnknown) {
                        internals.fastSplice(items, v);
                        --v;
                        --vl;
                        isValid = true;
                        break;
                    }
    
                    errors.push(Errors.create(wasArray ? 'array.includesOne' : 'array.includesOneSingle', { pos: v, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));
                    errored = true;
    
                    if (options.abortEarly) {
                        return errors;
                    }
    
                    break;
                }
            }
    
            if (errored) {
                continue;
            }
    
            if (this._inner.inclusions.length && !isValid) {
                if (options.stripUnknown) {
                    internals.fastSplice(items, v);
                    --v;
                    --vl;
                    continue;
                }
    
                errors.push(Errors.create(wasArray ? 'array.includes' : 'array.includesSingle', { pos: v, value: item }, { key: state.key, path: localState.path }, options));
    
                if (options.abortEarly) {
                    return errors;
                }
            }
        }
    
        if (requireds.length) {
            internals.fillMissedErrors(errors, requireds, state, options);
        }
    
        return errors.length ? errors : null;
    };
    
    
    internals.fillMissedErrors = function (errors, requireds, state, options) {
    
        var knownMisses = [];
        var unknownMisses = 0;
        for (var i = 0, il = requireds.length; i < il; ++i) {
            var label = Hoek.reach(requireds[i], '_settings.language.label');
            if (label) {
                knownMisses.push(label);
            }
            else {
                ++unknownMisses;
            }
        }
    
        if (knownMisses.length) {
            if (unknownMisses) {
                errors.push(Errors.create('array.includesRequiredBoth', { knownMisses: knownMisses, unknownMisses: unknownMisses }, { key: state.key, path: state.patk }, options));
            }
            else {
                errors.push(Errors.create('array.includesRequiredKnowns', { knownMisses: knownMisses }, { key: state.key, path: state.path }, options));
            }
        }
        else {
            errors.push(Errors.create('array.includesRequiredUnknowns', { unknownMisses: unknownMisses }, { key: state.key, path: state.path }, options));
        }
    };
    
    
    internals.Array.prototype.describe = function () {
    
        var description = Any.prototype.describe.call(this);
    
        if (this._inner.items.length) {
            description.items = [];
    
            for (var i = 0, il = this._inner.items.length; i < il; ++i) {
                description.items.push(this._inner.items[i].describe());
            }
        }
    
        return description;
    };
    
    
    internals.Array.prototype.items = function () {
    
        var obj = this.clone();
    
        Hoek.flatten(Array.prototype.slice.call(arguments)).forEach(function (type) {
    
            type = Cast.schema(type);
            obj._inner.items.push(type);
    
            if (type._flags.presence === 'required') {
                obj._inner.requireds.push(type);
            }
            else if (type._flags.presence === 'forbidden') {
                obj._inner.exclusions.push(type.optional());
            }
            else {
                obj._inner.inclusions.push(type);
            }
        });
    
        return obj;
    };
    
    
    internals.Array.prototype.min = function (limit) {
    
        Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');
    
        return this._test('min', limit, function (value, state, options) {
    
            if (value.length >= limit) {
                return null;
            }
    
            return Errors.create('array.min', { limit: limit, value: value }, state, options);
        });
    };
    
    
    internals.Array.prototype.max = function (limit) {
    
        Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');
    
        return this._test('max', limit, function (value, state, options) {
    
            if (value.length <= limit) {
                return null;
            }
    
            return Errors.create('array.max', { limit: limit, value: value }, state, options);
        });
    };
    
    
    internals.Array.prototype.length = function (limit) {
    
        Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');
    
        return this._test('length', limit, function (value, state, options) {
    
            if (value.length === limit) {
                return null;
            }
    
            return Errors.create('array.length', { limit: limit, value: value }, state, options);
        });
    };
    
    
    internals.Array.prototype.unique = function () {
    
        return this._test('unique', undefined, function (value, state, options) {
    
            var found = {
                string: {},
                number: {},
                undefined: {},
                boolean: {},
                object: [],
                function: []
            };
    
            for (var i = 0, il = value.length; i < il; ++i) {
                var item = value[i];
                var type = typeof item;
                var records = found[type];
    
                // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.
                // I still want to keep the test for future js versions with new types (eg. Symbol).
                if (/* $lab:coverage:off$ */ records /* $lab:coverage:on$ */) {
                    if (Array.isArray(records)) {
                        for (var r = 0, rl = records.length; r < rl; ++r) {
                            if (Hoek.deepEqual(records[r], item)) {
                                return Errors.create('array.unique', { pos: i, value: item }, state, options);
                            }
                        }
    
                        records.push(item);
                    }
                    else {
                        if (records[item]) {
                            return Errors.create('array.unique', { pos: i, value: item }, state, options);
                        }
    
                        records[item] = true;
                    }
                }
            }
        });
    };
    
    
    internals.Array.prototype.sparse = function (enabled) {
    
        var obj = this.clone();
        obj._flags.sparse = enabled === undefined ? true : !!enabled;
        return obj;
    };
    
    
    internals.Array.prototype.single = function (enabled) {
    
        var obj = this.clone();
        obj._flags.single = enabled === undefined ? true : !!enabled;
        return obj;
    };
    
    
    module.exports = new internals.Array();
    
  provide("joi/lib/array", module.exports);
}(global));

// pakmanager:joi/lib/binary
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Any =  require('joi/lib/any');
    var Errors =  require('joi/lib/errors');
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    
    internals.Binary = function () {
    
        Any.call(this);
        this._type = 'binary';
    };
    
    Hoek.inherits(internals.Binary, Any);
    
    
    internals.Binary.prototype._base = function (value, state, options) {
    
        var result = {
            value: value
        };
    
        if (typeof value === 'string' &&
            options.convert) {
    
            try {
                var converted = new Buffer(value, this._flags.encoding);
                result.value = converted;
            }
            catch (e) { }
        }
    
        result.errors = Buffer.isBuffer(result.value) ? null : Errors.create('binary.base', null, state, options);
        return result;
    };
    
    
    internals.Binary.prototype.encoding = function (encoding) {
    
        Hoek.assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);
    
        var obj = this.clone();
        obj._flags.encoding = encoding;
        return obj;
    };
    
    
    internals.Binary.prototype.min = function (limit) {
    
        Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');
    
        return this._test('min', limit, function (value, state, options) {
    
            if (value.length >= limit) {
                return null;
            }
    
            return Errors.create('binary.min', { limit: limit, value: value }, state, options);
        });
    };
    
    
    internals.Binary.prototype.max = function (limit) {
    
        Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');
    
        return this._test('max', limit, function (value, state, options) {
    
            if (value.length <= limit) {
                return null;
            }
    
            return Errors.create('binary.max', { limit: limit, value: value }, state, options);
        });
    };
    
    
    internals.Binary.prototype.length = function (limit) {
    
        Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');
    
        return this._test('length', limit, function (value, state, options) {
    
            if (value.length === limit) {
                return null;
            }
    
            return Errors.create('binary.length', { limit: limit, value: value }, state, options);
        });
    };
    
    
    module.exports = new internals.Binary();
    
  provide("joi/lib/binary", module.exports);
}(global));

// pakmanager:joi/lib/function
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Any =  require('joi/lib/any');
    var Errors =  require('joi/lib/errors');
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    
    internals.Function = function () {
    
        Any.call(this);
        this._type = 'func';
    };
    
    Hoek.inherits(internals.Function, Any);
    
    
    internals.Function.prototype._base = function (value, state, options) {
    
        return {
            value: value,
            errors: (typeof value === 'function') ? null : Errors.create('function.base', null, state, options)
        };
    };
    
    
    module.exports = new internals.Function();
    
  provide("joi/lib/function", module.exports);
}(global));

// pakmanager:joi
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Hoek = require('hoek');
    var Any =  require('joi/lib/any');
    var Cast =  require('joi/lib/cast');
    var Ref =  require('joi/lib/ref');
    
    
    // Declare internals
    
    var internals = {
        alternatives:  require('joi/lib/alternatives'),
        array:  require('joi/lib/array'),
        boolean:  require('joi/lib/boolean'),
        binary:  require('joi/lib/binary'),
        date:  require('joi/lib/date'),
        func:  require('joi/lib/function'),
        number:  require('joi/lib/number'),
        object:  require('joi/lib/object'),
        string:  require('joi/lib/string')
    };
    
    
    internals.root = function () {
    
        var any = new Any();
    
        var root = any.clone();
        root.any = function () {
    
            return any;
        };
    
        root.alternatives = root.alt = function () {
    
            return arguments.length ? internals.alternatives.try.apply(internals.alternatives, arguments) : internals.alternatives;
        };
    
        root.array = function () {
    
            return internals.array;
        };
    
        root.boolean = root.bool = function () {
    
            return internals.boolean;
        };
    
        root.binary = function () {
    
            return internals.binary;
        };
    
        root.date = function () {
    
            return internals.date;
        };
    
        root.func = function () {
    
            return internals.func;
        };
    
        root.number = function () {
    
            return internals.number;
        };
    
        root.object = function () {
    
            return arguments.length ? internals.object.keys.apply(internals.object, arguments) : internals.object;
        };
    
        root.string = function () {
    
            return internals.string;
        };
    
        root.ref = function () {
    
            return Ref.create.apply(null, arguments);
        };
    
        root.isRef = function (ref) {
    
            return Ref.isRef(ref);
        };
    
        root.validate = function (value /*, [schema], [options], callback */) {
    
            var last = arguments[arguments.length - 1];
            var callback = typeof last === 'function' ? last : null;
    
            var count = arguments.length - (callback ? 1 : 0);
            if (count === 1) {
                return any.validate(value, callback);
            }
    
            var options = count === 3 ? arguments[2] : {};
            var schema = Cast.schema(arguments[1]);
    
            return schema._validateWithOptions(value, options, callback);
        };
    
        root.describe = function () {
    
            var schema = arguments.length ? Cast.schema(arguments[0]) : any;
            return schema.describe();
        };
    
        root.compile = function (schema) {
    
            return Cast.schema(schema);
        };
    
        root.assert = function (value, schema, message) {
    
            var error = root.validate(value, schema).error;
            if (error) {
                if (!message) {
                    throw new Error(error.annotate());
                }
    
                if (!(message instanceof Error)) {
                    throw new Error(message + ' ' + error.annotate());
                }
    
                throw message;
            }
        };
    
        return root;
    };
    
    
    module.exports = internals.root();
    
  provide("joi", module.exports);
}(global));

// pakmanager:wreck/lib/payload
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Load modules
    
    var Hoek = require('hoek');
    var Stream = require('stream');
    
    
    // Declare internals
    
    var internals = {};
    
    
    module.exports = internals.Payload = function (payload, encoding) {
    
        Stream.Readable.call(this);
    
        var data = [].concat(payload || '');
        var size = 0;
        for (var i = 0, il = data.length; i < il; ++i) {
            var chunk = data[i];
            size += chunk.length;
            data[i] = Buffer.isBuffer(chunk) ? chunk : new Buffer(chunk);
        }
    
        this._data = Buffer.concat(data, size);
        this._position = 0;
        this._encoding = encoding || 'utf8';
    };
    
    Hoek.inherits(internals.Payload, Stream.Readable);
    
    
    internals.Payload.prototype._read = function (size) {
    
        var chunk = this._data.slice(this._position, this._position + size);
        this.push(chunk, this._encoding);
        this._position += chunk.length;
    
        if (this._position >= this._data.length) {
            this.push(null);
        }
    };
    
  provide("wreck/lib/payload", module.exports);
}(global));

// pakmanager:wreck/lib/recorder
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Load modules
    
    var Boom = require('boom');
    var Hoek = require('hoek');
    var Stream = require('stream');
    
    
    // Declare internals
    
    var internals = {};
    
    
    module.exports = internals.Recorder = function (options) {
    
        Stream.Writable.call(this);
    
        this.settings = options;                // No need to clone since called internally with new object
        this.buffers = [];
        this.length = 0;
    };
    
    Hoek.inherits(internals.Recorder, Stream.Writable);
    
    
    internals.Recorder.prototype._write = function (chunk, encoding, next) {
    
        if (this.settings.maxBytes &&
            this.length + chunk.length > this.settings.maxBytes) {
    
            return this.emit('error', Boom.badRequest('Payload content length greater than maximum allowed: ' + this.settings.maxBytes));
        }
    
        this.length += chunk.length;
        this.buffers.push(chunk);
        next();
    };
    
    
    internals.Recorder.prototype.collect = function () {
    
        var buffer = (this.buffers.length === 0 ? new Buffer(0) : (this.buffers.length === 1 ? this.buffers[0] : Buffer.concat(this.buffers, this.length)));
        return buffer;
    };
    
  provide("wreck/lib/recorder", module.exports);
}(global));

// pakmanager:wreck/lib/tap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Load modules
    
    var Hoek = require('hoek');
    var Stream = require('stream');
    var Payload =  require('wreck/lib/payload');
    
    
    // Declare internals
    
    var internals = {};
    
    
    module.exports = internals.Tap = function () {
    
        Stream.Transform.call(this);
        this.buffers = [];
    };
    
    Hoek.inherits(internals.Tap, Stream.Transform);
    
    
    internals.Tap.prototype._transform = function (chunk, encoding, next) {
    
        this.buffers.push(chunk);
        next(null, chunk);
    };
    
    
    internals.Tap.prototype.collect = function () {
    
        return new Payload(this.buffers);
    };
    
  provide("wreck/lib/tap", module.exports);
}(global));

// pakmanager:wreck
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Load modules
    
    var Events = require('events');
    var Url = require('url');
    var Http = require('http');
    var Https = require('https');
    var Stream = require('stream');
    var Hoek = require('hoek');
    var Boom = require('boom');
    var Payload =  require('wreck/lib/payload');
    var Recorder =  require('wreck/lib/recorder');
    var Tap =  require('wreck/lib/tap');
    
    
    // Declare internals
    
    var internals = {
        jsonRegex: /^application\/[a-z.+-]*json$/
    };
    
    
    // new instance is exported as module.exports
    
    internals.Client = function (defaults) {
    
        Events.EventEmitter.call(this);
    
        this.agents = {
            https: new Https.Agent({ maxSockets: Infinity }),
            http: new Http.Agent({ maxSockets: Infinity }),
            httpsAllowUnauthorized: new Https.Agent({ maxSockets: Infinity, rejectUnauthorized: false })
        };
    
        this._defaults = defaults || {};
    };
    
    Hoek.inherits(internals.Client, Events.EventEmitter);
    
    
    internals.Client.prototype.defaults = function (options) {
    
        options = Hoek.applyToDefaultsWithShallow(options, this._defaults, ['agent', 'payload', 'downstreamRes']);
        return new internals.Client(options);
    };
    
    
    internals.resolveUrl = function (baseUrl, path) {
    
        if (!path) {
            return baseUrl;
        }
    
        var parsedBase = Url.parse(baseUrl);
        var parsedPath = Url.parse(path);
    
        parsedBase.pathname += parsedPath.pathname;
        parsedBase.pathname = parsedBase.pathname.replace(/[/]{2,}/g, '/');
        parsedBase.search = parsedPath.search;      // Always use the querystring from the path argument
    
        return Url.format(parsedBase);
    };
    
    
    internals.Client.prototype.request = function (method, url, options, callback, _trace) {
    
        var self = this;
    
        options = Hoek.applyToDefaultsWithShallow(options || {}, this._defaults, ['agent', 'payload', 'downstreamRes']);
    
        Hoek.assert(options.payload === null || options.payload === undefined || typeof options.payload === 'string' ||
            options.payload instanceof Stream || Buffer.isBuffer(options.payload),
            'options.payload must be a string, a Buffer, or a Stream');
    
        Hoek.assert((options.agent === undefined || options.agent === null) || (typeof options.rejectUnauthorized !== 'boolean'),
            'options.agent cannot be set to an Agent at the same time as options.rejectUnauthorized is set');
    
        if (options.baseUrl) {
            url = internals.resolveUrl(options.baseUrl, url);
            delete options.baseUrl;
        }
    
        var uri = Url.parse(url);
        var timeoutId;
        uri.method = method.toUpperCase();
        uri.headers = options.headers;
    
        var payloadSupported = (uri.method !== 'GET' && uri.method !== 'HEAD' && options.payload !== null && options.payload !== undefined);
        if (payloadSupported &&
            (typeof options.payload === 'string' || Buffer.isBuffer(options.payload))) {
    
            uri.headers = Hoek.clone(uri.headers) || {};
            uri.headers['Content-Length'] = Buffer.isBuffer(options.payload) ? options.payload.length : Buffer.byteLength(options.payload);
        }
    
        var redirects = (options.hasOwnProperty('redirects') ? options.redirects : false);      // Needed to allow 0 as valid value when passed recursively
    
        _trace = (_trace || []);
        _trace.push({ method: uri.method, url: url });
    
        var client = (uri.protocol === 'https:' ? Https : Http);
    
        if (options.rejectUnauthorized !== undefined && uri.protocol === 'https:') {
            uri.agent = options.rejectUnauthorized ? this.agents.https : this.agents.httpsAllowUnauthorized;
        }
        else if (options.agent || options.agent === false) {
            uri.agent = options.agent;
        }
        else {
            uri.agent = uri.protocol === 'https:' ? this.agents.https : this.agents.http;
        }
    
        if (options.secureProtocol !== undefined) {
            uri.secureProtocol = options.secureProtocol;
        }
    
        var start = Date.now();
        var req = client.request(uri);
    
        var shadow = null;                                                                      // A copy of the streamed request payload when redirects are enabled
    
        // Register handlers
    
        var finish = function (err, res) {
    
            if (!callback || err) {
                req.abort();
            }
    
            req.removeListener('response', onResponse);
            req.removeListener('error', onError);
            req.on('error', Hoek.ignore);
            clearTimeout(timeoutId);
            self.emit('response', err, req, res, start, uri);
    
            if (callback) {
                return callback(err, res);
            }
        };
    
        finish = Hoek.once(finish);
    
        var onError = function (err) {
    
            err.trace = _trace;
            return finish(Boom.badGateway('Client request error', err));
        };
    
        req.once('error', onError);
    
        var onResponse = function (res) {
    
            // Pass-through response
    
            if (redirects === false ||
                [301, 302, 307, 308].indexOf(res.statusCode) === -1) {
    
                return finish(null, res);
            }
    
            // Redirection
    
            var redirectMethod = (res.statusCode === 301 || res.statusCode === 302 ? 'GET' : uri.method);
            var location = res.headers.location;
    
            res.destroy();
    
            if (redirects === 0) {
                return finish(Boom.badGateway('Maximum redirections reached', _trace));
            }
    
            if (!location) {
                return finish(Boom.badGateway('Received redirection without location', _trace));
            }
    
            if (!/^https?:/i.test(location)) {
                location = Url.resolve(uri.href, location);
            }
    
            var redirectOptions = Hoek.cloneWithShallow(options, ['agent', 'payload', 'downstreamRes']);
    
            redirectOptions.payload = shadow || options.payload;         // shadow must be ready at this point if set
            redirectOptions.redirects = --redirects;
    
            return self.request(redirectMethod, location, redirectOptions, finish, _trace);
        };
    
        req.once('response', onResponse);
    
        if (options.timeout) {
            timeoutId = setTimeout(function () {
    
                return finish(Boom.gatewayTimeout('Client request timeout'));
            }, options.timeout);
            delete options.timeout;
        }
    
        // Write payload
    
        if (payloadSupported) {
            if (options.payload instanceof Stream) {
                var stream = options.payload;
    
                if (redirects) {
                    var collector = new Tap();
                    collector.once('finish', function () {
    
                        shadow = collector.collect();
                    });
    
                    stream = options.payload.pipe(collector);
                }
    
                stream.pipe(req);
                return;
            }
    
            req.write(options.payload);
        }
    
        // Custom abort method to detect early aborts
    
        var _abort = req.abort;
        var aborted = false;
        req.abort = function () {
    
            if (!aborted && !req.res && !req.socket) {
                process.nextTick(function () {
    
                    // Fake an ECONNRESET error
    
                    var error = new Error('socket hang up');
                    error.code = 'ECONNRESET';
                    finish(error);
                });
            }
    
            aborted = true;
            return _abort.call(req);
        };
    
        // Finalize request
    
        req.end();
    
        return req;
    };
    
    
    // read()
    
    internals.Client.prototype.read = function (res, options, callback) {
    
        options = Hoek.applyToDefaultsWithShallow(options || {}, this._defaults, ['agent', 'payload', 'downstreamRes']);
    
        // Set stream timeout
    
        var clientTimeout = options.timeout;
        var clientTimeoutId = null;
    
        if (clientTimeout &&
            clientTimeout > 0) {
    
            clientTimeoutId = setTimeout(function () {
    
                finish(Boom.clientTimeout());
            }, clientTimeout);
        }
    
        // Finish once
    
        var finish = function (err, buffer) {
    
            clearTimeout(clientTimeoutId);
            reader.removeListener('error', onReaderError);
            reader.removeListener('finish', onReaderFinish);
            res.removeListener('error', onResError);
            res.removeListener('close', onResClose);
            res.on('error', Hoek.ignore);
    
            if (err ||
                !options.json) {
    
                return callback(err, buffer);
            }
    
            // Parse JSON
    
            var result;
            if (buffer.length === 0) {
                return callback(null, null);
            }
    
            if (options.json === 'force') {
                result = internals.tryParseBuffer(buffer);
                return callback(result.err, result.json);
            }
    
            // mode is "smart" or true
    
            var contentType = (res.headers && res.headers['content-type']) || '';
            var mime = contentType.split(';')[0].trim().toLowerCase();
    
            if (!internals.jsonRegex.test(mime)) {
                return callback(null, buffer);
            }
    
            result = internals.tryParseBuffer(buffer);
            return callback(result.err, result.json);
        };
    
        finish = Hoek.once(finish);
    
        // Hander errors
    
        var onResError = function (err) {
    
            return finish(Boom.internal('Payload stream error', err));
        };
    
        var onResClose = function () {
    
            return finish(Boom.internal('Payload stream closed prematurely'));
        };
    
        res.once('error', onResError);
        res.once('close', onResClose);
    
        // Read payload
    
        var reader = new Recorder({ maxBytes: options.maxBytes });
    
        var onReaderError = function (err) {
    
            if (res.destroy) {                          // GZip stream has no destroy() method
                res.destroy();
            }
    
            return finish(err);
        };
    
        reader.once('error', onReaderError);
    
        var onReaderFinish = function () {
    
            return finish(null, reader.collect());
        };
    
        reader.once('finish', onReaderFinish);
    
        res.pipe(reader);
    };
    
    
    // toReadableStream()
    
    internals.Client.prototype.toReadableStream = function (payload, encoding) {
    
        return new Payload(payload, encoding);
    };
    
    
    // parseCacheControl()
    
    internals.Client.prototype.parseCacheControl = function (field) {
    
        /*
            Cache-Control   = 1#cache-directive
            cache-directive = token [ "=" ( token / quoted-string ) ]
            token           = [^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+
            quoted-string   = "(?:[^"\\]|\\.)*"
        */
    
        //                             1: directive                                        =   2: token                                              3: quoted-string
        var regex = /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g;
    
        var header = {};
        var error = field.replace(regex, function ($0, $1, $2, $3) {
    
            var value = $2 || $3;
            header[$1] = value ? value.toLowerCase() : true;
            return '';
        });
    
        if (header['max-age']) {
            try {
                var maxAge = parseInt(header['max-age'], 10);
                if (isNaN(maxAge)) {
                    return null;
                }
    
                header['max-age'] = maxAge;
            }
            catch (err) { }
        }
    
        return (error ? null : header);
    };
    
    
    // Shortcuts
    
    internals.Client.prototype.get = function (uri, options, callback) {
    
        return this._shortcutWrap('GET', uri, options, callback);
    };
    
    
    internals.Client.prototype.post = function (uri, options, callback) {
    
        return this._shortcutWrap('POST', uri, options, callback);
    };
    
    
    internals.Client.prototype.put = function (uri, options, callback) {
    
        return this._shortcutWrap('PUT', uri, options, callback);
    };
    
    
    internals.Client.prototype.delete = function (uri, options, callback) {
    
        return this._shortcutWrap('DELETE', uri, options, callback);
    };
    
    
    // Wrapper so that shortcut can be optimized with required params
    
    internals.Client.prototype._shortcutWrap = function (method, uri /* [options], callback */) {
    
        var options = (typeof arguments[2] === 'function' ? {} : arguments[2]);
        var callback = (typeof arguments[2] === 'function' ? arguments[2] : arguments[3]);
    
        return this._shortcut(method, uri, options, callback);
    };
    
    
    internals.Client.prototype._shortcut = function (method, uri, options, callback) {
    
        var self = this;
    
        return this.request(method, uri, options, function (err, res) {
    
            if (err) {
                return callback(err);
            }
    
            self.read(res, options, function (err, payload) {
    
                return callback(err, res, payload);
            });
        });
    };
    
    
    internals.tryParseBuffer = function (buffer) {
    
        var result = {
            json: null,
            err: null
        };
        try {
            var json = JSON.parse(buffer.toString());
            result.json = json;
        }
        catch (err) {
            result.err = err;
        }
        return result;
    };
    
    
    module.exports = new internals.Client();
    
  provide("wreck", module.exports);
}(global));

// pakmanager:ammo
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Stream = require('stream');
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.header = function (header, length) {
    
        // Parse header
    
        var parts = header.split('=');
        if (parts.length !== 2 ||
            parts[0] !== 'bytes') {
    
            return null;
        }
    
        var lastPos = length - 1;
    
        var result = [];
        var ranges = parts[1].match(/\d*\-\d*/g);
        for (var i = 0, il = ranges.length; i < il; ++i) {
            var range = ranges[i];
            if (range.length === 1) {               // '-'
                return null;
            }
    
            var set = {};
            range = range.split('-');
            if (range[0]) {
                set.from = parseInt(range[0], 10);
            }
    
            if (range[1]) {
                set.to = parseInt(range[1], 10);
                if (set.from !== undefined) {      // Can be 0
                    // From-To
                    if (set.to > lastPos) {
                        set.to = lastPos;
                    }
                }
                else {
                    // -To
                    set.from = length - set.to;
                    set.to = lastPos;
                }
            }
            else {
                // From-
                set.to = lastPos;
            }
    
            if (set.from > set.to) {
                return null;
            }
    
            result.push(set);
        }
    
        if (result.length === 1) {
            return result;
        }
    
        // Sort and consolidate ranges
    
        result.sort(function (a, b) {
    
            return a.from - b.from;
        });
    
        var consolidated = [];
        for (i = result.length - 1; i > 0; --i) {
            var current = result[i];
            var before = result[i - 1];
            if (current.from <= before.to + 1) {
                before.to = current.to;
            }
            else {
                consolidated.unshift(current);
            }
        }
    
        consolidated.unshift(result[0]);
    
        return consolidated;
    };
    
    
    exports.Stream = internals.Stream = function (range) {
    
        Stream.Transform.call(this);
    
        this._range = range;
        this._next = 0;
    };
    
    Hoek.inherits(internals.Stream, Stream.Transform);
    
    
    internals.Stream.prototype._transform = function (chunk, encoding, done) {
    
        var pos = this._next;
        this._next += chunk.length;
    
        if (this._next <= this._range.from ||       // Before range
            pos > this._range.to) {                 // After range
    
            return done();
        }
    
        var from = Math.max(0, this._range.from - pos);
        var to = Math.min(chunk.length, this._range.to - pos + 1);
    
        this.push(chunk.slice(from, to));
        return done();
    };
    
  provide("ammo", module.exports);
}(global));

// pakmanager:items/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.serial = function (array, method, callback) {
    
        var il = array.length;
        if (!il) {
            callback();
        }
        else {
            var i = 0;
            var iterate = function () {
    
                var done = function (err) {
    
                    if (err) {
                        callback(err);
                    }
                    else {
                        i += 1;
                        if (i < il) {
                            iterate();
                        }
                        else {
                            callback();
                        }
                    }
                };
    
                method(array[i], done);
            };
    
            iterate();
        }
    };
    
    
    exports.parallel = function (array, method, callback) {
    
        var il = array.length;
        if (!il) {
            callback();
        }
        else {
            var count = 0;
            var errored = false;
    
            var done = function (err) {
    
                if (!errored) {
                    if (err) {
                        errored = true;
                        callback(err);
                    }
                    else {
                        count += 1;
                        if (count === array.length) {
                            callback();
                        }
                    }
                }
            };
    
            for (var i = 0; i < il; ++i) {
                method(array[i], done);
            }
        }
    };
    
    
    exports.parallel.execute = function (fnObj, callback) {
    
        var result = {};
        if (!fnObj) {
            return callback(null, result);
        }
    
        var keys = Object.keys(fnObj);
        var count = 0;
        var il = keys.length;
        var errored = false;
    
        if (!il) {
            return callback(null, result);
        }
    
        var done = function (key) {
    
            return function (err, val) {
    
                if (!errored) {
                    if (err) {
                        errored = true;
                        callback(err);
                    }
                    else {
                        result[key] = val;
                        if (++count === il) {
                            callback(null, result);
                        }
                    }
                }
            };
        };
    
        for (var i = 0; i < il; ++i) {
            if (!errored) {
                var key = keys[i];
                fnObj[key](done(key));
            }
        }
    };
    
  provide("items/lib", module.exports);
}(global));

// pakmanager:items
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('items/lib');
  provide("items", module.exports);
}(global));

// pakmanager:lru-cache
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  ;(function () { // closure for web browsers
    
    if (typeof module === 'object' && module.exports) {
      module.exports = LRUCache
    } else {
      // just set the global for non-node platforms.
      this.LRUCache = LRUCache
    }
    
    function hOP (obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key)
    }
    
    function naiveLength () { return 1 }
    
    function LRUCache (options) {
      if (!(this instanceof LRUCache))
        return new LRUCache(options)
    
      if (typeof options === 'number')
        options = { max: options }
    
      if (!options)
        options = {}
    
      this._max = options.max
      // Kind of weird to have a default max of Infinity, but oh well.
      if (!this._max || !(typeof this._max === "number") || this._max <= 0 )
        this._max = Infinity
    
      this._lengthCalculator = options.length || naiveLength
      if (typeof this._lengthCalculator !== "function")
        this._lengthCalculator = naiveLength
    
      this._allowStale = options.stale || false
      this._maxAge = options.maxAge || null
      this._dispose = options.dispose
      this.reset()
    }
    
    // resize the cache when the max changes.
    Object.defineProperty(LRUCache.prototype, "max",
      { set : function (mL) {
          if (!mL || !(typeof mL === "number") || mL <= 0 ) mL = Infinity
          this._max = mL
          if (this._length > this._max) trim(this)
        }
      , get : function () { return this._max }
      , enumerable : true
      })
    
    // resize the cache when the lengthCalculator changes.
    Object.defineProperty(LRUCache.prototype, "lengthCalculator",
      { set : function (lC) {
          if (typeof lC !== "function") {
            this._lengthCalculator = naiveLength
            this._length = this._itemCount
            for (var key in this._cache) {
              this._cache[key].length = 1
            }
          } else {
            this._lengthCalculator = lC
            this._length = 0
            for (var key in this._cache) {
              this._cache[key].length = this._lengthCalculator(this._cache[key].value)
              this._length += this._cache[key].length
            }
          }
    
          if (this._length > this._max) trim(this)
        }
      , get : function () { return this._lengthCalculator }
      , enumerable : true
      })
    
    Object.defineProperty(LRUCache.prototype, "length",
      { get : function () { return this._length }
      , enumerable : true
      })
    
    
    Object.defineProperty(LRUCache.prototype, "itemCount",
      { get : function () { return this._itemCount }
      , enumerable : true
      })
    
    LRUCache.prototype.forEach = function (fn, thisp) {
      thisp = thisp || this
      var i = 0
      var itemCount = this._itemCount
    
      for (var k = this._mru - 1; k >= 0 && i < itemCount; k--) if (this._lruList[k]) {
        i++
        var hit = this._lruList[k]
        if (isStale(this, hit)) {
          del(this, hit)
          if (!this._allowStale) hit = undefined
        }
        if (hit) {
          fn.call(thisp, hit.value, hit.key, this)
        }
      }
    }
    
    LRUCache.prototype.keys = function () {
      var keys = new Array(this._itemCount)
      var i = 0
      for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
        var hit = this._lruList[k]
        keys[i++] = hit.key
      }
      return keys
    }
    
    LRUCache.prototype.values = function () {
      var values = new Array(this._itemCount)
      var i = 0
      for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
        var hit = this._lruList[k]
        values[i++] = hit.value
      }
      return values
    }
    
    LRUCache.prototype.reset = function () {
      if (this._dispose && this._cache) {
        for (var k in this._cache) {
          this._dispose(k, this._cache[k].value)
        }
      }
    
      this._cache = Object.create(null) // hash of items by key
      this._lruList = Object.create(null) // list of items in order of use recency
      this._mru = 0 // most recently used
      this._lru = 0 // least recently used
      this._length = 0 // number of items in the list
      this._itemCount = 0
    }
    
    // Provided for debugging/dev purposes only. No promises whatsoever that
    // this API stays stable.
    LRUCache.prototype.dump = function () {
      return this._cache
    }
    
    LRUCache.prototype.dumpLru = function () {
      return this._lruList
    }
    
    LRUCache.prototype.set = function (key, value, maxAge) {
      maxAge = maxAge || this._maxAge
      var now = maxAge ? Date.now() : 0
    
      if (hOP(this._cache, key)) {
        // dispose of the old one before overwriting
        if (this._dispose)
          this._dispose(key, this._cache[key].value)
    
        this._cache[key].now = now
        this._cache[key].maxAge = maxAge
        this._cache[key].value = value
        this.get(key)
        return true
      }
    
      var len = this._lengthCalculator(value)
      var hit = new Entry(key, value, this._mru++, len, now, maxAge)
    
      // oversized objects fall out of cache automatically.
      if (hit.length > this._max) {
        if (this._dispose) this._dispose(key, value)
        return false
      }
    
      this._length += hit.length
      this._lruList[hit.lu] = this._cache[key] = hit
      this._itemCount ++
    
      if (this._length > this._max)
        trim(this)
    
      return true
    }
    
    LRUCache.prototype.has = function (key) {
      if (!hOP(this._cache, key)) return false
      var hit = this._cache[key]
      if (isStale(this, hit)) {
        return false
      }
      return true
    }
    
    LRUCache.prototype.get = function (key) {
      return get(this, key, true)
    }
    
    LRUCache.prototype.peek = function (key) {
      return get(this, key, false)
    }
    
    LRUCache.prototype.pop = function () {
      var hit = this._lruList[this._lru]
      del(this, hit)
      return hit || null
    }
    
    LRUCache.prototype.del = function (key) {
      del(this, this._cache[key])
    }
    
    function get (self, key, doUse) {
      var hit = self._cache[key]
      if (hit) {
        if (isStale(self, hit)) {
          del(self, hit)
          if (!self._allowStale) hit = undefined
        } else {
          if (doUse) use(self, hit)
        }
        if (hit) hit = hit.value
      }
      return hit
    }
    
    function isStale(self, hit) {
      if (!hit || (!hit.maxAge && !self._maxAge)) return false
      var stale = false;
      var diff = Date.now() - hit.now
      if (hit.maxAge) {
        stale = diff > hit.maxAge
      } else {
        stale = self._maxAge && (diff > self._maxAge)
      }
      return stale;
    }
    
    function use (self, hit) {
      shiftLU(self, hit)
      hit.lu = self._mru ++
      self._lruList[hit.lu] = hit
    }
    
    function trim (self) {
      while (self._lru < self._mru && self._length > self._max)
        del(self, self._lruList[self._lru])
    }
    
    function shiftLU (self, hit) {
      delete self._lruList[ hit.lu ]
      while (self._lru < self._mru && !self._lruList[self._lru]) self._lru ++
    }
    
    function del (self, hit) {
      if (hit) {
        if (self._dispose) self._dispose(hit.key, hit.value)
        self._length -= hit.length
        self._itemCount --
        delete self._cache[ hit.key ]
        shiftLU(self, hit)
      }
    }
    
    // classy, since V8 prefers predictable objects.
    function Entry (key, value, lu, length, now, maxAge) {
      this.key = key
      this.value = value
      this.lu = lu
      this.length = length
      this.now = now
      if (maxAge) this.maxAge = maxAge
    }
    
    })()
    
  provide("lru-cache", module.exports);
}(global));

// pakmanager:mime-db
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * mime-db
     * Copyright(c) 2014 Jonathan Ong
     * MIT Licensed
     */
    
    /**
     * Module exports.
     */
    
    module.exports = require('./db.json')
    
  provide("mime-db", module.exports);
}(global));

// pakmanager:iron/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Crypto = require('crypto');
    var Boom = require('boom');
    var Hoek = require('hoek');
    var Cryptiles = require('cryptiles');
    
    
    // Declare internals
    
    var internals = {};
    
    
    // Common defaults
    
    exports.defaults = {
        encryption: {
            saltBits: 256,
            algorithm: 'aes-256-cbc',
            iterations: 1
        },
    
        integrity: {
            saltBits: 256,
            algorithm: 'sha256',
            iterations: 1
        },
    
        ttl: 0,                                             // Milliseconds, 0 means forever
        timestampSkewSec: 60,                               // Seconds of permitted clock skew for incoming expirations
        localtimeOffsetMsec: 0                              // Local clock time offset express in a number of milliseconds (positive or negative)
    };
    
    
    // Algorithm configuration
    
    exports.algorithms = {
    
        'aes-128-ctr': { keyBits: 128, ivBits: 128 },       // Requires node 0.10.x
        'aes-256-cbc': { keyBits: 256, ivBits: 128 },
        'sha256': { keyBits: 256 }
    };
    
    
    // MAC normalization format version
    
    exports.macFormatVersion = '2';                         // Prevent comparison of mac values generated with different normalized string formats
    exports.macPrefix = 'Fe26.' + exports.macFormatVersion;
    
    
    // Generate a unique encryption key
    
    /*
        var options =  {
            saltBits: 256,                                  // Ignored if salt is set
            salt: '4d8nr9q384nr9q384nr93q8nruq9348run',
            algorithm: 'aes-128-ctr',
            iterations: 10000,
            iv: 'sdfsdfsdfsdfscdrgercgesrcgsercg'           // Optional
        };
    */
    
    exports.generateKey = function (password, options, callback) {
    
        var callbackTick = Hoek.nextTick(callback);
    
        if (!password) {
            return callbackTick(Boom.internal('Empty password'));
        }
    
        if (!options ||
            typeof options !== 'object') {
    
            return callbackTick(Boom.internal('Bad options'));
        }
    
        var algorithm = exports.algorithms[options.algorithm];
        if (!algorithm) {
            return callbackTick(Boom.internal('Unknown algorithm: ' + options.algorithm));
        }
    
        var generate = function () {
    
            if (Buffer.isBuffer(password)) {
                if (password.length < algorithm.keyBits / 8) {
                    return callbackTick(Boom.internal('Key buffer (password) too small'));
                }
    
                var result = {
                    key: password,
                    salt: ''
                };
    
                return generateIv(result);
            }
    
            if (options.salt) {
                return generateKey(options.salt);
            }
    
            if (options.saltBits) {
                return generateSalt();
            }
    
            return callbackTick(Boom.internal('Missing salt or saltBits options'));
        };
    
        var generateSalt = function () {
    
            var randomSalt = Cryptiles.randomBits(options.saltBits);
            if (randomSalt instanceof Error) {
                return callbackTick(randomSalt);
            }
    
            var salt = randomSalt.toString('hex');
            return generateKey(salt);
        };
    
        var generateKey = function (salt) {
    
            Crypto.pbkdf2(password, salt, options.iterations, algorithm.keyBits / 8, function (err, derivedKey) {
    
                if (err) {
                    return callback(err);
                }
    
                var result = {
                    key: derivedKey,
                    salt: salt
                };
    
                return generateIv(result);
            });
        };
    
        var generateIv = function (result) {
    
            if (algorithm.ivBits &&
                !options.iv) {
    
                var randomIv = Cryptiles.randomBits(algorithm.ivBits);
                if (randomIv instanceof Error) {
                    return callbackTick(randomIv);
                }
    
                result.iv = randomIv;
                return callbackTick(null, result);
            }
            else {
                if (options.iv) {
                    result.iv = options.iv;
                }
    
                return callbackTick(null, result);
            }
        };
    
        generate();
    };
    
    
    // Encrypt data
    // options: see exports.generateKey()
    
    exports.encrypt = function (password, options, data, callback) {
    
        exports.generateKey(password, options, function (err, key) {
    
            if (err) {
                return callback(err);
            }
    
            var cipher = Crypto.createCipheriv(options.algorithm, key.key, key.iv);
            var enc = Buffer.concat([cipher.update(data, 'utf8'), cipher.final()]);
    
            callback(null, enc, key);
        });
    };
    
    
    // Decrypt data
    // options: see exports.generateKey()
    
    exports.decrypt = function (password, options, data, callback) {
    
        exports.generateKey(password, options, function (err, key) {
    
            if (err) {
                return callback(err);
            }
    
            var decipher = Crypto.createDecipheriv(options.algorithm, key.key, key.iv);
            var dec = decipher.update(data, null, 'utf8');
            dec += decipher.final('utf8');
    
            callback(null, dec);
        });
    };
    
    
    // HMAC using a password
    // options: see exports.generateKey()
    
    exports.hmacWithPassword = function (password, options, data, callback) {
    
        exports.generateKey(password, options, function (err, key) {
    
            if (err) {
                return callback(err);
            }
    
            var hmac = Crypto.createHmac(options.algorithm, key.key).update(data);
            var digest = hmac.digest('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
    
            var result = {
                digest: digest,
                salt: key.salt
            };
    
            return callback(null, result);
        });
    };
    
    
    // Normalizes a password parameter into a { id, encryption, integrity } object
    // password: string, buffer or object with { id, secret } or { id, encryption, integrity }
    
    internals.normalizePassword = function (password) {
    
        var obj = {};
    
        if (password instanceof Object &&
            !Buffer.isBuffer(password)) {
    
            obj.id = password.id;
            obj.encryption = password.secret || password.encryption;
            obj.integrity = password.secret || password.integrity;
        }
        else {
            obj.encryption = password;
            obj.integrity = password;
        }
    
        return obj;
    };
    
    
    // Encrypt and HMAC an object
    // password: string, buffer or object with { id, secret } or { id, encryption, integrity }
    // options: see exports.defaults
    
    exports.seal = function (object, password, options, callback) {
    
        var now = Date.now() + (options.localtimeOffsetMsec || 0);                 // Measure now before any other processing
    
        var callbackTick = Hoek.nextTick(callback);
    
        // Serialize object
    
        var objectString = JSON.stringify(object);
    
        // Obtain password
    
        var passwordId = '';
        password = internals.normalizePassword(password);
        if (password.id) {
            if (!/^\w+$/.test(password.id)) {
                return callbackTick(Boom.internal('Invalid password id'));
            }
    
            passwordId = password.id;
        }
    
        // Encrypt object string
    
        exports.encrypt(password.encryption, options.encryption, objectString, function (err, encrypted, key) {
    
            if (err) {
                return callback(err);
            }
    
            // Base64url the encrypted value
    
            var encryptedB64 = Hoek.base64urlEncode(encrypted);
            var iv = Hoek.base64urlEncode(key.iv);
            var expiration = (options.ttl ? now + options.ttl : '');
            var macBaseString = exports.macPrefix + '*' + passwordId + '*' + key.salt + '*' + iv + '*' + encryptedB64 + '*' + expiration;
    
            // Mac the combined values
    
            var hmac = exports.hmacWithPassword(password.integrity, options.integrity, macBaseString, function (err, mac) {
    
                if (err) {
                    return callback(err);
                }
    
                // Put it all together
    
                // prefix*[password-id]*encryption-salt*encryption-iv*encrypted*[expiration]*hmac-salt*hmac
                // Allowed URI query name/value characters: *-. \d \w
    
                var sealed = macBaseString + '*' + mac.salt + '*' + mac.digest;
                return callback(null, sealed);
            });
        });
    };
    
    
    // Decrypt and validate sealed string
    // password: string, buffer or object with { id: secret } or { id: { encryption, integrity } }
    // options: see exports.defaults
    
    exports.unseal = function (sealed, password, options, callback) {
    
        var now = Date.now() + (options.localtimeOffsetMsec || 0);                 // Measure now before any other processing
    
        var callbackTick = Hoek.nextTick(callback);
    
        // Break string into components
    
        var parts = sealed.split('*');
        if (parts.length !== 8) {
            return callbackTick(Boom.internal('Incorrect number of sealed components'));
        }
    
        var macPrefix = parts[0];
        var passwordId = parts[1];
        var encryptionSalt = parts[2];
        var encryptionIv = parts[3];
        var encryptedB64 = parts[4];
        var expiration = parts[5];
        var hmacSalt = parts[6];
        var hmac = parts[7];
        var macBaseString = macPrefix + '*' + passwordId + '*' + encryptionSalt + '*' + encryptionIv + '*' + encryptedB64 + '*' + expiration;
    
        // Check prefix
    
        if (macPrefix !== exports.macPrefix) {
            return callbackTick(Boom.internal('Wrong mac prefix'));
        }
    
        // Check expiration
    
        if (expiration) {
            if (!expiration.match(/^\d+$/)) {
                return callbackTick(Boom.internal('Invalid expiration'));
            }
    
            var exp = parseInt(expiration, 10);
            if (exp <= (now - (options.timestampSkewSec * 1000))) {
                return callbackTick(Boom.internal('Expired seal'));
            }
        }
    
        // Obtain password
    
        if (password instanceof Object &&
            !(Buffer.isBuffer(password))) {
    
            password = password[passwordId || 'default'];
            if (!password) {
                return callbackTick(Boom.internal('Cannot find password: ' + passwordId));
            }
        }
        password = internals.normalizePassword(password);
    
        // Check hmac
    
        var macOptions = Hoek.clone(options.integrity);
        macOptions.salt = hmacSalt;
        exports.hmacWithPassword(password.integrity, macOptions, macBaseString, function (err, mac) {
    
            if (err) {
                return callback(err);
            }
    
            if (!Cryptiles.fixedTimeComparison(mac.digest, hmac)) {
                return callback(Boom.internal('Bad hmac value'));
            }
    
            // Decrypt
    
            var encrypted = Hoek.base64urlDecode(encryptedB64, 'buffer');
            if (encrypted instanceof Error) {
                return callback(encrypted);
            }
    
            var decryptOptions = Hoek.clone(options.encryption);
            decryptOptions.salt = encryptionSalt;
    
            decryptOptions.iv = Hoek.base64urlDecode(encryptionIv, 'buffer');
            if (decryptOptions.iv instanceof Error) {
                return callback(decryptOptions.iv);
            }
    
            exports.decrypt(password.encryption, decryptOptions, encrypted, function (err, decrypted) {
    
                // Parse JSON
    
                var object = null;
                try {
                    object = JSON.parse(decrypted);
                }
                catch (err) {
                    return callback(Boom.internal('Failed parsing sealed object JSON: ' + err.message));
                }
    
                return callback(null, object);
            });
        });
    };
    
    
  provide("iron/lib", module.exports);
}(global));

// pakmanager:iron
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('iron/lib');
  provide("iron", module.exports);
}(global));

// pakmanager:qs/lib/utils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    
    // Declare internals
    
    var internals = {};
    internals.hexTable = new Array(256);
    for (var h = 0; h < 256; ++h) {
        internals.hexTable[h] = '%' + ((h < 16 ? '0' : '') + h.toString(16)).toUpperCase();
    }
    
    
    exports.arrayToObject = function (source, options) {
    
        var obj = options.plainObjects ? Object.create(null) : {};
        for (var i = 0, il = source.length; i < il; ++i) {
            if (typeof source[i] !== 'undefined') {
    
                obj[i] = source[i];
            }
        }
    
        return obj;
    };
    
    
    exports.merge = function (target, source, options) {
    
        if (!source) {
            return target;
        }
    
        if (typeof source !== 'object') {
            if (Array.isArray(target)) {
                target.push(source);
            }
            else if (typeof target === 'object') {
                target[source] = true;
            }
            else {
                target = [target, source];
            }
    
            return target;
        }
    
        if (typeof target !== 'object') {
            target = [target].concat(source);
            return target;
        }
    
        if (Array.isArray(target) &&
            !Array.isArray(source)) {
    
            target = exports.arrayToObject(target, options);
        }
    
        var keys = Object.keys(source);
        for (var k = 0, kl = keys.length; k < kl; ++k) {
            var key = keys[k];
            var value = source[key];
    
            if (!Object.prototype.hasOwnProperty.call(target, key)) {
                target[key] = value;
            }
            else {
                target[key] = exports.merge(target[key], value, options);
            }
        }
    
        return target;
    };
    
    
    exports.decode = function (str) {
    
        try {
            return decodeURIComponent(str.replace(/\+/g, ' '));
        } catch (e) {
            return str;
        }
    };
    
    exports.encode = function (str) {
    
        // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
        // It has been adapted here for stricter adherence to RFC 3986
        if (str.length === 0) {
            return str;
        }
    
        if (typeof str !== 'string') {
            str = '' + str;
        }
    
        var out = '';
        for (var i = 0, il = str.length; i < il; ++i) {
            var c = str.charCodeAt(i);
    
            if (c === 0x2D || // -
                c === 0x2E || // .
                c === 0x5F || // _
                c === 0x7E || // ~
                (c >= 0x30 && c <= 0x39) || // 0-9
                (c >= 0x41 && c <= 0x5A) || // a-z
                (c >= 0x61 && c <= 0x7A)) { // A-Z
    
                out += str[i];
                continue;
            }
    
            if (c < 0x80) {
                out += internals.hexTable[c];
                continue;
            }
    
            if (c < 0x800) {
                out += internals.hexTable[0xC0 | (c >> 6)] + internals.hexTable[0x80 | (c & 0x3F)];
                continue;
            }
    
            if (c < 0xD800 || c >= 0xE000) {
                out += internals.hexTable[0xE0 | (c >> 12)] + internals.hexTable[0x80 | ((c >> 6) & 0x3F)] + internals.hexTable[0x80 | (c & 0x3F)];
                continue;
            }
    
            ++i;
            c = 0x10000 + (((c & 0x3FF) << 10) | (str.charCodeAt(i) & 0x3FF));
            out += internals.hexTable[0xF0 | (c >> 18)] + internals.hexTable[0x80 | ((c >> 12) & 0x3F)] + internals.hexTable[0x80 | ((c >> 6) & 0x3F)] + internals.hexTable[0x80 | (c & 0x3F)];
        }
    
        return out;
    };
    
    exports.compact = function (obj, refs) {
    
        if (typeof obj !== 'object' ||
            obj === null) {
    
            return obj;
        }
    
        refs = refs || [];
        var lookup = refs.indexOf(obj);
        if (lookup !== -1) {
            return refs[lookup];
        }
    
        refs.push(obj);
    
        if (Array.isArray(obj)) {
            var compacted = [];
    
            for (var i = 0, il = obj.length; i < il; ++i) {
                if (typeof obj[i] !== 'undefined') {
                    compacted.push(obj[i]);
                }
            }
    
            return compacted;
        }
    
        var keys = Object.keys(obj);
        for (i = 0, il = keys.length; i < il; ++i) {
            var key = keys[i];
            obj[key] = exports.compact(obj[key], refs);
        }
    
        return obj;
    };
    
    
    exports.isRegExp = function (obj) {
    
        return Object.prototype.toString.call(obj) === '[object RegExp]';
    };
    
    
    exports.isBuffer = function (obj) {
    
        if (obj === null ||
            typeof obj === 'undefined') {
    
            return false;
        }
    
        return !!(obj.constructor &&
                  obj.constructor.isBuffer &&
                  obj.constructor.isBuffer(obj));
    };
    
  provide("qs/lib/utils", module.exports);
}(global));

// pakmanager:qs/lib/stringify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Utils =  require('qs/lib/utils');
    
    
    // Declare internals
    
    var internals = {
        delimiter: '&',
        arrayPrefixGenerators: {
            brackets: function (prefix, key) {
    
                return prefix + '[]';
            },
            indices: function (prefix, key) {
    
                return prefix + '[' + key + ']';
            },
            repeat: function (prefix, key) {
    
                return prefix;
            }
        },
        strictNullHandling: false
    };
    
    
    internals.stringify = function (obj, prefix, generateArrayPrefix, strictNullHandling, filter) {
    
        if (typeof filter === 'function') {
            obj = filter(prefix, obj);
        }
        else if (Utils.isBuffer(obj)) {
            obj = obj.toString();
        }
        else if (obj instanceof Date) {
            obj = obj.toISOString();
        }
        else if (obj === null) {
            if (strictNullHandling) {
                return Utils.encode(prefix);
            }
    
            obj = '';
        }
    
        if (typeof obj === 'string' ||
            typeof obj === 'number' ||
            typeof obj === 'boolean') {
    
            return [Utils.encode(prefix) + '=' + Utils.encode(obj)];
        }
    
        var values = [];
    
        if (typeof obj === 'undefined') {
            return values;
        }
    
        var objKeys = Array.isArray(filter) ? filter : Object.keys(obj);
        for (var i = 0, il = objKeys.length; i < il; ++i) {
            var key = objKeys[i];
    
            if (Array.isArray(obj)) {
                values = values.concat(internals.stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, filter));
            }
            else {
                values = values.concat(internals.stringify(obj[key], prefix + '[' + key + ']', generateArrayPrefix, strictNullHandling, filter));
            }
        }
    
        return values;
    };
    
    
    module.exports = function (obj, options) {
    
        options = options || {};
        var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;
        var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;
        var objKeys;
        var filter;
        if (typeof options.filter === 'function') {
            filter = options.filter;
            obj = filter('', obj);
        }
        else if (Array.isArray(options.filter)) {
            objKeys = filter = options.filter;
        }
    
        var keys = [];
    
        if (typeof obj !== 'object' ||
            obj === null) {
    
            return '';
        }
    
        var arrayFormat;
        if (options.arrayFormat in internals.arrayPrefixGenerators) {
            arrayFormat = options.arrayFormat;
        }
        else if ('indices' in options) {
            arrayFormat = options.indices ? 'indices' : 'repeat';
        }
        else {
            arrayFormat = 'indices';
        }
    
        var generateArrayPrefix = internals.arrayPrefixGenerators[arrayFormat];
    
        if (!objKeys) {
            objKeys = Object.keys(obj);
        }
        for (var i = 0, il = objKeys.length; i < il; ++i) {
            var key = objKeys[i];
            keys = keys.concat(internals.stringify(obj[key], key, generateArrayPrefix, strictNullHandling, filter));
        }
    
        return keys.join(delimiter);
    };
    
  provide("qs/lib/stringify", module.exports);
}(global));

// pakmanager:qs/lib/parse
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Utils =  require('qs/lib/utils');
    
    
    // Declare internals
    
    var internals = {
        delimiter: '&',
        depth: 5,
        arrayLimit: 20,
        parameterLimit: 1000,
        strictNullHandling: false,
        plainObjects: false,
        allowPrototypes: false
    };
    
    
    internals.parseValues = function (str, options) {
    
        var obj = {};
        var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);
    
        for (var i = 0, il = parts.length; i < il; ++i) {
            var part = parts[i];
            var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;
    
            if (pos === -1) {
                obj[Utils.decode(part)] = '';
    
                if (options.strictNullHandling) {
                    obj[Utils.decode(part)] = null;
                }
            }
            else {
                var key = Utils.decode(part.slice(0, pos));
                var val = Utils.decode(part.slice(pos + 1));
    
                if (!Object.prototype.hasOwnProperty.call(obj, key)) {
                    obj[key] = val;
                }
                else {
                    obj[key] = [].concat(obj[key]).concat(val);
                }
            }
        }
    
        return obj;
    };
    
    
    internals.parseObject = function (chain, val, options) {
    
        if (!chain.length) {
            return val;
        }
    
        var root = chain.shift();
    
        var obj;
        if (root === '[]') {
            obj = [];
            obj = obj.concat(internals.parseObject(chain, val, options));
        }
        else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
            var index = parseInt(cleanRoot, 10);
            var indexString = '' + index;
            if (!isNaN(index) &&
                root !== cleanRoot &&
                indexString === cleanRoot &&
                index >= 0 &&
                (options.parseArrays &&
                 index <= options.arrayLimit)) {
    
                obj = [];
                obj[index] = internals.parseObject(chain, val, options);
            }
            else {
                obj[cleanRoot] = internals.parseObject(chain, val, options);
            }
        }
    
        return obj;
    };
    
    
    internals.parseKeys = function (key, val, options) {
    
        if (!key) {
            return;
        }
    
        // Transform dot notation to bracket notation
    
        if (options.allowDots) {
            key = key.replace(/\.([^\.\[]+)/g, '[$1]');
        }
    
        // The regex chunks
    
        var parent = /^([^\[\]]*)/;
        var child = /(\[[^\[\]]*\])/g;
    
        // Get the parent
    
        var segment = parent.exec(key);
    
        // Stash the parent if it exists
    
        var keys = [];
        if (segment[1]) {
            // If we aren't using plain objects, optionally prefix keys
            // that would overwrite object prototype properties
            if (!options.plainObjects &&
                Object.prototype.hasOwnProperty(segment[1])) {
    
                if (!options.allowPrototypes) {
                    return;
                }
            }
    
            keys.push(segment[1]);
        }
    
        // Loop through children appending to the array until we hit depth
    
        var i = 0;
        while ((segment = child.exec(key)) !== null && i < options.depth) {
    
            ++i;
            if (!options.plainObjects &&
                Object.prototype.hasOwnProperty(segment[1].replace(/\[|\]/g, ''))) {
    
                if (!options.allowPrototypes) {
                    continue;
                }
            }
            keys.push(segment[1]);
        }
    
        // If there's a remainder, just add whatever is left
    
        if (segment) {
            keys.push('[' + key.slice(segment.index) + ']');
        }
    
        return internals.parseObject(keys, val, options);
    };
    
    
    module.exports = function (str, options) {
    
        options = options || {};
        options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;
        options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;
        options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;
        options.parseArrays = options.parseArrays !== false;
        options.allowDots = options.allowDots !== false;
        options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : internals.plainObjects;
        options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : internals.allowPrototypes;
        options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;
        options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;
    
        if (str === '' ||
            str === null ||
            typeof str === 'undefined') {
    
            return options.plainObjects ? Object.create(null) : {};
        }
    
        var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;
        var obj = options.plainObjects ? Object.create(null) : {};
    
        // Iterate over the keys and setup the new object
    
        var keys = Object.keys(tempObj);
        for (var i = 0, il = keys.length; i < il; ++i) {
            var key = keys[i];
            var newObj = internals.parseKeys(key, tempObj[key], options);
            obj = Utils.merge(obj, newObj, options);
        }
    
        return Utils.compact(obj);
    };
    
  provide("qs/lib/parse", module.exports);
}(global));

// pakmanager:qs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Stringify =  require('qs/lib/stringify');
    var Parse =  require('qs/lib/parse');
    
    
    // Declare internals
    
    var internals = {};
    
    
    module.exports = {
        stringify: Stringify,
        parse: Parse
    };
    
  provide("qs", module.exports);
}(global));

// pakmanager:pez/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Stream = require('stream');
    var B64 = require('b64');
    var Boom = require('boom');
    var Content = require('content');
    var Hoek = require('hoek');
    var Nigel = require('nigel');
    
    
    // Declare internals
    
    var internals = {};
    
    
    /*
        RFC 2046 (http://tools.ietf.org/html/rfc2046)
    
        multipart-body = [preamble CRLF]
                        dash-boundary *( SPACE / HTAB ) CRLF body-part
                        *( CRLF dash-boundary *( SPACE / HTAB ) CRLF body-part )
                        CRLF dash-boundary "--" *( SPACE / HTAB )
                        [CRLF epilogue]
    
        boundary       = 0*69<bchars> bcharsnospace
        bchars         = bcharsnospace / " "
        bcharsnospace  = DIGIT / ALPHA / "'" / "(" / ")" / "+" / "_" / "," / "-" / "." / "/" / ":" / "=" / "?"
        dash-boundary  = "--" boundary
    
        preamble       = discard-text
        epilogue       = discard-text
        discard-text   = *(*text CRLF) *text
    
        body-part      = MIME-part-headers [CRLF *OCTET]
        OCTET          = <any 0-255 octet value>
    
        SPACE          = 32
        HTAB           = 9
        CRLF           = 13 10
    */
    
    
    internals.state = {
        preamble: 0,                // Until the first boundary is received
        boundary: 1,                // After a boundary, waiting for first line with optional linear-whitespace
        header: 2,                  // Receiving part headers
        payload: 3,                 // Receiving part payload
        epilogue: 4
    };
    
    
    exports.Dispenser = internals.Dispenser = function (contentType) {
    
        var self = this;
    
        Stream.Writable.call(this);
    
        this._boundary = contentType.boundary;
        this._state = internals.state.preamble;
        this._held = '';
    
        this._stream = null;
        this._headers = {};
        this._name = '';
        this._pendingHeader = '';
        this._error = null;
    
        this._parts = new Nigel.Stream(new Buffer('--' + contentType.boundary));
        this._lines = new Nigel.Stream(new Buffer('\r\n'));
    
        this._parts.on('needle', function () {
    
            self._onPartEnd();
        });
    
        this._parts.on('haystack', function (chunk) {
    
            self._onPart(chunk);
        });
    
        this._lines.on('needle', function () {
    
            self._onLineEnd();
        });
    
        this._lines.on('haystack', function (chunk) {
    
            self._onLine(chunk);
        });
    
        this.once('finish', function () {
    
            self._parts.end();
        });
    
        this._parts.once('close', function () {
    
            self._lines.end();
        });
    
        var piper = null;
        var finish = function (err) {
    
            if (piper) {
                piper.removeListener('error', finish);
                piper.removeListener('aborted', onReqAborted);
            }
    
            if (err) {
                return self._abort(err);
            }
    
            self._emit('close');
        };
    
        finish = Hoek.once(finish);
    
        this._lines.once('close', function () {
    
            if (self._state === internals.state.epilogue) {
                if (self._held) {
                    self._emit('epilogue', self._held);
                    self._held = '';
                }
            }
            else if (self._state === internals.state.boundary) {
                if (!self._held) {
                    self._abort(Boom.badRequest('Missing end boundary'));
                }
                else if (self._held !== '--') {
                    self._abort(Boom.badRequest('Only white space allowed after boundary at end'));
                }
            }
            else {
                self._abort(Boom.badRequest('Incomplete multipart payload'));
            }
    
            setImmediate(finish);                  // Give pending events a chance to fire
        });
    
        var onReqAborted = function () {
    
            finish(Boom.badRequest('Client request aborted'));
        };
    
        this.once('pipe', function (req) {
    
            piper = req;
            req.once('error', finish);
            req.once('aborted', onReqAborted);
        });
    };
    
    Hoek.inherits(internals.Dispenser, Stream.Writable);
    
    
    internals.Dispenser.prototype._write = function (buffer, encoding, next) {
    
        if (this._error) {
            return next();
        }
    
        this._parts.write(buffer);
        return next();
    };
    
    
    internals.Dispenser.prototype._emit = function () {
    
        if (this._error) {
            return;
        }
    
        this.emit.apply(this, arguments);
    };
    
    
    internals.Dispenser.prototype._abort = function (err) {
    
        this._emit('error', err);
        this._error = err;
    };
    
    
    internals.Dispenser.prototype._onPartEnd = function () {
    
        this._lines.flush();
    
        if (this._state === internals.state.preamble) {
            if (this._held) {
                var last = this._held.length - 1;
                if (this._held[last] !== '\n' ||
                    this._held[last - 1] !== '\r') {
    
                    return this._abort(Boom.badRequest('Preamble missing CRLF terminator'));
                }
    
                this._emit('preamble', this._held.slice(0, -2));
                this._held = '';
            }
    
            this._parts.needle(new Buffer('\r\n--' + this._boundary));                      // CRLF no longer optional
        }
    
        this._state = internals.state.boundary;
    
        if (this._stream) {
            this._stream.end();
            this._stream = null;
        }
        else if (this._name) {
            this._emit('field', this._name, this._held);
            this._name = '';
            this._held = '';
        }
    };
    
    
    internals.Dispenser.prototype._onPart = function (chunk) {
    
        if (this._state === internals.state.preamble) {
            this._held += chunk.toString();
        }
        else if (this._state === internals.state.payload) {
            if (this._stream) {
                this._stream.write(chunk);                                                 // Stream payload
            }
            else {
                this._held += chunk.toString();
            }
        }
        else {
            this._lines.write(chunk);                                                       // Look for boundary
        }
    };
    
    
    internals.Dispenser.prototype._onLineEnd = function () {
    
        // Boundary whitespace
    
        if (this._state === internals.state.boundary) {
            if (this._held) {
                this._held = this._held.replace(/[\t ]/g, '');                                // trim() removes new lines
                if (this._held) {
                    if (this._held === '--') {
                        this._state = internals.state.epilogue;
                        this._held = '';
    
                        return;
                    }
                    else {
                        return this._abort(Boom.badRequest('Only white space allowed after boundary'));
                    }
                }
            }
    
            this._state = internals.state.header;
    
            return;
        }
    
        // Part headers
    
        if (this._state === internals.state.header) {
    
            // Header
    
            if (this._held) {
    
                // Header continuation
    
                if (this._held[0] === ' ' ||
                    this._held[0] === '\t') {
    
                    if (!this._pendingHeader) {
                        return this._abort(Boom.badRequest('Invalid header continuation without valid declaration on previous line'));
                    }
    
                    this._pendingHeader += ' ' + this._held.slice(1);                       // Drop tab
                    this._held = '';
                    return;
                }
    
                // Start of new header
    
                this._flushHeader();
                this._pendingHeader = this._held;
                this._held = '';
    
                return;
            }
    
            // End of headers
    
            this._flushHeader();
    
            this._state = internals.state.payload;
    
            var disposition = Content.disposition(this._headers['content-disposition']);
            if (disposition.isBoom) {
                return this._abort(disposition);
            }
    
            if (disposition.filename !== undefined) {
                var stream = new Stream.PassThrough();
                var transferEncoding = this._headers['content-transfer-encoding'];
                if (transferEncoding &&
                    transferEncoding.toLowerCase() === 'base64') {
    
                    this._stream = new B64.Decoder();
                    this._stream.pipe(stream);
                }
                else {
                    this._stream = stream;
                }
    
                stream.name = disposition.name;
                stream.filename = disposition.filename;
                stream.headers = this._headers;
                this._headers = {};
    
    
                this._emit('part', stream);
            }
            else {
                this._name = disposition.name;
            }
    
            this._lines.flush();
            return;
        }
    
        // Epilogue
    
        this._held += '\r\n';                               // Put the new line back
    };
    
    
    internals.Dispenser.prototype._onLine = function (chunk) {
    
        if (this._stream) {
            this._stream.write(chunk);                      // Stream payload
        }
        else {
            this._held += chunk.toString();                 // Reading header or field
        }
    };
    
    
    internals.Dispenser.prototype._flushHeader = function () {
    
        if (!this._pendingHeader) {
            return;
        }
    
        var sep = this._pendingHeader.indexOf(':');
        if (sep === -1) {
            return this._abort(Boom.badRequest('Invalid header missing colon separator'));
        }
    
        if (!sep) {
            return this._abort(Boom.badRequest('Invalid header missing field name'));
        }
    
        this._headers[this._pendingHeader.slice(0, sep).toLowerCase()] = this._pendingHeader.slice(sep + 1).trim();
        this._pendingHeader = '';
    };
    
  provide("pez/lib", module.exports);
}(global));

// pakmanager:pez
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('pez/lib');
  provide("pez", module.exports);
}(global));

// pakmanager:optimist
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require('path');
    var minimist = require('minimist');
    var wordwrap = require('wordwrap');
    
    /*  Hack an instance of Argv with process.argv into Argv
        so people can do
             require('optimist')(['--beeble=1','-z','zizzle']).argv
        to parse a list of args and
             require('optimist').argv
        to get a parsed version of process.argv.
    */
    
    var inst = Argv(process.argv.slice(2));
    Object.keys(inst).forEach(function (key) {
        Argv[key] = typeof inst[key] == 'function'
            ? inst[key].bind(inst)
            : inst[key];
    });
    
    var exports = module.exports = Argv;
    function Argv (processArgs, cwd) {
        var self = {};
        if (!cwd) cwd = process.cwd();
        
        self.$0 = process.argv
            .slice(0,2)
            .map(function (x) {
                var b = rebase(cwd, x);
                return x.match(/^\//) && b.length < x.length
                    ? b : x
            })
            .join(' ')
        ;
        
        if (process.env._ != undefined && process.argv[1] == process.env._) {
            self.$0 = process.env._.replace(
                path.dirname(process.execPath) + '/', ''
            );
        }
        
        var options = {
            boolean: [],
            string: [],
            alias: {},
            default: []
        };
        
        self.boolean = function (bools) {
            options.boolean.push.apply(options.boolean, [].concat(bools));
            return self;
        };
        
        self.string = function (strings) {
            options.string.push.apply(options.string, [].concat(strings));
            return self;
        };
        
        self.default = function (key, value) {
            if (typeof key === 'object') {
                Object.keys(key).forEach(function (k) {
                    self.default(k, key[k]);
                });
            }
            else {
                options.default[key] = value;
            }
            return self;
        };
        
        self.alias = function (x, y) {
            if (typeof x === 'object') {
                Object.keys(x).forEach(function (key) {
                    self.alias(key, x[key]);
                });
            }
            else {
                options.alias[x] = (options.alias[x] || []).concat(y);
            }
            return self;
        };
        
        var demanded = {};
        self.demand = function (keys) {
            if (typeof keys == 'number') {
                if (!demanded._) demanded._ = 0;
                demanded._ += keys;
            }
            else if (Array.isArray(keys)) {
                keys.forEach(function (key) {
                    self.demand(key);
                });
            }
            else {
                demanded[keys] = true;
            }
            
            return self;
        };
        
        var usage;
        self.usage = function (msg, opts) {
            if (!opts && typeof msg === 'object') {
                opts = msg;
                msg = null;
            }
            
            usage = msg;
            
            if (opts) self.options(opts);
            
            return self;
        };
        
        function fail (msg) {
            self.showHelp();
            if (msg) console.error(msg);
            process.exit(1);
        }
        
        var checks = [];
        self.check = function (f) {
            checks.push(f);
            return self;
        };
        
        var descriptions = {};
        self.describe = function (key, desc) {
            if (typeof key === 'object') {
                Object.keys(key).forEach(function (k) {
                    self.describe(k, key[k]);
                });
            }
            else {
                descriptions[key] = desc;
            }
            return self;
        };
        
        self.parse = function (args) {
            return parseArgs(args);
        };
        
        self.option = self.options = function (key, opt) {
            if (typeof key === 'object') {
                Object.keys(key).forEach(function (k) {
                    self.options(k, key[k]);
                });
            }
            else {
                if (opt.alias) self.alias(key, opt.alias);
                if (opt.demand) self.demand(key);
                if (typeof opt.default !== 'undefined') {
                    self.default(key, opt.default);
                }
                
                if (opt.boolean || opt.type === 'boolean') {
                    self.boolean(key);
                }
                if (opt.string || opt.type === 'string') {
                    self.string(key);
                }
                
                var desc = opt.describe || opt.description || opt.desc;
                if (desc) {
                    self.describe(key, desc);
                }
            }
            
            return self;
        };
        
        var wrap = null;
        self.wrap = function (cols) {
            wrap = cols;
            return self;
        };
        
        self.showHelp = function (fn) {
            if (!fn) fn = console.error;
            fn(self.help());
        };
        
        self.help = function () {
            var keys = Object.keys(
                Object.keys(descriptions)
                .concat(Object.keys(demanded))
                .concat(Object.keys(options.default))
                .reduce(function (acc, key) {
                    if (key !== '_') acc[key] = true;
                    return acc;
                }, {})
            );
            
            var help = keys.length ? [ 'Options:' ] : [];
            
            if (usage) {
                help.unshift(usage.replace(/\$0/g, self.$0), '');
            }
            
            var switches = keys.reduce(function (acc, key) {
                acc[key] = [ key ].concat(options.alias[key] || [])
                    .map(function (sw) {
                        return (sw.length > 1 ? '--' : '-') + sw
                    })
                    .join(', ')
                ;
                return acc;
            }, {});
            
            var switchlen = longest(Object.keys(switches).map(function (s) {
                return switches[s] || '';
            }));
            
            var desclen = longest(Object.keys(descriptions).map(function (d) { 
                return descriptions[d] || '';
            }));
            
            keys.forEach(function (key) {
                var kswitch = switches[key];
                var desc = descriptions[key] || '';
                
                if (wrap) {
                    desc = wordwrap(switchlen + 4, wrap)(desc)
                        .slice(switchlen + 4)
                    ;
                }
                
                var spadding = new Array(
                    Math.max(switchlen - kswitch.length + 3, 0)
                ).join(' ');
                
                var dpadding = new Array(
                    Math.max(desclen - desc.length + 1, 0)
                ).join(' ');
                
                var type = null;
                
                if (options.boolean[key]) type = '[boolean]';
                if (options.string[key]) type = '[string]';
                
                if (!wrap && dpadding.length > 0) {
                    desc += dpadding;
                }
                
                var prelude = '  ' + kswitch + spadding;
                var extra = [
                    type,
                    demanded[key]
                        ? '[required]'
                        : null
                    ,
                    options.default[key] !== undefined
                        ? '[default: ' + JSON.stringify(options.default[key]) + ']'
                        : null
                    ,
                ].filter(Boolean).join('  ');
                
                var body = [ desc, extra ].filter(Boolean).join('  ');
                
                if (wrap) {
                    var dlines = desc.split('\n');
                    var dlen = dlines.slice(-1)[0].length
                        + (dlines.length === 1 ? prelude.length : 0)
                    
                    body = desc + (dlen + extra.length > wrap - 2
                        ? '\n'
                            + new Array(wrap - extra.length + 1).join(' ')
                            + extra
                        : new Array(wrap - extra.length - dlen + 1).join(' ')
                            + extra
                    );
                }
                
                help.push(prelude + body);
            });
            
            help.push('');
            return help.join('\n');
        };
        
        Object.defineProperty(self, 'argv', {
            get : function () { return parseArgs(processArgs) },
            enumerable : true,
        });
        
        function parseArgs (args) {
            var argv = minimist(args, options);
            argv.$0 = self.$0;
            
            if (demanded._ && argv._.length < demanded._) {
                fail('Not enough non-option arguments: got '
                    + argv._.length + ', need at least ' + demanded._
                );
            }
            
            var missing = [];
            Object.keys(demanded).forEach(function (key) {
                if (!argv[key]) missing.push(key);
            });
            
            if (missing.length) {
                fail('Missing required arguments: ' + missing.join(', '));
            }
            
            checks.forEach(function (f) {
                try {
                    if (f(argv) === false) {
                        fail('Argument check failed: ' + f.toString());
                    }
                }
                catch (err) {
                    fail(err)
                }
            });
            
            return argv;
        }
        
        function longest (xs) {
            return Math.max.apply(
                null,
                xs.map(function (x) { return x.length })
            );
        }
        
        return self;
    };
    
    // rebase an absolute path to a relative one with respect to a base directory
    // exported for tests
    exports.rebase = rebase;
    function rebase (base, dir) {
        var ds = path.normalize(dir).split('/').slice(1);
        var bs = path.normalize(base).split('/').slice(1);
        
        for (var i = 0; ds[i] && ds[i] == bs[i]; i++);
        ds.splice(0, i); bs.splice(0, i);
        
        var p = path.normalize(
            bs.map(function () { return '..' }).concat(ds).join('/')
        ).replace(/\/$/,'').replace(/^$/, '.');
        return p.match(/^[.\/]/) ? p : './' + p;
    };
    
  provide("optimist", module.exports);
}(global));

// pakmanager:uglify-js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require("path");
    var fs = require("fs");
    var vm = require("vm");
    
    var UglifyJS = vm.createContext({
        console       : console,
        process       : process,
        Buffer        : Buffer,
        MOZ_SourceMap : require("source-map")
    });
    
    function load_global(file) {
        file = path.resolve(path.dirname(module.filename), file);
        try {
            var code = fs.readFileSync(file, "utf8");
            return vm.runInContext(code, UglifyJS, file);
        } catch(ex) {
            // XXX: in case of a syntax error, the message is kinda
            // useless. (no location information).
            console.log("ERROR in file: " + file + " / " + ex);
            process.exit(1);
        }
    };
    
    var FILES = exports.FILES = [
        "../lib/utils.js",
        "../lib/ast.js",
        "../lib/parse.js",
        "../lib/transform.js",
        "../lib/scope.js",
        "../lib/output.js",
        "../lib/compress.js",
        "../lib/sourcemap.js",
        "../lib/mozilla-ast.js",
        "../lib/propmangle.js"
    ].map(function(file){
        return fs.realpathSync(path.join(path.dirname(__filename), file));
    });
    
    FILES.forEach(load_global);
    
    UglifyJS.AST_Node.warn_function = function(txt) {
        console.error("WARN: %s", txt);
    };
    
    // XXX: perhaps we shouldn't export everything but heck, I'm lazy.
    for (var i in UglifyJS) {
        if (UglifyJS.hasOwnProperty(i)) {
            exports[i] = UglifyJS[i];
        }
    }
    
    exports.minify = function(files, options) {
        options = UglifyJS.defaults(options, {
            spidermonkey : false,
            outSourceMap : null,
            sourceRoot   : null,
            inSourceMap  : null,
            fromString   : false,
            warnings     : false,
            mangle       : {},
            output       : null,
            compress     : {}
        });
        UglifyJS.base54.reset();
    
        // 1. parse
        var toplevel = null,
            sourcesContent = {};
    
        if (options.spidermonkey) {
            toplevel = UglifyJS.AST_Node.from_mozilla_ast(files);
        } else {
            if (typeof files == "string")
                files = [ files ];
            files.forEach(function(file){
                var code = options.fromString
                    ? file
                    : fs.readFileSync(file, "utf8");
                sourcesContent[file] = code;
                toplevel = UglifyJS.parse(code, {
                    filename: options.fromString ? "?" : file,
                    toplevel: toplevel
                });
            });
        }
    
        // 2. compress
        if (options.compress) {
            var compress = { warnings: options.warnings };
            UglifyJS.merge(compress, options.compress);
            toplevel.figure_out_scope();
            var sq = UglifyJS.Compressor(compress);
            toplevel = toplevel.transform(sq);
        }
    
        // 3. mangle
        if (options.mangle) {
            toplevel.figure_out_scope(options.mangle);
            toplevel.compute_char_frequency(options.mangle);
            toplevel.mangle_names(options.mangle);
        }
    
        // 4. output
        var inMap = options.inSourceMap;
        var output = {};
        if (typeof options.inSourceMap == "string") {
            inMap = fs.readFileSync(options.inSourceMap, "utf8");
        }
        if (options.outSourceMap) {
            output.source_map = UglifyJS.SourceMap({
                file: options.outSourceMap,
                orig: inMap,
                root: options.sourceRoot
            });
            if (options.sourceMapIncludeSources) {
                for (var file in sourcesContent) {
                    if (sourcesContent.hasOwnProperty(file)) {
                        output.source_map.get().setSourceContent(file, sourcesContent[file]);
                    }
                }
            }
    
        }
        if (options.output) {
            UglifyJS.merge(output, options.output);
        }
        var stream = UglifyJS.OutputStream(output);
        toplevel.print(stream);
    
        if(options.outSourceMap){
            stream += "\n//# sourceMappingURL=" + options.outSourceMap;
        }
    
        var source_map = output.source_map;
        if (source_map) {
            source_map = source_map + "";
        }
    
        return {
            code : stream + "",
            map  : source_map
        };
    };
    
    // exports.describe_ast = function() {
    //     function doitem(ctor) {
    //         var sub = {};
    //         ctor.SUBCLASSES.forEach(function(ctor){
    //             sub[ctor.TYPE] = doitem(ctor);
    //         });
    //         var ret = {};
    //         if (ctor.SELF_PROPS.length > 0) ret.props = ctor.SELF_PROPS;
    //         if (ctor.SUBCLASSES.length > 0) ret.sub = sub;
    //         return ret;
    //     }
    //     return doitem(UglifyJS.AST_Node).sub;
    // }
    
    exports.describe_ast = function() {
        var out = UglifyJS.OutputStream({ beautify: true });
        function doitem(ctor) {
            out.print("AST_" + ctor.TYPE);
            var props = ctor.SELF_PROPS.filter(function(prop){
                return !/^\$/.test(prop);
            });
            if (props.length > 0) {
                out.space();
                out.with_parens(function(){
                    props.forEach(function(prop, i){
                        if (i) out.space();
                        out.print(prop);
                    });
                });
            }
            if (ctor.documentation) {
                out.space();
                out.print_string(ctor.documentation);
            }
            if (ctor.SUBCLASSES.length > 0) {
                out.space();
                out.with_block(function(){
                    ctor.SUBCLASSES.forEach(function(ctor, i){
                        out.indent();
                        doitem(ctor);
                        out.newline();
                    });
                });
            }
        };
        doitem(UglifyJS.AST_Node);
        return out + "";
    };
    
    function readReservedFile(filename, reserved) {
        if (!reserved) {
            reserved = { vars: [], props: [] };
        }
        var data = fs.readFileSync(filename, "utf8");
        data = JSON.parse(data);
        if (data.vars) {
            data.vars.forEach(function(name){
                UglifyJS.push_uniq(reserved.vars, name);
            });
        }
        if (data.props) {
            data.props.forEach(function(name){
                UglifyJS.push_uniq(reserved.props, name);
            });
        }
        return reserved;
    }
    
    exports.readReservedFile = readReservedFile;
    
    exports.readDefaultReservedFile = function(reserved) {
        return readReservedFile(path.join(__dirname, "domprops.json"), reserved);
    };
    
    exports.readNameCache = function(filename, key) {
        var cache = null;
        if (filename) {
            try {
                var cache = fs.readFileSync(filename, "utf8");
                cache = JSON.parse(cache)[key];
                if (!cache) throw "init";
                cache.props = UglifyJS.Dictionary.fromObject(cache.props);
            } catch(ex) {
                cache = {
                    cname: -1,
                    props: new UglifyJS.Dictionary()
                };
            }
        }
        return cache;
    };
    
    exports.writeNameCache = function(filename, key, cache) {
        if (filename) {
            var data;
            try {
                data = fs.readFileSync(filename, "utf8");
                data = JSON.parse(data);
            } catch(ex) {
                data = {};
            }
            data[key] = {
                cname: cache.cname,
                props: cache.props.toObject()
            };
            fs.writeFileSync(filename, JSON.stringify(data, null, 2), "utf8");
        }
    };
    
  provide("uglify-js", module.exports);
}(global));

// pakmanager:accept/lib/charset
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Boom = require('boom');
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    
    // From https://tools.ietf.org/html/rfc7231#section-5.3.3
    // Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
    
    exports.charset = function (header, preferences) {
    
        Hoek.assert(!preferences || Array.isArray(preferences), 'Preferences must be an array');
        var charsets = header
            .split(',')
            .map(internals.getParts)
            .filter(internals.removeEmpty)
            .sort(internals.compareByWeight);
    
        // Tack on a default return
    
        charsets.push({
            weight: 0.001,
            charset: ''
        });
    
        // No preferences.  Take the first non-disallowed charset
    
        if (!preferences || preferences.length === 0) {
            return charsets.filter(internals.removeDisallowed)[0].charset;
        }
    
        // Lower case all preferences
    
        preferences = preferences.map(internals.lowerCase);
    
        // Remove any disallowed preferences
    
        internals.removeDisallowedPreferences(charsets, preferences);
    
        // If charsets includes * (that isn't disallowed *;q=0) return first preference
    
        var splatLocation = internals.findCharsetItem(charsets, '*');
        if (splatLocation !== -1 && charsets[splatLocation].weight > 0) {
            return preferences[0];
        }
    
        // Try to find the first match in the array of preferences, ignoring case
    
        for (var i = 0, il = charsets.length; i < il; ++i) {
            if (preferences.indexOf(charsets[i].charset.toLowerCase()) !== -1 && charsets[i].weight > 0) {
                return charsets[i].charset;
            }
        }
    
        return '';
    };
    
    
    exports.charsets = function (header) {
    
        if (header === undefined || typeof header !== 'string') {
            return [];
        }
    
        header = header.toLowerCase();
    
        return header
            .split(',')
            .map(internals.getParts)
            .filter(internals.removeEmptyAndDisallowed)
            .sort(internals.compareByWeight)
            .map(internals.partToCharset);
    };
    
    
    internals.getParts = function (item) {
    
        var result = {
            weight: 1,
            charset: ''
        };
    
        var match = item.match(internals.partsRegex);
        if (!match) {
            return result;
        }
    
        result.charset = match[1];
        if (match[2] && internals.isNumber(match[2])) {
            var weight = parseFloat(match[2]);
            if (weight === 0 || (weight >= 0.001 && weight <= 1)) {
                result.weight = weight;
            }
        }
        return result;
    };
    
    //                         1: token               2: qvalue
    internals.partsRegex = /\s*([^;]+)(?:\s*;\s*[qQ]\=([01](?:\.\d*)?))?\s*/;
    
    
    internals.removeEmpty = function (item) {
    
        return item.charset !== '';
    };
    
    
    internals.removeDisallowed = function (item) {
    
        return item.weight !== 0;
    };
    
    
    internals.removeEmptyAndDisallowed = function (item) {
    
        return item.charset !== '' && item.weight !== 0;
    };
    
    
    internals.removeDisallowedPreferences = function (charsets, preferences) {
    
        for (var i = 0, il = charsets.length; i < il; i++) {
            var location;
            if (charsets[i].weight === 0) {
                location = preferences.indexOf(charsets[i].charset.toLowerCase());
                if (location !== -1) {
                    preferences.splice(location, 1);
                }
            }
        }
    };
    
    
    internals.compareByWeight = function (a, b) {
    
        return a.weight < b.weight;
    };
    
    
    internals.partToCharset = function (item) {
    
        return item.charset;
    };
    
    
    internals.isNumber = function (n) {
    
        return !isNaN(parseFloat(n));
    };
    
    
    internals.lowerCase = function (str) {
    
        return str.toLowerCase();
    };
    
    
    internals.findCharsetItem = function (charsets, charset) {
    
        for (var i = 0, il = charsets.length; i < il; ++i) {
            if (charsets[i].charset === charset) {
                return i;
            }
        }
    
        return -1;
    };
    
  provide("accept/lib/charset", module.exports);
}(global));

// pakmanager:accept/lib/encoding
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Boom = require('boom');
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    /*
        RFC 7231 Section 5.3.4 (https://tools.ietf.org/html/rfc7231#section-5.3.4)
    
        Accept-Encoding  = #( codings [ weight ] )
        codings          = content-coding / "identity" / "*"
    
        Accept-Encoding: compress, gzip
        Accept-Encoding:
        Accept-Encoding: *
        Accept-Encoding: compress;q=0.5, gzip;q=1.0
        Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
    */
    
    exports.encoding = function (header, preferences) {
    
        var encodings = exports.encodings(header, preferences);
        if (encodings.isBoom) {
            return encodings;
        }
    
        return encodings.length ? encodings[0] : '';
    };
    
    
    exports.encodings = function (header, preferences) {
    
        Hoek.assert(!preferences || Array.isArray(preferences), 'Preferences must be an array');
    
        var scores = internals.parse(header, 'encoding');
        if (scores.isBoom) {
            return scores;
        }
    
        if (!preferences) {
            preferences = Object.keys(scores.accept);
            preferences.push('*');
        }
    
        return internals.map(preferences, scores);
    };
    
    
    /*
        RFC 7231 Section 5.3.1 (https://tools.ietf.org/html/rfc7231#section-5.3.1)
    
       The weight is normalized to a real number in the range 0 through 1,
       where 0.001 is the least preferred and 1 is the most preferred; a
       value of 0 means "not acceptable".  If no "q" parameter is present,
       the default weight is 1.
    
         weight = OWS ";" OWS "q=" qvalue
         qvalue = ( "0" [ "." 0*3DIGIT ] ) / ( "1" [ "." 0*3("0") ] )
    */
    
    //                              1: token               2: qvalue
    internals.preferenceRegex = /\s*([^;\,]+)(?:\s*;\s*[qQ]\=([01](?:\.\d{0,3})?))?\s*(?:\,|$)/g;
    
    
    internals.equivalents = {
        encoding: {
            'x-compress': 'compress',
            'x-gzip': 'gzip'
        }
    };
    
    internals.parse = function (header, type) {
    
        var scores = {
            accept: {},
            reject: {},
            any: 0.0
        };
    
        if (header) {
            var leftovers = header.replace(internals.preferenceRegex, function ($0, $1, $2) {
    
                $1 = $1.toLowerCase();
                var key = internals.equivalents[type][$1] || $1;
                var score = $2 ? parseFloat($2) : 1.0;
                if (key === '*') {
                    scores.any = score;
                }
                else if (score > 0) {
                    scores.accept[key] = score;
                }
                else {
                    scores.reject[key] = true;
                }
    
                return '';
            });
    
            if (leftovers) {
                return Boom.badRequest('Invalid accept-' + type + ' header');
            }
        }
    
        // Add identity at the lowest score if not explicitly set
    
        if (!scores.reject.identity &&
            !scores.accept.identity) {
    
            scores.accept.identity = scores.any || 0.001;
        }
    
        return scores;
    };
    
    
    internals.map = function (preferences, scores) {
    
        var scored = [];
        for (var i = 0, il = preferences.length; i < il; ++i) {
            var key = preferences[i].toLowerCase();
            if (!scores.reject[key]) {
                var score = scores.accept[key] || scores.any;
                if (score > 0) {
                    scored.push({ key: key, score: score });
                }
            }
        }
    
        scored.sort(internals.sort);
    
        var result = [];
        for (i = 0, il = scored.length; i < il; ++i) {
            result.push(scored[i].key);
        }
    
        return result;
    };
    
    
    internals.sort = function (a, b) {
    
        return (a.score === b.score ? 0 : (a.score < b.score ? 1 : -1));
    };
    
  provide("accept/lib/encoding", module.exports);
}(global));

// pakmanager:accept
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var CharsetLib =  require('accept/lib/charset');
    var EncodingLib =  require('accept/lib/encoding');
    
    exports.charset = CharsetLib.charset;
    exports.charsets = CharsetLib.charsets;
    
    exports.encoding = EncodingLib.encoding;
    exports.encodings = EncodingLib.encodings;
    
  provide("accept", module.exports);
}(global));

// pakmanager:call/lib/regex
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.generate = function () {
    
        /*
            /path/{param}/path/{param?}
            /path/{param*2}/path
            /path/{param*2}
            /path/x{param}x
            /{param*}
        */
    
        var empty = '(?:^\\/$)';
    
        var legalChars = '[\\w\\!\\$&\'\\(\\)\\*\\+\\,;\\=\\:@\\-\\.~]';
        var encoded = '%[A-F0-9]{2}';
    
        var literalChar = '(?:' + legalChars + '|' + encoded + ')';
        var literal = literalChar + '+';
        var literalOptional = literalChar + '*';
    
        var midParam = '(?:\\{\\w+(?:\\*[1-9]\\d*)?\\})';                               // {p}, {p*2}
        var endParam = '(?:\\/(?:\\{\\w+(?:(?:\\*(?:[1-9]\\d*)?)|(?:\\?))?\\})?)?';     // {p}, {p*2}, {p*}, {p?}
    
        var partialParam = '(?:\\{\\w+\\??\\})';                                        // {p}, {p?}
        var mixedParam = '(?:(?:' + literal + partialParam + ')+' + literalOptional + ')|(?:' + partialParam + '(?:' + literal + partialParam + ')+' + literalOptional + ')|(?:' + partialParam + literal + ')';
    
        var segmentContent = '(?:' + literal + '|' + midParam + '|' + mixedParam + ')';
        var segment = '\\/' + segmentContent;
        var segments = '(?:' + segment + ')*';
    
        var path = '(?:^' + segments + endParam + '$)';
    
        //                1:literal               2:name   3:*  4:count  5:?
        var parseParam = '(' + literal + ')|(?:\\{(\\w+)(?:(\\*)(\\d+)?)?(\\?)?\\})';
    
        var expressions = {
            parseParam: new RegExp(parseParam, 'g'),
            validatePath: new RegExp(empty + '|' + path),
            validatePathEncoded: /%(?:2[146-9A-E]|3[\dABD]|4[\dA-F]|5[\dAF]|6[1-9A-F]|7[\dAE])/g
        };
    
        return expressions;
    };
    
  provide("call/lib/regex", module.exports);
}(global));

// pakmanager:call/lib/segment
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Hoek = require('hoek');
    var Boom = require('boom');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports = module.exports = internals.Segment = function () {
    
        this._edge = null;              // { segment, record }
        this._fulls = null;             // { path: { segment, record }
        this._literals = null;          // { literal: { segment, <node> } }
        this._param = null;             // <node>
        this._mixed = null;             // [{ segment, <node> }]
        this._wildcard = null;          // { segment, record }
    };
    
    
    internals.Segment.prototype.add = function (segments, record) {
    
        /*
            { literal: 'x' }        -> x
            { empty: false }        -> {p}
            { wildcard: true }      -> {p*}
            { mixed: /regex/ }      -> a{p}b
        */
    
        var current = segments[0];
        var remaining = segments.slice(1);
        var isEdge = !remaining.length;
    
        var literals = [];
        for (var i = 0, il = segments.length, isLiteral = true; i < il && isLiteral; ++i) {
            isLiteral = segments[i].literal !== undefined;
            literals.push(segments[i].literal);
        }
    
        if (isLiteral) {
            this._fulls = this._fulls || {};
            var literal = '/' + literals.join('/');
            if (!record.settings.isCaseSensitive) {
                literal = literal.toLowerCase();
            }
    
            Hoek.assert(!this._fulls[literal], 'New route', record.path, 'conflicts with existing', this._fulls[literal] && this._fulls[literal].record.path);
            this._fulls[literal] = { segment: current, record: record };
        }
        else if (current.literal !== undefined) {               // Can be empty string
    
            // Literal
    
            this._literals = this._literals || {};
            var currentLiteral = (record.settings.isCaseSensitive ? current.literal : current.literal.toLowerCase());
            this._literals[currentLiteral] = this._literals[currentLiteral] || new internals.Segment();
            this._literals[currentLiteral].add(remaining, record);
        }
        else if (current.wildcard) {
    
            // Wildcard
    
            Hoek.assert(!this._wildcard, 'New route', record.path, 'conflicts with existing', this._wildcard && this._wildcard.record.path);
            Hoek.assert(!this._param || !this._param._wildcard, 'New route', record.path, 'conflicts with existing', this._param && this._param._wildcard && this._param._wildcard.record.path);
            this._wildcard = { segment: current, record: record };
        }
        else if (current.mixed) {
    
            // Mixed
    
            this._mixed = this._mixed || [];
    
            var mixed = this._mixedLookup(current);
            if (!mixed) {
                mixed = { segment: current, node: new internals.Segment() };
                this._mixed.push(mixed);
                this._mixed.sort(internals.mixed);
            }
    
            if (isEdge) {
                Hoek.assert(!mixed.node._edge, 'New route', record.path, 'conflicts with existing', mixed.node._edge && mixed.node._edge.record.path);
                mixed.node._edge = { segment: current, record: record };
            }
            else {
                mixed.node.add(remaining, record);
            }
        }
        else {
    
            // Parameter
    
            this._param = this._param || new internals.Segment();
    
            if (isEdge) {
                Hoek.assert(!this._param._edge, 'New route', record.path, 'conflicts with existing', this._param._edge && this._param._edge.record.path);
                this._param._edge = { segment: current, record: record };
            }
            else {
                Hoek.assert(!this._wildcard || !remaining[0].wildcard, 'New route', record.path, 'conflicts with existing', this._wildcard && this._wildcard.record.path);
                this._param.add(remaining, record);
            }
        }
    };
    
    
    internals.Segment.prototype._mixedLookup = function (segment) {
    
        for (var i = 0, il = this._mixed.length; i < il; ++i) {
            if (internals.mixed({ segment: segment }, this._mixed[i]) === 0) {
                return this._mixed[i];
            }
        }
    
        return null;
    };
    
    
    internals.mixed = function (a, b) {
    
        var aFirst = -1;
        var bFirst = 1;
    
        var as = a.segment;
        var bs = b.segment;
    
        if (as.length !== bs.length) {
            return (as.length > bs.length ? aFirst : bFirst);
        }
    
        if (as.first !== bs.first) {
            return (as.first ? bFirst : aFirst);
        }
    
        for (var j = 0, jl = as.segments.length; j < jl; ++j) {
            var am = as.segments[j];
            var bm = bs.segments[j];
    
            if (am === bm) {
                continue;
            }
    
            if (am.length === bm.length) {
                return (am > bm ? bFirst : aFirst);
            }
    
            return (am.length < bm.length ? bFirst : aFirst);
        }
    
        return 0;
    };
    
    
    internals.Segment.prototype.lookup = function (path, segments, options) {
    
        var match = null;
    
        // Literal edge
    
        if (this._fulls) {
            match = this._fulls[options.isCaseSensitive ? path : path.toLowerCase()];
            if (match) {
                return { record: match.record, array: [] };
            }
        }
    
        // Literal node
    
        var current = segments[0];
        var nextPath = path.slice(current.length + 1);
        var remainder = (segments.length > 1 ? segments.slice(1) : null);
    
        if (this._literals) {
            match = this._literals[options.isCaseSensitive ? current : current.toLowerCase()];
            if (match) {
                var record = internals.deeper(match, nextPath, remainder, [], options);
                if (record) {
                    return record;
                }
            }
        }
    
        // Mixed
    
        if (this._mixed) {
            for (var i = 0, il = this._mixed.length; i < il; ++i) {
                match = this._mixed[i];
                var params = current.match(match.segment.mixed);
                if (params) {
                    var array = [];
                    for (var p = 1, pl = params.length; p < pl; ++p) {
                        array.push(params[p]);
                    }
    
                    record = internals.deeper(match.node, nextPath, remainder, array, options);
                    if (record) {
                        return record;
                    }
                }
            }
        }
    
        // Param
    
        if (this._param) {
            if (current ||
                !this._param._edge ||
                this._param._edge.segment.empty) {
    
                record = internals.deeper(this._param, nextPath, remainder, [current], options);
                if (record) {
                    return record;
                }
            }
        }
    
        // Wildcard
    
        if (this._wildcard) {
            return { record: this._wildcard.record, array: [path.slice(1)] };
        }
    
        return null;
    };
    
    
    internals.deeper = function (match, path, segments, array, options) {
    
        if (!segments) {
            if (match._edge) {
                return { record: match._edge.record, array: array };
            }
    
            if (match._wildcard) {
                return { record: match._wildcard.record, array: array };
            }
        }
        else {
            var result = match.lookup(path, segments, options);
            if (result) {
                return { record: result.record, array: array.concat(result.array) };
            }
        }
    
        return null;
    };
    
  provide("call/lib/segment", module.exports);
}(global));

// pakmanager:call
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Hoek = require('hoek');
    var Boom = require('boom');
    var Regex =  require('call/lib/regex');
    var Segment =  require('call/lib/segment');
    
    
    // Declare internals
    
    var internals = {
        pathRegex: Regex.generate(),
        defaults: {
            isCaseSensitive: true
        }
    };
    
    
    exports.Router = internals.Router = function (options) {
    
        this.settings = Hoek.applyToDefaults(internals.defaults, options || {});
    
        this.routes = {};                               // Key: HTTP method or * for catch-all, value: sorted array of routes
        this.ids = {};                                  // Key: route id, value: record
        this.vhosts = null;                             // {} where Key: hostname, value: see this.routes
    
        this.specials = {
            badRequest: null,
            notFound: null,
            options: null
        };
    };
    
    
    internals.Router.prototype.add = function (config, route) {
    
        var self = this;
    
        var method = config.method.toLowerCase();
    
        var vhost = config.vhost || '*';
        if (vhost !== '*') {
            self.vhosts = self.vhosts || {};
            self.vhosts[vhost] = self.vhosts[vhost] || {};
        }
    
        var table = (vhost === '*' ? self.routes : self.vhosts[vhost]);
        table[method] = table[method] || { routes: [], router: new Segment() };
    
        var analysis = config.analysis || this.analyze(config.path);
        var record = {
            path: config.path,
            route: route || config.path,
            segments: analysis.segments,
            params: analysis.params,
            fingerprint: analysis.fingerprint,
            settings: this.settings
        };
    
        // Add route
    
        table[method].router.add(analysis.segments, record);
        table[method].routes.push(record);
        table[method].routes.sort(internals.sort);
    
        var last = record.segments[record.segments.length - 1];
        if (last.empty) {
            table[method].router.add(analysis.segments.slice(0, -1), record);
        }
    
        if (config.id) {
            Hoek.assert(!this.ids[config.id], 'Route id', config.id, 'for path', config.path, 'conflicts with existing path', this.ids[config.id] && this.ids[config.id].path);
            this.ids[config.id] = record;
        }
    
        return record;
    };
    
    
    internals.Router.prototype.special = function (type, route) {
    
        Hoek.assert(Object.keys(this.specials).indexOf(type) !== -1, 'Unknown special route type:', type);
    
        this.specials[type] = { route: route };
    };
    
    
    internals.Router.prototype.route = function (method, path, hostname) {
    
        var segments = path.split('/').slice(1);
    
        var vhost = (this.vhosts && hostname && this.vhosts[hostname]);
        var route = (vhost && this._lookup(path, segments, vhost, method)) ||
                    this._lookup(path, segments, this.routes, method) ||
                    (method === 'head' && vhost && this._lookup(path, segments, vhost, 'get')) ||
                    (method === 'head' && this._lookup(path, segments, this.routes, 'get')) ||
                    (method === 'options' && this.specials.options) ||
                    (vhost && this._lookup(path, segments, vhost, '*')) ||
                    this._lookup(path, segments, this.routes, '*') ||
                    this.specials.notFound || Boom.notFound();
    
        return route;
    };
    
    
    internals.Router.prototype._lookup = function (path, segments, table, method) {
    
        var set = table[method];
        if (!set) {
            return null;
        }
    
        var match = set.router.lookup(path, segments, this.settings);
        if (!match) {
            return null;
        }
    
        var assignments = {};
        var array = [];
        for (var i = 0, il = match.array.length; i < il; ++i) {
            var name = match.record.params[i];
            var value = match.array[i];
            if (value) {
                value = internals.decode(value);
                if (value.isBoom) {
                    return this.specials.badRequest || value;
                }
    
                if (assignments[name] !== undefined) {
                    assignments[name] += '/' + value;
                }
                else {
                    assignments[name] = value;
                }
    
                if (i + 1 === il ||
                    name !== match.record.params[i + 1]) {
    
                    array.push(assignments[name]);
                }
            }
        }
    
        return { params: assignments, paramsArray: array, route: match.record.route };
    };
    
    
    internals.decode = function (value) {
    
        try {
            return decodeURIComponent(value);
        }
        catch (err) {
            return Boom.badRequest('Invalid request path');
        }
    };
    
    
    internals.Router.prototype.normalize = function (path) {
    
        if (path &&
            path.indexOf('%') !== -1) {
    
            // Uppercase %encoded values
    
            var uppercase = path.replace(/%[0-9a-fA-F][0-9a-fA-F]/g, function (encoded) {
    
                return encoded.toUpperCase();
            });
    
            // Decode non-reserved path characters: a-z A-Z 0-9 _!$&'()*+,;=:@-.~
            // ! (%21) $ (%24) & (%26) ' (%27) ( (%28) ) (%29) * (%2A) + (%2B) , (%2C) - (%2D) . (%2E)
            // 0-9 (%30-39) : (%3A) ; (%3B) = (%3D)
            // @ (%40) A-Z (%41-5A) _ (%5F) a-z (%61-7A) ~ (%7E)
    
            var decoded = uppercase.replace(/%(?:2[146-9A-E]|3[\dABD]|4[\dA-F]|5[\dAF]|6[1-9A-F]|7[\dAE])/g, function (encoded) {
    
                return String.fromCharCode(parseInt(encoded.substring(1), 16));
            });
    
            path = decoded;
        }
    
        return path;
    };
    
    
    internals.Router.prototype.analyze = function (path) {
    
        Hoek.assert(internals.pathRegex.validatePath.test(path), 'Invalid path:', path);
        Hoek.assert(!internals.pathRegex.validatePathEncoded.test(path), 'Path cannot contain encoded non-reserved path characters:', path);
    
        var pathParts = path.split('/');
        var segments = [];
        var params = [];
        var fingers = [];
    
        for (var i = 1, il = pathParts.length; i < il; ++i) {                            // Skip first empty segment
            var segment = pathParts[i];
    
            // Literal
    
            if (segment.indexOf('{') === -1) {
                segment = this.settings.isCaseSensitive ? segment : segment.toLowerCase();
                fingers.push(segment);
                segments.push({ literal: segment });
                continue;
            }
    
            // Parameter
    
            var parts = internals.parseParams(segment);
            if (parts.length === 1) {
    
                // Simple parameter
    
                var item = parts[0];
                Hoek.assert(params.indexOf(item.name) === -1, 'Cannot repeat the same parameter name:', item.name, 'in:', path);
                params.push(item.name);
    
                if (item.wilcard) {
                    if (item.count) {
                        for (var m = 0; m < item.count; ++m) {
                            fingers.push('?');
                            segments.push({});
                            if (m) {
                                params.push(item.name);
                            }
                        }
                    }
                    else {
                        fingers.push('#');
                        segments.push({ wildcard: true });
                    }
                }
                else {
                    fingers.push('?');
                    segments.push({ empty: item.empty });
                }
            }
            else {
    
                // Mixed parameter
    
                var seg = {
                    length: parts.length,
                    first: typeof parts[0] !== 'string',
                    segments: []
                };
    
                var finger = '';
                var regex = '^';
                for (var p = 0, pl = parts.length; p < pl; ++p) {
                    var part = parts[p];
                    if (typeof part === 'string') {
                        finger += part;
                        regex += Hoek.escapeRegex(part);
                        seg.segments.push(part);
                    }
                    else {
                        Hoek.assert(params.indexOf(part.name) === -1, 'Cannot repeat the same parameter name:', part.name, 'in:', path);
                        params.push(part.name);
    
                        finger += '?';
                        regex += '(.' + (part.empty ? '*' : '+') + ')';
                    }
                }
    
                seg.mixed = new RegExp(regex + '$', (!this.settings.isCaseSensitive ? 'i' : ''));
                fingers.push(finger);
                segments.push(seg);
            }
        }
    
        return {
            segments: segments,
            fingerprint: '/' + fingers.join('/'),
            params: params
        };
    };
    
    
    internals.parseParams = function (segment) {
    
        var parts = [];
        segment.replace(internals.pathRegex.parseParam, function (match, literal, name, wilcard, count, empty) {
    
            if (literal) {
                parts.push(literal);
            }
            else {
                parts.push({
                    name: name,
                    wilcard: !!wilcard,
                    count: count && parseInt(count, 10),
                    empty: !!empty
                });
            }
    
            return '';
        });
    
        return parts;
    };
    
    
    internals.Router.prototype.table = function (host) {
    
        var result = [];
        var collect = function (table) {
    
            if (!table) {
                return;
            }
    
            Object.keys(table).forEach(function (method) {
    
                table[method].routes.forEach(function (record) {
    
                    result.push(record.route);
                });
            });
        };
    
        if (this.vhosts) {
            var vhosts = host ? [].concat(host) : Object.keys(this.vhosts);
            for (var i = 0, il = vhosts.length; i < il; ++i) {
                collect(this.vhosts[vhosts[i]]);
            }
        }
    
        collect(this.routes);
    
        return result;
    };
    
    
    internals.sort = function (a, b) {
    
        var aFirst = -1;
        var bFirst = 1;
    
        var as = a.segments;
        var bs = b.segments;
    
        if (as.length !== bs.length) {
            return (as.length > bs.length ? bFirst : aFirst);
        }
    
        for (var i = 0, il = as.length; ; ++i) {
            if (as[i].literal) {
                if (bs[i].literal) {
                    if (as[i].literal === bs[i].literal) {
                        continue;
                    }
    
                    return (as[i].literal > bs[i].literal ? bFirst : aFirst);
                }
                return aFirst;
            }
            else if (bs[i].literal) {
                return bFirst;
            }
    
            return (as[i].wildcard ? bFirst : aFirst);
        }
    };
    
  provide("call", module.exports);
}(global));

// pakmanager:catbox/lib/client
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Hoek = require('hoek');
    var Boom = require('boom');
    
    
    // Declare internals
    
    var internals = {};
    
    
    internals.defaults = {
        partition: 'catbox'
    };
    
    
    module.exports = internals.Client = function (engine, options) {
    
        Hoek.assert(this.constructor === internals.Client, 'Cache client must be instantiated using new');
        Hoek.assert(engine, 'Missing catbox client engine');
        Hoek.assert(typeof engine === 'object' || typeof engine === 'function', 'engine must be an engine object or engine prototype (function)');
        Hoek.assert(typeof engine === 'function' || !options, 'Can only specify options with function engine config');
    
        var settings = Hoek.applyToDefaults(internals.defaults, options || {});
        Hoek.assert(settings.partition.match(/^[\w\-]+$/), 'Invalid partition name:' + settings.partition);
    
        this.connection = (typeof engine === 'object' ? engine : new engine(settings));
    };
    
    
    internals.Client.prototype.stop = function () {
    
        this.connection.stop();
    };
    
    
    internals.Client.prototype.start = function (callback) {
    
        this.connection.start(callback);
    };
    
    
    internals.Client.prototype.isReady = function () {
    
        return this.connection.isReady();
    };
    
    
    internals.Client.prototype.validateSegmentName = function (name) {
    
        return this.connection.validateSegmentName(name);
    };
    
    
    internals.Client.prototype.get = function (key, callback) {
    
        var self = this;
    
        if (!this.connection.isReady()) {
            // Disconnected
            return callback(Boom.internal('Disconnected'));
        }
    
        if (!key) {
            // Not found on null
            return callback(null, null);
        }
    
        if (!internals.validateKey(key)) {
            return callback(Boom.internal('Invalid key'));
        }
    
        this.connection.get(key, function (err, result) {
    
            if (err) {
                // Connection error
                return callback(err);
            }
    
            if (!result ||
                result.item === undefined ||
                result.item === null) {
    
                // Not found
                return callback(null, null);
            }
    
            var now = Date.now();
            var expires = result.stored + result.ttl;
            var ttl = expires - now;
            if (ttl <= 0) {
                // Expired
                return callback(null, null);
            }
    
            // Valid
    
            var cached = {
                item: result.item,
                stored: result.stored,
                ttl: ttl
            };
    
            return callback(null, cached);
        });
    };
    
    
    internals.Client.prototype.set = function (key, value, ttl, callback) {
    
        if (!this.connection.isReady()) {
            // Disconnected
            return callback(Boom.internal('Disconnected'));
        }
    
        if (!internals.validateKey(key)) {
            return callback(Boom.internal('Invalid key'));
        }
    
        if (ttl <= 0) {
            // Not cachable (or bad rules)
            return callback();
        }
    
        this.connection.set(key, value, ttl, callback);
    };
    
    
    internals.Client.prototype.drop = function (key, callback) {
    
        if (!this.connection.isReady()) {
            // Disconnected
            return callback(Boom.internal('Disconnected'));
        }
    
        if (!internals.validateKey(key)) {
            return callback(Boom.internal('Invalid key'));
        }
    
        this.connection.drop(key, callback);           // Always drop, regardless of caching rules
    };
    
    
    internals.validateKey = function (key) {
    
        return (key && typeof key.id === 'string' && key.segment && typeof key.segment === 'string');
    };
    
  provide("catbox/lib/client", module.exports);
}(global));

// pakmanager:catbox/lib/policy
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Boom = require('boom');
    var Hoek = require('hoek');
    var Joi = require('joi');
    
    
    // Declare internals
    
    var internals = {
        day: 24 * 60 * 60 * 1000
    };
    
    
    exports = module.exports = internals.Policy = function (options, cache, segment) {
    
        Hoek.assert(this.constructor === internals.Policy, 'Cache Policy must be instantiated using new');
    
        this._cache = cache;
        this._pendings = {};                                        // id -> [callbacks]
        this.rules(options);
    
        if (cache) {
            var nameErr = cache.validateSegmentName(segment);
            Hoek.assert(nameErr === null, 'Invalid segment name: ' + segment + (nameErr ? ' (' + nameErr.message + ')' : ''));
    
            this._segment = segment;
        }
    };
    
    
    internals.Policy.prototype.rules = function (options) {
    
        this.rule = internals.Policy.compile(options, !!this._cache);
    };
    
    
    internals.Policy.prototype.get = function (key, callback) {     // key: string or { id: 'id' }
    
        var self = this;
    
        // Check if request is already pending
    
        var id = (key && typeof key === 'object') ? key.id : key;
        var pendingsId = '+' + id;                                  // Prefix to avoid conflicts with JS internals (e.g. __proto__)
        if (this._pendings[pendingsId]) {
            this._pendings[pendingsId].push(callback);
            return;
        }
    
        this._pendings[pendingsId] = [callback];
    
        // Lookup in cache
    
        var timer = new Hoek.Timer();
        this._get(id, function (err, cached) {
    
            // Prepare report
    
            var report = {
                msec: timer.elapsed(),
                error: err
            };
    
            if (cached) {
                report.stored = cached.stored;
                report.ttl = cached.ttl;
                var staleIn = typeof self.rule.staleIn === 'function' ? self.rule.staleIn(cached.stored, cached.ttl) : self.rule.staleIn;
                cached.isStale = (staleIn ? (Date.now() - cached.stored) >= staleIn : false);
                report.isStale = cached.isStale;
            }
    
            // No generate method
    
            if (!self.rule.generateFunc) {
                return self._finalize(id, err, cached ? cached.item : null, cached, report);
            }
    
            // Error / Not found
    
            if (err ||
                !cached) {
    
                return self._generate(id, key, null, report, callback);
            }
    
            // Check if found and fresh
    
            if (!cached.isStale) {
                return self._finalize(id, null, cached.item, cached, report);
            }
    
            return self._generate(id, key, cached, report, callback);
        });
    };
    
    
    internals.Policy.prototype._get = function (id, callback) {
    
        if (!this._cache) {
            return Hoek.nextTick(callback)(null, null);
        }
    
        this._cache.get({ segment: this._segment, id: id }, callback);
    };
    
    
    internals.Policy.prototype._generate = function (id, key, cached, report, callback) {
    
        var self = this;
    
        var finalize = Hoek.once(function (id, err, value, cached, report) {
    
            return self._finalize(id, err, value, cached, report);
        });
    
        if (cached) {                                       // Must be stale
    
            // Set stale timeout
    
            cached.ttl -= this.rule.staleTimeout;           // Adjust TTL for when the timeout is invoked (staleTimeout must be valid if isStale is true)
            if (cached.ttl > 0) {
                setTimeout(function () {
    
                    return finalize(id, null, cached.item, cached, report);
                }, this.rule.staleTimeout);
            }
        }
        else if (this.rule.generateTimeout) {
    
            // Set item generation timeout (when not in cache)
    
            setTimeout(function () {
    
                return finalize(id, Boom.serverTimeout(), null, null, report);
            }, this.rule.generateTimeout);
        }
    
        // Generate new value
    
        try {
            this.rule.generateFunc.call(null, key, function (err, value, ttl) {
    
                // Error (if dropOnError is not set to false) or not cached
    
                if ((err && self.rule.dropOnError) ||
                    ttl === 0) {                                    // null or undefined means use policy
    
                    self.drop(id);                                  // Invalidate cache
                }
                else if (!err) {
                    self.set(id, value, ttl);                       // Lazy save (replaces stale cache copy with late-coming fresh copy)
                }
    
                if (cached &&
                    err &&
                    !self.rule.dropOnError) {
    
                    return finalize(id, err, cached.item, cached, report);
                }
    
                return finalize(id, err, value, null, report);      // Ignored if stale value already returned
            });
        }
        catch (err) {
            return finalize(id, err, null, null, report);
        }
    };
    
    
    internals.Policy.prototype._finalize = function (id, err, value, cached, report) {
    
        id = '+' + id;
        var pendings = this._pendings[id];
        delete this._pendings[id];
    
        for (var i = 0, il = pendings.length; i < il; ++i) {
            Hoek.nextTick(pendings[i])(err, value, cached, report);
        }
    };
    
    
    internals.Policy.prototype.set = function (key, value, ttl, callback) {
    
        callback = callback || Hoek.ignore;
    
        if (!this._cache) {
            return callback(null);
        }
    
        ttl = ttl || internals.Policy.ttl(this.rule);
        var id = (key && typeof key === 'object') ? key.id : key;
        this._cache.set({ segment: this._segment, id: id }, value, ttl, callback);
    };
    
    
    internals.Policy.prototype.drop = function (id, callback) {
    
        callback = callback || Hoek.ignore;
    
        if (!this._cache) {
            return callback(null);
        }
    
        this._cache.drop({ segment: this._segment, id: id }, callback);
    };
    
    
    internals.Policy.prototype.ttl = function (created) {
    
        return internals.Policy.ttl(this.rule, created);
    };
    
    
    internals.schema = Joi.object({
        expiresIn: Joi.number().integer().min(1),
        expiresAt: Joi.string().regex(/^\d\d?\:\d\d$/),
        staleIn: [Joi.number().integer().min(1).max(86400000 - 1), Joi.func()],               // One day - 1 (max is inclusive)
        staleTimeout: Joi.number().integer().min(1),
        generateFunc: Joi.func(),
        generateTimeout: Joi.number().integer().min(1),
        dropOnError: Joi.boolean(),
    
        // Ignored external keys (hapi)
    
        privacy: Joi.any(),
        cache: Joi.any(),
        segment: Joi.any(),
        shared: Joi.any()
    })
        .without('expiresIn', 'expiresAt')
        .with('staleIn', 'generateFunc')
        .with('generateTimeout', 'generateFunc')
        .with('dropOnError', 'generateFunc')
        .and('staleIn', 'staleTimeout');
    
    
    internals.Policy.compile = function (options, serverSide) {
    
        /*
            {
                expiresIn: 30000,
                expiresAt: '13:00',
    
                generateFunc: function (id, next) { next(err, result, ttl); }
                generateTimeout: 500,
                staleIn: 20000,
                staleTimeout: 500,
                dropOnError: true
            }
         */
    
        var rule = {};
    
        if (!options ||
            !Object.keys(options).length) {
    
            return rule;
        }
    
        // Validate rule
    
        Joi.assert(options, internals.schema, 'Invalid cache policy configuration');
    
        var hasExpiresIn = options.expiresIn !== undefined && options.expiresIn !== null;
        var hasExpiresAt = options.expiresAt !== undefined && options.expiresAt !== null;
    
        Hoek.assert(!hasExpiresAt || typeof options.expiresAt === 'string', 'expiresAt must be a string', options);
        Hoek.assert(!hasExpiresIn || Hoek.isInteger(options.expiresIn), 'expiresIn must be an integer', options);
        Hoek.assert(!hasExpiresIn || !options.staleIn || typeof options.staleIn === 'function' || options.staleIn < options.expiresIn, 'staleIn must be less than expiresIn');
        Hoek.assert(!options.staleIn || serverSide, 'Cannot use stale options without server-side caching');
        Hoek.assert(!options.staleTimeout || !hasExpiresIn || options.staleTimeout < options.expiresIn, 'staleTimeout must be less than expiresIn');
        Hoek.assert(!options.staleTimeout || !hasExpiresIn || typeof options.staleIn === 'function' || options.staleTimeout < (options.expiresIn - options.staleIn), 'staleTimeout must be less than the delta between expiresIn and staleIn');
    
        // Expiration
    
        if (hasExpiresAt) {
    
            // expiresAt
    
            var time = /^(\d\d?):(\d\d)$/.exec(options.expiresAt);
            rule.expiresAt = {
                hours: parseInt(time[1], 10),
                minutes: parseInt(time[2], 10)
            };
        }
        else {
    
            // expiresIn
    
            rule.expiresIn = options.expiresIn || 0;
        }
    
        // generateTimeout
    
        if (options.generateFunc) {
            rule.generateFunc = options.generateFunc;
            rule.generateTimeout = options.generateTimeout;
    
            // Stale
    
            if (options.staleIn) {
                rule.staleIn = options.staleIn;
                rule.staleTimeout = options.staleTimeout;
            }
    
            rule.dropOnError = options.dropOnError !== undefined ? options.dropOnError : true;      // Defaults to true
        }
    
        return rule;
    };
    
    
    internals.Policy.ttl = function (rule, created, now) {
    
        now = now || Date.now();
        created = created || now;
        var age = now - created;
    
        if (age < 0) {
            return 0;                                                                   // Created in the future, assume expired/bad
        }
    
        if (rule.expiresIn) {
            return Math.max(rule.expiresIn - age, 0);
        }
    
        if (rule.expiresAt) {
            if (age > internals.day) {                                                  // If the item was created more than a 24 hours ago
                return 0;
            }
    
            var expiresAt = new Date(created);                                          // Compare expiration time on the same day
            expiresAt.setHours(rule.expiresAt.hours);
            expiresAt.setMinutes(rule.expiresAt.minutes);
            expiresAt.setSeconds(0);
            expiresAt.setMilliseconds(0);
            var expires = expiresAt.getTime();
    
            if (expires <= created) {
                expires += internals.day;                                               // Move to tomorrow
            }
    
            if (now >= expires) {                                                       // Expired
                return 0;
            }
    
            return expires - now;
        }
    
        return 0;                                                                       // No rule
    };
    
    
    internals.Policy.prototype.isReady = function () {
    
        if (!this._cache) {
            return false;
        }
    
        return this._cache.connection.isReady();
    };
    
  provide("catbox/lib/policy", module.exports);
}(global));

// pakmanager:catbox
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Client =  require('catbox/lib/client');
    var Policy =  require('catbox/lib/policy');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.Client = Client;
    exports.Policy = exports.policy = Policy;
    
  provide("catbox", module.exports);
}(global));

// pakmanager:catbox-memory/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    
    internals.defaults = {
        maxByteSize: 100 * 1024 * 1024,          // 100MB
        allowMixedContent: false
    };
    
    // Provides a named reference for memory debugging
    internals.MemoryCacheSegment = function MemoryCacheSegment () {
    };
    
    internals.MemoryCacheEntry = function MemoryCacheEntry (key, value, ttl, allowMixedContent) {
    
        var valueByteSize = 0;
    
        if (allowMixedContent && Buffer.isBuffer(value)) {
            this.item = new Buffer(value.length);
            // copy buffer to prevent value from changing while in the cache
            value.copy(this.item);
            valueByteSize = this.item.length;
        }
        else {
            // stringify() to prevent value from changing while in the cache
            this.item = JSON.stringify(value);
            valueByteSize = Buffer.byteLength(this.item);
        }
    
        this.stored = Date.now();
        this.ttl = ttl;
    
        // Approximate cache entry size without value: 144 bytes
        this.byteSize = 144 + valueByteSize + Buffer.byteLength(key.segment) + Buffer.byteLength(key.id);
    
        this.timeoutId = null;
    };
    
    
    exports = module.exports = internals.Connection = function MemoryCache (options) {
    
        Hoek.assert(this.constructor === internals.Connection, 'Memory cache client must be instantiated using new');
        Hoek.assert(!options || options.maxByteSize === undefined || options.maxByteSize >= 0, 'Invalid cache maxByteSize value');
        Hoek.assert(!options || options.allowMixedContent === undefined || typeof options.allowMixedContent === 'boolean', 'Invalid allowMixedContent value');
    
        this.settings = Hoek.applyToDefaults(internals.defaults, options || {});
        this.cache = null;
    };
    
    
    internals.Connection.prototype.start = function (callback) {
    
        callback = Hoek.nextTick(callback);
    
        if (!this.cache) {
            this.cache = {};
            this.byteSize = 0;
        }
    
        return callback();
    };
    
    
    internals.Connection.prototype.stop = function () {
    
        this.cache = null;
        this.byteSize = 0;
        return;
    };
    
    
    internals.Connection.prototype.isReady = function () {
    
        return (!!this.cache);
    };
    
    
    internals.Connection.prototype.validateSegmentName = function (name) {
    
        if (!name) {
            return new Error('Empty string');
        }
    
        if (name.indexOf('\0') !== -1) {
            return new Error('Includes null character');
        }
    
        return null;
    };
    
    
    internals.Connection.prototype.get = function (key, callback) {
    
        callback = Hoek.nextTick(callback);
    
        if (!this.cache) {
            return callback(new Error('Connection not started'));
        }
    
        var segment = this.cache[key.segment];
        if (!segment) {
            return callback(null, null);
        }
    
        var envelope = segment[key.id];
        if (!envelope) {
            return callback(null, null);
        }
    
        var value = null;
    
        if (Buffer.isBuffer(envelope.item)) {
            value = envelope.item;
        }
        else {
            value = internals.parseJSON(envelope.item);
    
            if (value instanceof Error) {
                return callback(new Error('Bad value content'));
            }
        }
    
        var result = {
            item: value,
            stored: envelope.stored,
            ttl: envelope.ttl
        };
    
        return callback(null, result);
    };
    
    
    internals.Connection.prototype.set = function (key, value, ttl, callback) {
    
        var self = this;
    
        callback = Hoek.nextTick(callback);
    
        if (!this.cache) {
            return callback(new Error('Connection not started'));
        }
    
        if (ttl > 2147483647) {                                                         // Math.pow(2, 31)
            return callback(new Error('Invalid ttl (greater than 2147483647)'));
        }
    
        var envelope = null;
        try {
            envelope = new internals.MemoryCacheEntry(key, value, ttl, this.settings.allowMixedContent);
        } catch (err) {
            return callback(err);
        }
    
        this.cache[key.segment] = this.cache[key.segment] || new internals.MemoryCacheSegment();
        var segment = this.cache[key.segment];
    
        var cachedItem = segment[key.id];
        if (cachedItem &&
            cachedItem.timeoutId) {
    
            clearTimeout(cachedItem.timeoutId);
            self.byteSize -= cachedItem.byteSize;                   // If the item existed, decrement the byteSize as the value could be different
        }
    
        if (this.settings.maxByteSize) {
            if (self.byteSize + envelope.byteSize > this.settings.maxByteSize) {
                return callback(new Error('Cache size limit reached'));
            }
        }
    
        var timeoutId = setTimeout(function () {
    
            self.drop(key, function () { });
        }, ttl);
    
        envelope.timeoutId = timeoutId;
    
        segment[key.id] = envelope;
        this.byteSize += envelope.byteSize;
    
        return callback(null);
    };
    
    
    internals.Connection.prototype.drop = function (key, callback) {
    
        callback = Hoek.nextTick(callback);
    
        if (!this.cache) {
            return callback(new Error('Connection not started'));
        }
    
        var segment = this.cache[key.segment];
        if (segment) {
            var item = segment[key.id];
    
            if (item) {
                this.byteSize -= item.byteSize;
            }
    
            delete segment[key.id];
        }
    
        return callback();
    };
    
    
    internals.parseJSON = function (json) {
    
        var obj = null;
    
        try {
            obj = JSON.parse(json);
        }
        catch (err) {
            obj = err;
        }
    
        return obj;
    };
    
  provide("catbox-memory/lib", module.exports);
}(global));

// pakmanager:catbox-memory
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('catbox-memory/lib');
  provide("catbox-memory", module.exports);
}(global));

// pakmanager:h2o2
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Http = require('http');
    var Https = require('https');
    var Hoek = require('hoek');
    var Joi = require('joi');
    var Wreck = require('wreck');
    
    
    // Declare internals
    
    var internals = {
        agents: {}                                      // server.info.uri -> { http, https, insecure }
    };
    
    
    internals.defaults = {
        xforward: false,
        passThrough: false,
        redirects: false,
        timeout: 1000 * 60 * 3,                         // Timeout request after 3 minutes
        localStatePassThrough: false,                   // Pass cookies defined by the server upstream
        maxSockets: Infinity
    };
    
    
    internals.schema = Joi.object({
        host: Joi.string(),
        port: Joi.number().integer(),
        protocol: Joi.string().valid('http', 'https', 'http:', 'https:'),
        uri: Joi.string(),
        passThrough: Joi.boolean(),
        localStatePassThrough: Joi.boolean(),
        acceptEncoding: Joi.boolean().when('passThrough', { is: true, otherwise: Joi.forbidden() }),
        rejectUnauthorized: Joi.boolean(),
        xforward: Joi.boolean(),
        redirects: Joi.number().min(0).integer().allow(false),
        timeout: Joi.number().integer(),
        mapUri: Joi.func(),
        onResponse: Joi.func(),
        agent: Joi.object(),
        ttl: Joi.string().valid('upstream').allow(null),
        maxSockets: Joi.number().positive().allow(false)
    })
        .xor('host', 'mapUri', 'uri')
        .without('mapUri', 'port', 'protocol')
        .without('uri', 'port', 'protocol');
    
    
    exports.register = function (server, options, next) {
    
        server.handler('proxy', internals.handler);
    
        server.decorate('reply', 'proxy', function (options) {
    
            internals.handler(this.request.route, options)(this.request, this);
        });
    
        return next();
    };
    
    exports.register.attributes = {
        pkg: require('../package.json')
    };
    
    
    internals.handler = function (route, options) {
    
        Joi.assert(options, internals.schema, 'Invalid proxy handler options (' + route.path + ')');
        Hoek.assert(!route.settings.payload || ((route.settings.payload.output === 'data' || route.settings.payload.output === 'stream') && !route.settings.payload.parse), 'Cannot proxy if payload is parsed or if output is not stream or data');
        var settings = Hoek.applyToDefaultsWithShallow(internals.defaults, options, ['agent']);
        settings.mapUri = options.mapUri || internals.mapUri(options.protocol, options.host, options.port, options.uri);
    
        if (settings.ttl === 'upstream') {
            settings._upstreamTtl = true;
        }
    
        return function (request, reply) {
    
            settings.mapUri(request, function (err, uri, headers) {
    
                if (err) {
                    return reply(err);
                }
    
                var protocol = uri.split(':', 1)[0];
    
                var options = {
                    headers: {},
                    payload: request.payload,
                    redirects: settings.redirects,
                    timeout: settings.timeout,
                    agent: internals.agent(protocol, settings, request.connection)
                };
    
                var bind = request.route.settings.bind;
    
                if (settings.passThrough) {
                    options.headers = Hoek.clone(request.headers);
                    delete options.headers.host;
    
                    if (settings.acceptEncoding === false) {                    // Defaults to true
                        delete options.headers['accept-encoding'];
                    }
    
                    if (options.headers.cookie) {
                        delete options.headers.cookie;
    
                        var cookieHeader = request.connection.states.passThrough(request.headers.cookie, settings.localStatePassThrough);
                        if (cookieHeader) {
                            if (typeof cookieHeader !== 'string') {
                                return reply(cookieHeader);                     // Error
                            }
    
                            options.headers.cookie = cookieHeader;
                        }
                    }
                }
    
                if (headers) {
                    Hoek.merge(options.headers, headers);
                }
    
                if (settings.xforward &&
                    request.info.remoteAddress &&
                    request.info.remotePort) {
    
                    options.headers['x-forwarded-for'] = (options.headers['x-forwarded-for'] ? options.headers['x-forwarded-for'] + ',' : '') + request.info.remoteAddress;
                    options.headers['x-forwarded-port'] = (options.headers['x-forwarded-port'] ? options.headers['x-forwarded-port'] + ',' : '') + request.info.remotePort;
                    options.headers['x-forwarded-proto'] = (options.headers['x-forwarded-proto'] ? options.headers['x-forwarded-proto'] + ',' : '') + protocol;
                }
    
                var contentType = request.headers['content-type'];
                if (contentType) {
                    options.headers['content-type'] = contentType;
                }
    
                // Send request
    
                Wreck.request(request.method, uri, options, function (err, res) {
    
                    var ttl = null;
    
                    if (err) {
                        if (settings.onResponse) {
                            return settings.onResponse.call(bind, err, res, request, reply, settings, ttl);
                        }
    
                        return reply(err);
                    }
    
                    if (settings._upstreamTtl) {
                        var cacheControlHeader = res.headers['cache-control'];
                        if (cacheControlHeader) {
                            var cacheControl = Wreck.parseCacheControl(cacheControlHeader);
                            if (cacheControl) {
                                ttl = cacheControl['max-age'] * 1000;
                            }
                        }
                    }
    
                    if (settings.onResponse) {
                        return settings.onResponse.call(bind, null, res, request, reply, settings, ttl);
                    }
    
                    var response = reply(res)
                        .ttl(ttl)
                        .code(res.statusCode)
                        .passThrough(!!settings.passThrough);   // Default to false
                });
            });
        };
    };
    
    
    internals.handler.defaults = function (method) {
    
        var payload = method !== 'get' && method !== 'head';
        return payload ? {
            payload: {
                output: 'stream',
                parse: false
            }
        } : null;
    };
    
    
    internals.mapUri = function (protocol, host, port, uri) {
    
        if (uri) {
            return function (request, next) {
    
                if (uri.indexOf('{') === -1) {
                    return next(null, uri);
                }
    
                var address = uri.replace(/{protocol}/g, request.connection.info.protocol)
                                 .replace(/{host}/g, request.connection.info.host)
                                 .replace(/{port}/g, request.connection.info.port)
                                 .replace(/{path}/g, request.url.path);
    
                return next(null, address);
            };
        }
    
        if (protocol &&
            protocol[protocol.length - 1] !== ':') {
    
            protocol += ':';
        }
    
        protocol = protocol || 'http:';
        port = port || (protocol === 'http:' ? 80 : 443);
        var baseUrl = protocol + '//' + host + ':' + port;
    
        return function (request, next) {
    
            return next(null, baseUrl + request.path + (request.url.search || ''));
        };
    };
    
    
    internals.agent = function (protocol, settings, connection) {
    
        if (settings.agent) {
            return settings.agent;
        }
    
        if (settings.maxSockets === false) {
            return undefined;
        }
    
        internals.agents[connection.info.uri] = internals.agents[connection.info.uri] || {};
        var agents = internals.agents[connection.info.uri];
    
        var type = (protocol === 'http' ? 'http' : (settings.rejectUnauthorized === false ? 'insecure' : 'https'));
        if (!agents[type]) {
            agents[type] = (type === 'http' ? new Http.Agent() : (type === 'https' ? new Https.Agent() : new Https.Agent({ rejectUnauthorized: false })));
            agents[type].maxSockets = settings.maxSockets;
        }
    
        return agents[type];
    };
    
  provide("h2o2", module.exports);
}(global));

// pakmanager:heavy/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Boom = require('boom');
    var Hoek = require('hoek');
    var Joi = require('joi');
    
    
    // Declare internals
    
    var internals = {};
    
    
    internals.schema = {
        process: Joi.object({
            sampleInterval: Joi.number().min(0)
        }),
        policy: Joi.object({
            maxHeapUsedBytes: Joi.number().min(0),
            maxEventLoopDelay: Joi.number().min(0),
            maxRssBytes: Joi.number().min(0)
        })
    };
    
    
    internals.defaults = {
        process: {
            sampleInterval: 0                           // Frequency of load sampling in milliseconds (zero is no sampling)
        },
        policy: {
            maxHeapUsedBytes: 0,                        // Reject requests when V8 heap is over size in bytes (zero is no max)
            maxRssBytes: 0,                             // Reject requests when process RSS is over size in bytes (zero is no max)
            maxEventLoopDelay: 0                        // Milliseconds of delay after which requests are rejected (zero is no max)
        }
    };
    
    
    exports = module.exports = internals.Heavy = function (options) {
    
        options = options || {};
    
        Joi.assert(options, internals.schema.process, 'Invalid load monitoring options');
        this.settings = Hoek.applyToDefaults(internals.defaults, options);
    
        this._eventLoopTimer = null;
        this._loadBench = new Hoek.Bench();
        this.load = {
            eventLoopDelay: 0,
            heapUsed: 0,
            rss: 0
        };
    };
    
    
    internals.Heavy.prototype.start = function () {
    
        var self = this;
    
        if (!this.settings.sampleInterval) {
            return;
        }
    
        var loopSample = function () {
    
            self._loadBench.reset();
            var measure = function () {
    
                var mem = process.memoryUsage();
    
                // Retain the same this.load object to keep external references valid
    
                self.load.eventLoopDelay = (self._loadBench.elapsed() - self.settings.sampleInterval);
                self.load.heapUsed = mem.heapUsed;
                self.load.rss = mem.rss;
    
                loopSample();
            };
    
            self._eventLoopTimer = setTimeout(measure, self.settings.sampleInterval);
        };
    
        loopSample();
    };
    
    
    internals.Heavy.prototype.stop = function () {
    
        clearTimeout(this._eventLoopTimer);
        this._eventLoopTimer = null;
    };
    
    
    internals.Heavy.prototype.policy = function (options) {
    
        return new internals.Policy(this, options);
    };
    
    
    internals.Policy = function (process, options) {
    
        options = options || {};
    
        Joi.assert(options, internals.schema.policy, 'Invalid load monitoring options');
        Hoek.assert(process.settings.sampleInterval || (!options.maxEventLoopDelay && !options.maxHeapUsedBytes && !options.maxRssBytes), 'Load sample interval must be set to enable load limits');
    
        this._process = process;
        this.settings = Hoek.applyToDefaults(internals.defaults.policy, options);
    };
    
    
    internals.Policy.prototype.check = function () {
    
        if (!this._process.settings.sampleInterval) {
            return null;
        }
    
        Hoek.assert(this._process._eventLoopTimer, 'Cannot check load when sampler is not started');
    
        var elapsed = this._process._loadBench.elapsed();
        var load = this._process.load;
    
        if (elapsed > this._process.settings.sampleInterval) {
            load.eventLoopDelay = Math.max(load.eventLoopDelay, elapsed - this._process.settings.sampleInterval);
        }
    
        if (this.settings.maxEventLoopDelay &&
            load.eventLoopDelay > this.settings.maxEventLoopDelay) {
    
            return Boom.serverTimeout('Server under heavy load (event loop)', load);
        }
    
        if (this.settings.maxHeapUsedBytes &&
            load.heapUsed > this.settings.maxHeapUsedBytes) {
    
            return Boom.serverTimeout('Server under heavy load (heap)', load);
        }
    
        if (this.settings.maxRssBytes &&
            load.rss > this.settings.maxRssBytes) {
    
            return Boom.serverTimeout('Server under heavy load (rss)', load);
        }
    
        return null;
    };
    
  provide("heavy/lib", module.exports);
}(global));

// pakmanager:heavy
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('heavy/lib');
    
  provide("heavy", module.exports);
}(global));

// pakmanager:inert/lib/file
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Fs = require('fs');
    var Path = require('path');
    var Crypto = require('crypto');
    var Ammo = require('ammo');
    var Boom = require('boom');
    var Hoek = require('hoek');
    var Joi = require('joi');
    var LruCache = require('lru-cache');
    
    
    // Declare internals
    
    var internals = {};
    
    
    internals.schema = Joi.alternatives([
        Joi.string(),
        Joi.func(),
        Joi.object({
            path: Joi.alternatives(Joi.string(), Joi.func()).required(),
            filename: Joi.string(),
            mode: Joi.string().valid('attachment', 'inline').allow(false),
            lookupCompressed: Joi.boolean()
        })
            .with('filename', 'mode')
    ]);
    
    
    exports.handler = function (route, options) {
    
        Joi.assert(options, internals.schema, 'Invalid file handler options (' + route.path + ')');
        var settings = (typeof options !== 'object' ? { path: options } : Joi.validate(options, internals.schema).value);
        Hoek.assert(typeof settings.path !== 'string' || settings.path[settings.path.length - 1] !== '/', 'File path cannot end with a \'/\':', route.path);
    
        var handler = function (request, reply) {
    
            var path = (typeof settings.path === 'function' ? settings.path(request) : settings.path);
            return reply(exports.response(path, settings, request));
        };
    
        return handler;
    };
    
    
    exports.load = function (path, request, options, callback) {
    
        var response = exports.response(path, options, request);
        return internals.prepare(response, callback);
    };
    
    
    exports.response = function (path, options, request) {
    
        options = options || {};
        Hoek.assert(!options.mode || ['attachment', 'inline'].indexOf(options.mode) !== -1, 'options.mode must be either false, attachment, or inline');
    
        var source = {
            path: Path.normalize(Hoek.isAbsolutePath(path) ? path : Path.join(request.route.settings.files.relativeTo, path)),
            settings: options,
            stat: null,
            fd: null
        };
    
        return request.generateResponse(source, { variety: 'file', marshal: internals.marshal, prepare: internals.prepare, close: internals.close });
    };
    
    
    internals.prepare = function (response, callback) {
    
        internals.close(response);                  // Close any leftover descriptors from previous prepare call
    
        var path = response.source.path;
        internals.openStat(path, 'r', function (err, fd, stat) {
    
            if (err) {
                return callback(err);
            }
    
            response.source.fd = fd;
            response.bytes(stat.size);
    
            if (!response.headers['content-type']) {
                response.type(response.request.server.mime.path(path).type || 'application/octet-stream');
            }
    
            response.header('last-modified', stat.mtime.toUTCString());
    
            var etags = response.request.server.plugins.inert._etags;
            if (etags) {
    
                // Use stat info for an LRU cache key.
    
                var cachekey = [path, stat.ino, stat.size, stat.mtime.getTime()].join('-');
    
                // The etag must hash the file contents in order to be consistent across distributed deployments
    
                var cachedEtag = etags.get(cachekey);
                if (cachedEtag) {
                    response.etag(cachedEtag, { vary: true });
                }
                else {
                    var hash = Crypto.createHash('sha1');
                    var processed = 0;
                    response.on('peek', function (chunk) {
    
                        hash.update(chunk);
                        processed += chunk.length;
                    });
    
                    response.once('finish', function () {
    
                        if (processed === stat.size) {
                            var etag = hash.digest('hex');
                            etags.set(cachekey, etag);
                        }
                    });
                }
            }
    
            if (response.source.settings.mode) {
                var fileName = response.source.settings.filename || Path.basename(path);
                response.header('content-disposition', response.source.settings.mode + '; filename=' + encodeURIComponent(fileName));
            }
    
            return callback(response);
        });
    };
    
    
    internals.marshal = function (response, next) {
    
        if (!response.source.settings.lookupCompressed ||
            response.request.info.acceptEncoding !== 'gzip') {
    
            return internals.openStream(response, response.source.path, next);
        }
    
        var gzFile = response.source.path + '.gz';
        internals.openStat(gzFile, 'r', function (err, fd, stat) {
    
            if (err) {
                return internals.openStream(response, response.source.path, next);
            }
    
            internals.close(response);
            response.source.fd = fd;
    
            response.bytes(stat.size);
            response.header('content-encoding', 'gzip');
            response.vary('accept-encoding');
    
            return internals.openStream(response, gzFile, next);
        });
    };
    
    
    internals.openStream = function (response, path, next) {
    
        Hoek.assert(response.source.fd !== null, 'file descriptor must be set');
    
        // Check for Range request
    
        var request = response.request;
        var length = response.headers['content-length'];
        var options = { fd: response.source.fd };
    
        if (request.headers.range && length) {
    
            // Check If-Range
    
            if (!request.headers['if-range'] ||
                request.headers['if-range'] === response.headers.etag) {            // Ignoring last-modified date (weak)
    
                // Parse header
    
                var ranges = Ammo.header(request.headers.range, length);
                if (!ranges) {
                    var error = Boom.rangeNotSatisfiable();
                    error.output.headers['content-range'] = 'bytes */' + length;
                    return next(error);
                }
    
                // Prepare transform
    
                if (ranges.length === 1) {                                          // Ignore requests for multiple ranges
                    var range = ranges[0];
                    response.code(206);
                    response.bytes(range.to - range.from + 1);
                    response._header('content-range', 'bytes ' + range.from + '-' + range.to + '/' + length);
    
                    options.start = range.from;
                    options.end = range.to;
                }
            }
        }
    
        response._header('accept-ranges', 'bytes');
    
        var fileStream = Fs.createReadStream(path, options);
        response.source.fd = null;              // Claim descriptor
        return next(null, fileStream);
    };
    
    
    internals.openStat = function (path, mode, callback) {
    
        Fs.open(path, mode, function (err, fd) {
    
            if (err) {
                if (path.indexOf('\u0000') !== -1 || err.code === 'ENOENT') {
                    return callback(Boom.notFound());
                }
    
                if (err.code === 'EACCES' || err.code === 'EPERM') {
                    return callback(Boom.forbidden(null, err.code));
                }
    
                return callback(Boom.wrap(err, null, 'Failed to open file'));
            }
    
            Fs.fstat(fd, function (err, stat) {
    
                if (err) {
                    Fs.close(fd, Hoek.ignore);
                    return callback(Boom.wrap(err, null, 'Failed to stat file'));
                }
    
                if (stat.isDirectory()) {
                    Fs.close(fd, Hoek.ignore);
                    return callback(Boom.forbidden(null, 'EISDIR'));
                }
    
                return callback(null, fd, stat);
            });
        });
    };
    
    
    internals.close = function (response) {
    
        if (response.source.fd !== null) {
            Fs.close(response.source.fd, Hoek.ignore);
            response.source.fd = null;
        }
    };
    
    
    exports.Etags = LruCache;
    
  provide("inert/lib/file", module.exports);
}(global));

// pakmanager:inert/lib/directory
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Fs = require('fs');
    var Path = require('path');
    var Boom = require('boom');
    var Hoek = require('hoek');
    var Items = require('items');
    var Joi = require('joi');
    var File =  require('inert/lib/file');
    
    
    // Declare internals
    
    var internals = {};
    
    
    internals.schema = Joi.object({
        path: Joi.alternatives(Joi.array().items(Joi.string()).single(), Joi.func()).required(),
        index: Joi.alternatives(Joi.boolean(), Joi.array().items(Joi.string()).single()).default(true),
        listing: Joi.boolean(),
        showHidden: Joi.boolean(),
        redirectToSlash: Joi.boolean(),
        lookupCompressed: Joi.boolean(),
        defaultExtension: Joi.string().alphanum()
    });
    
    
    exports.handler = function (route, options) {
    
        Joi.assert(options, internals.schema, 'Invalid directory handler options (' + route.path + ')');
        Hoek.assert(route.path[route.path.length - 1] === '}', 'The route path must end with a parameter:', route.path);
    
        var settings = Joi.validate(options, internals.schema).value;
    
        var normalize = function (paths) {
    
            var normalized = [];
            for (var i = 0, il = paths.length; i < il; ++i) {
                var path = paths[i];
    
                if (!Hoek.isAbsolutePath(path)) {
                    path = Path.join(route.settings.files.relativeTo, path);
                }
    
                normalized.push(path);
            }
    
            return normalized;
        };
    
        var normalized = (Array.isArray(settings.path) ? normalize(settings.path) : []);            // Array or function
    
        var indexNames = (settings.index === true) ? ['index.html'] : (settings.index || []);
    
        // Declare handler
    
        var handler = function (request, reply) {
    
            var paths = normalized;
            if (typeof settings.path === 'function') {
                var result = settings.path.call(null, request);
                if (result instanceof Error) {
                    return reply(result);
                }
    
                if (Array.isArray(result)) {
                    paths = normalize(result);
                }
                else if (typeof result === 'string') {
                    paths = normalize([result]);
                }
                else {
                    return reply(Boom.badImplementation('Invalid path function'));
                }
            }
    
            // Append parameter
    
            var selection = null;
            var lastParam = request.paramsArray[request.paramsArray.length - 1];
            if (lastParam) {
                if (lastParam.indexOf('..') !== -1) {
                    return reply(Boom.forbidden());
                }
    
                selection = lastParam;
            }
    
            if (selection &&
                !settings.showHidden &&
                internals.isFileHidden(selection)) {
    
                return reply(Boom.notFound());
            }
    
            // Generate response
    
            var resource = request.path;
            var hasTrailingSlash = (resource[resource.length - 1] === '/');
    
            Items.serial(paths, function (path, nextPath) {
    
                path = Path.join(path, selection || '');
    
                File.load(path, request, { lookupCompressed: settings.lookupCompressed }, function (response) {
    
                    // File loaded successfully
    
                    if (!response.isBoom) {
                        return reply(response);
                    }
    
                    // Not found
    
                    var err = response;
                    if (err.output.statusCode === 404) {
                        if (!settings.defaultExtension) {
                            return nextPath();
                        }
    
                        if (hasTrailingSlash) {
                            path = path.slice(0, -1);
                        }
    
                        return File.load(path + '.' + settings.defaultExtension, request, { lookupCompressed: settings.lookupCompressed }, function (extResponse) {
    
                            if (!extResponse.isBoom) {
                                return reply(extResponse);
                            }
    
                            return nextPath();
                        });
                    }
    
                    // Propagate non-directory errors
    
                    if (err.output.statusCode !== 403 || err.data !== 'EISDIR') {
                        return reply(err);
                    }
    
                    // Directory
    
                    if (indexNames.length === 0 &&
                        !settings.listing) {
    
                        return reply(Boom.forbidden());
                    }
    
                    if (settings.redirectToSlash !== false &&                       // Defaults to true
                        !request.connection.settings.router.stripTrailingSlash &&
                        !hasTrailingSlash) {
    
                        return reply.redirect(resource + '/');
                    }
    
                    Items.serial(indexNames, function (indexName, nextIndex) {
    
                        var indexFile = Path.join(path, indexName);
                        File.load(indexFile, request, { lookupCompressed: settings.lookupCompressed }, function (indexResponse) {
    
                            // File loaded successfully
    
                            if (!indexResponse.isBoom) {
                                return reply(indexResponse);
                            }
    
                            // Directory
    
                            var err = indexResponse;
                            if (err.output.statusCode !== 404) {
                                return reply(Boom.badImplementation(indexName + ' is a directory'));
                            }
    
                            // Not found, try the next one
    
                            return nextIndex();
                        });
                    },
                    function (/* err */) {
    
                        // None of the index files were found
    
                        if (!settings.listing) {
                            return reply(Boom.forbidden());
                        }
    
                        return internals.generateListing(path, resource, selection, hasTrailingSlash, settings, request, reply);
                    });
                });
            },
            function (/* err */) {
    
                return reply(Boom.notFound());
            });
        };
    
        return handler;
    };
    
    
    internals.generateListing = function (path, resource, selection, hasTrailingSlash, settings, request, reply) {
    
        Fs.readdir(path, function (err, files) {
    
            if (err) {
                return reply(Boom.internal('Error accessing directory', err));
            }
    
            resource = decodeURIComponent(resource);
            var display = Hoek.escapeHtml(resource);
            var html = '<html><head><title>' + display + '</title></head><body><h1>Directory: ' + display + '</h1><ul>';
    
            if (selection) {
                var parent = resource.substring(0, resource.lastIndexOf('/', resource.length - (hasTrailingSlash ? 2 : 1))) + '/';
                html += '<li><a href="' + internals.pathEncode(parent) + '">Parent Directory</a></li>';
            }
    
            for (var i = 0, il = files.length; i < il; ++i) {
                if (settings.showHidden ||
                    !internals.isFileHidden(files[i])) {
    
                    html += '<li><a href="' + internals.pathEncode(resource + (selection && !hasTrailingSlash ? '/' : '') + files[i]) + '">' + Hoek.escapeHtml(files[i]) + '</a></li>';
                }
            }
    
            html += '</ul></body></html>';
    
            return reply(request.generateResponse(html));
        });
    };
    
    
    internals.isFileHidden = function (path) {
    
        return /(^|[\\\/])\.([^\\\/]|[\\\/]?$)/.test(path);           // Starts with a '.' or contains '/.' or '\.', and not followed by a '/' or '\' or end
    };
    
    
    internals.pathEncode = function (path) {
    
        return encodeURIComponent(path).replace(/%2F/g, '/').replace(/%5C/g, '\\');
    };
    
  provide("inert/lib/directory", module.exports);
}(global));

// pakmanager:inert
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Directory =  require('inert/lib/directory');
    var File =  require('inert/lib/file');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.register = function (server, options, next) {
    
        server.expose('_etags', server.settings.files.etagsCacheMaxSize ? new File.Etags(server.settings.files.etagsCacheMaxSize) : null);
    
        server.handler('file', File.handler);
        server.handler('directory', Directory.handler);
    
        server.decorate('reply', 'file', function (path, responseOptions) {
    
            return this.response(File.response(path, responseOptions, this.request));
        });
    
        return next();
    };
    
    exports.register.attributes = {
        pkg: require('../package.json')
    };
    
  provide("inert", module.exports);
}(global));

// pakmanager:kilt/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Events = require('events');
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports = module.exports = internals.Kilt = function () {
    
        Events.EventEmitter.call(this);
    
        this._sources = [];
        this._handlers = {};
    
        var emitters = Hoek.flatten(Array.prototype.slice.call(arguments));
        if (emitters.length) {
            emitters = [].concat(emitters);
            for (var i = 0, il = emitters.length; i < il; ++i) {
                this.addEmitter(emitters[i]);
            }
        }
    };
    
    Hoek.inherits(internals.Kilt, Events.EventEmitter);
    
    
    internals.Kilt.prototype.addEmitter = function (emitter) {
    
        this._sources.push(emitter);
        var types = Object.keys(this._events);
        for (var i = 0, il = types.length; i < il; ++i) {
            var type = types[i];
            emitter.on(type, this._handler(type));
        }
    };
    
    
    internals.Kilt.prototype._handler = function (type) {
    
        var self = this;
    
        if (this._handlers[type]) {
            return this._handlers[type];
        }
    
        var handler = function () {
    
            var args = Array.prototype.slice.call(arguments);
            args.unshift(type);
            Events.EventEmitter.prototype.emit.apply(self, args);
            self._unsubscribe(type);
        };
    
        this._handlers[type] = handler;
        return handler;
    };
    
    
    internals.Kilt.prototype.on = internals.Kilt.prototype.addListener = function (type, listener) {
    
        this._subscribe(type);
        return Events.EventEmitter.prototype.on.call(this, type, listener);
    };
    
    
    internals.Kilt.prototype._subscribe = function (type) {
    
        if (!this._events[type]) {
            for (var i = 0, il = this._sources.length; i < il; ++i) {
                this._sources[i].on(type, this._handler(type));
            }
        }
    };
    
    
    internals.Kilt.prototype.removeListener = function (type, listener) {
    
        Events.EventEmitter.prototype.removeListener.call(this, type, listener);
        this._unsubscribe(type);
        return this;
    };
    
    
    internals.Kilt.prototype.removeAllListeners = function (type) {
    
        Events.EventEmitter.prototype.removeAllListeners.apply(this, arguments);
        this._unsubscribe(type);
        return this;
    };
    
    
    internals.Kilt.prototype._unsubscribe = function (type) {
    
        if (type === undefined) {
            for (var i = 0, il = this._sources.length; i < il; ++i) {
                this._sources[i].removeAllListeners();
            }
        }
        else if (!this._events[type]) {
            for (var i = 0, il = this._sources.length; i < il; ++i) {
                this._sources[i].removeListener(type, this._handler(type));
            }
        }
    };
  provide("kilt/lib", module.exports);
}(global));

// pakmanager:kilt
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('kilt/lib');
  provide("kilt", module.exports);
}(global));

// pakmanager:mimos/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Path = require('path');
    var Hoek = require('hoek');
    var MimeDb = require('mime-db');
    
    
    // Declare internals
    
    var internals = {};
    
    
    internals.compressibleRx = /^text\/|\+json$|\+text$|\+xml$/;
    
    
    module.exports = internals.Mimos = function (options) {
    
        options = options || {};
    
        Hoek.assert(this.constructor === internals.Mimos, 'Mimos must be created with new');
    
        var result = options.override ? internals.compile(options.override) : internals.base;
        this._byType = result.byType;
        this._byExtension = result.byExtension;
    };
    
    
    internals.compile = function (override) {
    
        var db = Hoek.clone(MimeDb);
        Hoek.merge(db, override, true, false);
    
        var result = {
            byType: db,
            byExtension: {}
        };
    
        var keys = Object.keys(result.byType);
        for (var i = 0, il = keys.length; i < il; i++) {
            var type = keys[i];
            var mime = result.byType[type];
            mime.type = mime.type || type;
            mime.source = mime.source || 'mime-db';
            mime.extensions = mime.extensions || [];
            mime.compressible = (mime.compressible !== undefined ? mime.compressible : internals.compressibleRx.test(type));
    
            Hoek.assert(!mime.predicate || typeof mime.predicate === 'function', 'predicate option must be a function');
    
            for (var j = 0, jl = mime.extensions.length; j < jl; j++) {
                var ext = mime.extensions[j];
                result.byExtension[ext] = mime;
            }
        }
    
        return result;
    };
    
    
    internals.base = internals.compile();       // Prevents an expensive copy on each constructor when no customization is needed
    
    
    internals.Mimos.prototype.path = function (path) {
    
        var extension = Path.extname(path).slice(1).toLowerCase();
        var mime = this._byExtension[extension] || {};
    
        if (mime.predicate) {
             return mime.predicate(Hoek.clone(mime));
        }
    
        return mime;
    };
    
    
    internals.Mimos.prototype.type = function (type) {
    
        type = type.split(';', 1)[0].trim().toLowerCase();
        var mime = this._byType[type];
        if (!mime) {
            mime = {
                type: type,
                source: 'mimos',
                extensions: [],
                compressible: internals.compressibleRx.test(type)
            };
    
            this._byType[type] = mime;
            return mime;
        }
    
        if (mime.predicate) {
            return mime.predicate(Hoek.clone(mime));
        }
    
        return mime;
    };
  provide("mimos/lib", module.exports);
}(global));

// pakmanager:mimos
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('mimos/lib');
  provide("mimos", module.exports);
}(global));

// pakmanager:peekaboo/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Stream = require('stream');
    var Util = require('util');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports = module.exports = internals.Peek = function (emitter) {
    
        Stream.Transform.call(this);
        this._emmiter = emitter;
        this.once('finish', function () {
    
            emitter.emit('finish');
        });
    };
    
    Util.inherits(internals.Peek, Stream.Transform);
    
    
    internals.Peek.prototype._transform = function (chunk, encoding, callback) {
    
        this._emmiter.emit('peek', chunk, encoding);
        this.push(chunk, encoding);
        callback();
    };
    
  provide("peekaboo/lib", module.exports);
}(global));

// pakmanager:peekaboo
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('peekaboo/lib');
    
  provide("peekaboo", module.exports);
}(global));

// pakmanager:shot
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Http = require('http');
    var Stream = require('stream');
    var Util = require('util');
    var Url = require('url');
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    
    internals.Request = function (options) {
    
        var self = this;
    
        Stream.Readable.call(this);
    
        // options: method, url, payload, headers
    
        var url = options.url;
    
        if (typeof url === 'object') {
            url = Url.format(url);
        }
    
        var uri = Url.parse(url);
        this.url = uri.path;
    
        this.httpVersion = '1.1';
        this.method = options.method.toUpperCase();
    
        this.headers = {};
        var headers = options.headers || {};
        var fields = Object.keys(headers);
        fields.forEach(function (field) {
    
            self.headers[field.toLowerCase()] = headers[field];
        });
    
        this.headers['user-agent'] = this.headers['user-agent'] || 'shot';
    
        if (uri.host &&
            !this.headers.host) {
    
            this.headers.host = uri.host;
        }
    
        // Use _shot namespace to avoid collision with Node
    
        var payload = options.payload || null;
        if (payload &&
            typeof payload !== 'string' &&
            !Buffer.isBuffer(payload)) {
    
            payload = JSON.stringify(payload);
            this.headers['content-type'] = this.headers['content-type'] || 'application/json';
        }
    
        // Set the content-length for the corresponding payload if none set
    
        if (payload &&
            !this.headers.hasOwnProperty('content-length')) {
    
            this.headers['content-length'] = (Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload)).toString();
        }
    
        this._shot = {
            payload: payload,
            isDone: false,
            simulate: options.simulate || {}
        };
    
        return this;
    };
    
    Util.inherits(internals.Request, Stream.Readable);
    
    
    internals.Request.prototype._read = function (size) {
    
        var self = this;
    
        setImmediate(function () {
    
            if (self._shot.isDone) {
                if (self._shot.simulate.end !== false) {        // 'end' defaults to true
                    self.push(null);
                }
    
                return;
            }
    
            self._shot.isDone = true;
    
            if (self._shot.payload) {
                if (self._shot.simulate.split) {
                    self.push(self._shot.payload.slice(0, 1));
                    self.push(self._shot.payload.slice(1));
                }
                else {
                    self.push(self._shot.payload);
                }
            }
    
            if (self._shot.simulate.error) {
                self.emit('error', new Error('Simulated'));
            }
    
            if (self._shot.simulate.close) {
                self.emit('close');
            }
    
            if (self._shot.simulate.end !== false) {        // 'end' defaults to true
                self.push(null);
            }
        });
    };
    
    
    internals.Request.prototype.destroy = function () {
    
    };
    
    
    internals.Response = function (req, onEnd) {
    
        Http.ServerResponse.call(this, { method: req.method, httpVersionMajor: 1, httpVersionMinor: 1 });
    
        this.once('finish', internals.finish(this, req, onEnd));
    
        return this;
    };
    
    Util.inherits(internals.Response, Http.ServerResponse);
    
    
    internals.Response.prototype.writeHead = function () {
    
        var self = this;
    
        var headers = ((arguments.length === 2 && typeof arguments[1] === 'object') ? arguments[1] : (arguments.length === 3 ? arguments[2] : {}));
        var result = Http.ServerResponse.prototype.writeHead.apply(this, arguments);
    
        this._headers = this._headers || {};
        var keys = Object.keys(headers);
        for (var i = 0, il = keys.length; i < il; ++i) {
            this._headers[keys[i]] = headers[keys[i]];
        }
    
        // Add raw headers
    
        ['Date', 'Connection', 'Transfer-Encoding'].forEach(function (name) {
    
            var regex = new RegExp('\\r\\n' + name + ': ([^\\r]*)\\r\\n');
            var field = self._header.match(regex);
            if (field) {
                self._headers[name.toLowerCase()] = field[1];
            }
        });
    
        return result;
    };
    
    
    internals.Response.prototype.write = function (data, encoding) {
    
        Http.ServerResponse.prototype.write.call(this, data, encoding);
        return true;                                                    // Write always returns false when disconnected
    };
    
    
    internals.Response.prototype.end = function (data, encoding) {
    
        Http.ServerResponse.prototype.end.call(this, data, encoding);
        this.emit('finish');                                            // Will not be emitted when disconnected
    };
    
    
    internals.Response.prototype.destroy = function () {
    
    };
    
    
    internals.finish = function (response, req, onEnd) {
    
        return function () {
    
            // Prepare response object
    
            var res = {
                raw: {
                    req: req,
                    res: response
                },
                headers: response._headers,
                statusCode: response.statusCode
            };
    
            // When done, call callback
    
            process.nextTick(function () {
    
                onEnd(res);
            });
    
            // Read payload
    
            var raw = [];
            var rawLength = 0;
            for (var i = 0, il = response.output.length; i < il; ++i) {
                var chunk = (response.output[i] instanceof Buffer ? response.output[i] : new Buffer(response.output[i], response.outputEncodings[i]));
                raw.push(chunk);
                rawLength += chunk.length;
            }
    
            var rawBuffer = Buffer.concat(raw, rawLength);
    
            // Parse payload
            res.payload = '';
    
            var CRLF = '\r\n';
            var sep = new Buffer(CRLF + CRLF);
            var parts = internals.splitBufferInTwo(rawBuffer, sep);
            var payloadBuffer = parts[1];
    
            if (!res.headers['transfer-encoding']) {
                res.rawPayload = payloadBuffer;
                res.payload = payloadBuffer.toString();
                return;
            }
    
            var CRLFBuffer = new Buffer(CRLF);
            var rest = payloadBuffer;
            var payloadBytes = [];
            do {
                var payloadParts = internals.splitBufferInTwo(rest, CRLFBuffer);
                var next = payloadParts[1];
                var size = parseInt(payloadParts[0].toString(), 16);
                if (size === 0) {
                    rest = next;
                }
                else {
                    var nextData = next.slice(0, size);
                    payloadBytes = payloadBytes.concat(Array.prototype.slice.call(nextData, 0));
                    rest = next.slice(size + 2);
                }
            }
            while (size);
    
            res.rawPayload = new Buffer(payloadBytes);
            res.payload = res.rawPayload.toString('utf8');
            var headers = rest.toString().split(CRLF);
            headers.forEach(function (header) {
    
                var parts = header.split(':');
                if (parts.length === 2) {
                    response._headers[parts[0].trim().toLowerCase()] = parts[1].trim();
                }
            });
        };
    };
    
    
    internals.splitBufferInTwo = function (buffer, seperator) {
    
        for (var i = 0, max = buffer.length - seperator.length; i < max; ++i) {
            if (internals.bufferEqual(buffer.slice(i, i + seperator.length), seperator)) {
                var part1 = buffer.slice(0, i);
                var part2 = buffer.slice(i + seperator.length);
                return [part1, part2];
            }
        }
    
        return [buffer, new Buffer(0)];
    };
    
    
    exports.inject = function (dispatchFunc, options, callback) {
    
        options = (typeof options === 'string' ? { url: options } : options);
        var settings = Hoek.applyToDefaults({ method: 'GET' }, options);
    
        var req = new internals.Request(settings);
        var res = new internals.Response(req, callback);
        dispatchFunc(req, res);
    };
    
    
    exports.isInjection = function (obj) {
    
        return (obj instanceof internals.Request || obj instanceof internals.Response);
    };
    
    
    internals.bufferEqual = function (a, b) {
    
        for (var i = 0, il = a.length; i < il; ++i) {
            if (a[i] !== b[i]) {
                return false;
            }
        }
    
        return true;
    };
    
  provide("shot", module.exports);
}(global));

// pakmanager:statehood
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Boom = require('boom');
    var Cryptiles = require('cryptiles');
    var Hoek = require('hoek');
    var Iron = require('iron');
    var Items = require('items');
    var Joi = require('joi');
    var Querystring = require('querystring');
    
    
    // Declare internals
    
    var internals = {};
    
    
    internals.schema = Joi.object({
        strictHeader: Joi.boolean(),
        ignoreErrors: Joi.boolean(),
        isSecure: Joi.boolean(),
        isHttpOnly: Joi.boolean(),
        path: Joi.string().allow(null),
        domain: Joi.string().allow(null),
        ttl: Joi.number().allow(null),
        encoding: Joi.string().valid('base64json', 'base64', 'form', 'iron', 'none'),
        sign: Joi.object({
            password: [Joi.string(), Joi.binary(), Joi.object()],
            integrity: Joi.object()
        }),
        iron: Joi.object(),
        password: [Joi.string(), Joi.binary(), Joi.object()],
    
        // Used by hapi
    
        clearInvalid: Joi.boolean(),
        autoValue: Joi.any(),
        passThrough: Joi.boolean()
    });
    
    
    internals.defaults = {
        strictHeader: true,                             // Require an RFC 6265 compliant header format
        ignoreErrors: false,
        isSecure: false,
        isHttpOnly: false,
        path: null,
        domain: null,
        ttl: null,                                      // MSecs, 0 means remove
        encoding: 'none'                                // options: 'base64json', 'base64', 'form', 'iron', 'none'
    };
    
    
    exports.Definitions = internals.Definitions = function (options) {
    
        this.settings = Hoek.applyToDefaults(internals.defaults, options || {});
        Joi.assert(this.settings, internals.schema, 'Invalid state definition defaults');
    
        this.cookies = {};
        this.names = [];
    };
    
    
    internals.Definitions.prototype.add = function (name, options) {
    
        Hoek.assert(name && typeof name === 'string', 'Invalid name');
        Hoek.assert(!this.cookies[name], 'State already defined:', name);
    
        var settings = Hoek.applyToDefaults(this.settings, options || {}, true);
        Joi.assert(settings, internals.schema, 'Invalid state definition: ' + name);
    
        this.cookies[name] = settings;
        this.names.push(name);
    };
    
    
    internals.empty = new internals.Definitions();
    
    
    // Header format
    
    //                      1: name                2: quoted  3: value
    internals.parseRx = /\s*([^=\s]+)\s*=\s*(?:(?:"([^\"]*)")|([^\;]*))(?:(?:;\s*)|$)/g;
    
    internals.validateRx = {
        nameRx: {
            strict: /^[^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+$/,
            loose: /^[^=\s]+$/
        },
        valueRx: {
            strict: /^[^\x00-\x20\"\,\;\\\x7F]*$/,
            loose: /^(?:"([^\"]*)")|(?:[^\;]*)$/
        },
        domainRx: /^\.?[a-z\d]+(?:(?:[a-z\d]*)|(?:[a-z\d\-]*[a-z\d]))(?:\.[a-z\d]+(?:(?:[a-z\d]*)|(?:[a-z\d\-]*[a-z\d])))*$/,
        domainLabelLenRx: /^\.?[a-z\d\-]{1,63}(?:\.[a-z\d\-]{1,63})*$/,
        pathRx: /^\/[^\x00-\x1F\;]*$/
    };
    
    //                      1: name         2: value
    internals.pairsRx = /\s*([^=\s]+)\s*=\s*([^\;]*)(?:(?:;\s*)|$)/g;
    
    
    internals.Definitions.prototype.parse = function (cookies, next) {
    
        var self = this;
    
        var state = {};
        var names = [];
        var verify = cookies.replace(internals.parseRx, function ($0, $1, $2, $3) {
    
            var name = $1;
            var value = $2 || $3 || '';
    
            if (state[name]) {
                if (!Array.isArray(state[name])) {
                    state[name] = [state[name]];
                }
    
                state[name].push(value);
            }
            else {
                state[name] = value;
                names.push(name);
            }
    
            return '';
        });
    
        // Validate cookie header syntax
    
        if (verify !== '') {
            return next(Boom.badRequest('Invalid cookie header'), null, []);
        }
    
        // Collect errors
    
        var failed = [];                                                // All errors
        var errored = [];                                               // Unignored errors
        var record = function (reason, name, value, definition) {
    
            var details = {
                name: name,
                value: value,
                settings: definition,
                reason: typeof reason === 'string' ? reason : reason.message
            };
    
            failed.push(details);
            if (!definition.ignoreErrors) {
                errored.push(details);
            }
        };
    
        // Parse cookies
    
        var parsed = {};
        Items.serial(names, function (name, nextName) {
    
            var value = state[name];
            var definition = self.cookies[name] || self.settings;
    
            // Validate cookie
    
            if (definition.strictHeader) {
                if (!name.match(internals.validateRx.nameRx.strict)) {
                    record('Invalid cookie name', name, value, definition);
                    return nextName();
                }
    
                var values = [].concat(state[name]);
                for (var v = 0, vl = values.length; v < vl; ++v) {
                    if (!values[v].match(internals.validateRx.valueRx.strict)) {
                        record('Invalid cookie value', name, value, definition);
                        return nextName();
                    }
                }
            }
    
            // Check cookie format
    
            if (definition.encoding === 'none') {
                parsed[name] = value;
                return nextName();
            }
    
            // Single value
    
            if (!Array.isArray(value)) {
                internals.unsign(name, value, definition, function (err, unsigned) {
    
                    if (err) {
                        record(err, name, value, definition);
                        return nextName();
                    }
    
                    internals.decode(unsigned, definition, function (err, result) {
    
                        if (err) {
                            record(err, name, value, definition);
                            return nextName();
                        }
    
                        parsed[name] = result;
                        return nextName();
                    });
                });
    
                return;
            }
    
            // Array
    
            var arrayResult = [];
            Items.serial(value, function (arrayValue, nextArray) {
    
                internals.unsign(name, arrayValue, definition, function (err, unsigned) {
    
                    if (err) {
                        record(err, name, value, definition);
                        return nextName();
                    }
    
                    internals.decode(unsigned, definition, function (err, result) {
    
                        if (err) {
                            record(err, name, value, definition);
                            return nextName();
                        }
    
                        arrayResult.push(result);
                        nextArray();
                    });
                });
            },
            function (err) {
    
                parsed[name] = arrayResult;
                return nextName();
            });
        },
        function (err) {
    
            return next(errored.length ? Boom.badRequest('Invalid cookie value', errored) : null, parsed, failed);
        });
    };
    
    
    internals.macPrefix = 'hapi.signed.cookie.1';
    
    
    internals.unsign = function (name, value, definition, next) {
    
        if (!definition.sign) {
            return next(null, value);
        }
    
        var pos = value.lastIndexOf('.');
        if (pos === -1) {
            return next(Boom.badRequest('Missing signature separator'));
        }
    
        var unsigned = value.slice(0, pos);
        var sig = value.slice(pos + 1);
    
        if (!sig) {
            return next(Boom.badRequest('Missing signature'));
        }
    
        var sigParts = sig.split('*');
        if (sigParts.length !== 2) {
            return next(Boom.badRequest('Invalid signature format'));
        }
    
        var hmacSalt = sigParts[0];
        var hmac = sigParts[1];
    
        var macOptions = Hoek.clone(definition.sign.integrity || Iron.defaults.integrity);
        macOptions.salt = hmacSalt;
        Iron.hmacWithPassword(definition.sign.password, macOptions, [internals.macPrefix, name, unsigned].join('\n'), function (err, mac) {
    
            if (err) {
                return next(err);
            }
    
            if (!Cryptiles.fixedTimeComparison(mac.digest, hmac)) {
                return next(Boom.badRequest('Invalid hmac value'));
            }
    
            return next(null, unsigned);
        });
    };
    
    
    internals.decode = function (value, definition, next) {
    
        // Encodings: 'base64json', 'base64', 'form', 'iron', 'none'
    
        if (definition.encoding === 'iron') {
            Iron.unseal(value, definition.password, definition.iron || Iron.defaults, function (err, unsealed) {
    
                if (err) {
                    return next(err);
                }
    
                return next(null, unsealed);
            });
    
            return;
        }
    
        var result = value;
    
        try {
            switch (definition.encoding) {
                case 'base64json':
                    var decoded = (new Buffer(value, 'base64')).toString('binary');
                    result = JSON.parse(decoded);
                    break;
                case 'base64':
                    result = (new Buffer(value, 'base64')).toString('binary');
                    break;
                case 'form':
                    result = Querystring.parse(value);
                    break;
            }
        }
        catch (err) {
            return next(err);
        }
    
        return next(null, result);
    };
    
    
    internals.Definitions.prototype.format = function (cookies, callback) {
    
        var self = this;
    
        if (!cookies ||
            (Array.isArray(cookies) && !cookies.length)) {
    
            return Hoek.nextTick(callback)(null, []);
        }
    
        if (!Array.isArray(cookies)) {
            cookies = [cookies];
        }
    
        var header = [];
        Items.serial(cookies, function (cookie, next) {
    
            // Apply definition to local configuration
    
            var base = self.cookies[cookie.name] || self.settings;
            var definition = cookie.options ? Hoek.applyToDefaults(base, cookie.options, true) : base;
    
            // Validate name
    
            var nameRx = (definition.strictHeader ? internals.validateRx.nameRx.strict : internals.validateRx.nameRx.loose);
            if (!nameRx.test(cookie.name)) {
                return callback(Boom.badImplementation('Invalid cookie name: ' + cookie.name));
            }
    
            // Prepare value (encode, sign)
    
            exports.prepareValue(cookie.name, cookie.value, definition, function (err, value) {
    
                if (err) {
                    return callback(err);
                }
    
                // Validate prepared value
    
                var valueRx = (definition.strictHeader ? internals.validateRx.valueRx.strict : internals.validateRx.valueRx.loose);
                if (value &&
                    (typeof value !== 'string' || !value.match(valueRx))) {
    
                    return callback(Boom.badImplementation('Invalid cookie value: ' + cookie.value));
                }
    
                // Construct cookie
    
                var segment = cookie.name + '=' + (value || '');
    
                if (definition.ttl !== null &&
                    definition.ttl !== undefined) {            // Can be zero
    
                    var expires = new Date(definition.ttl ? Date.now() + definition.ttl : 0);
                    segment += '; Max-Age=' + Math.floor(definition.ttl / 1000) + '; Expires=' + expires.toUTCString();
                }
    
                if (definition.isSecure) {
                    segment += '; Secure';
                }
    
                if (definition.isHttpOnly) {
                    segment += '; HttpOnly';
                }
    
                if (definition.domain) {
                    var domain = definition.domain.toLowerCase();
                    if (!domain.match(internals.validateRx.domainLabelLenRx)) {
                        return callback(Boom.badImplementation('Cookie domain too long: ' + definition.domain));
                    }
    
                    if (!domain.match(internals.validateRx.domainRx)) {
                        return callback(Boom.badImplementation('Invalid cookie domain: ' + definition.domain));
                    }
    
                    segment += '; Domain=' + domain;
                }
    
                if (definition.path) {
                    if (!definition.path.match(internals.validateRx.pathRx)) {
                        return callback(Boom.badImplementation('Invalid cookie path: ' + definition.path));
                    }
    
                    segment += '; Path=' + definition.path;
                }
    
                header.push(segment);
                return next();
            });
        },
        function (err) {
    
            return callback(null, header);
        });
    };
    
    
    exports.prepareValue = function (name, value, options, callback) {
    
        Hoek.assert(options && typeof options === 'object', 'Missing or invalid options');
    
        // Encode value
    
        internals.encode(value, options, function (err, encoded) {
    
            if (err) {
                return callback(Boom.badImplementation('Failed to encode cookie (' + name + ') value: ' + err.message));
            }
    
            // Sign cookie
    
            internals.sign(name, encoded, options.sign, function (err, signed) {
    
                if (err) {
                    return callback(Boom.badImplementation('Failed to sign cookie (' + name + ') value: ' + err.message));
                }
    
                return callback(null, signed);
            });
        });
    };
    
    
    internals.encode = function (value, options, callback) {
    
        callback = Hoek.nextTick(callback);
    
        // Encodings: 'base64json', 'base64', 'form', 'iron', 'none'
    
        if (value === undefined) {
            return callback(null, value);
        }
    
        if (options.encoding === 'none') {
            return callback(null, value);
        }
    
        if (options.encoding === 'iron') {
            Iron.seal(value, options.password, options.iron || Iron.defaults, function (err, sealed) {
    
                if (err) {
                    return callback(err);
                }
    
                return callback(null, sealed);
            });
    
            return;
        }
    
        var result = value;
    
        try {
            switch (options.encoding) {
                case 'base64':
                    result = (new Buffer(value, 'binary')).toString('base64');
                    break;
                case 'base64json':
                    var stringified = JSON.stringify(value);
                    result = (new Buffer(stringified, 'binary')).toString('base64');
                    break;
                case 'form':
                    result = Querystring.stringify(value);
                    break;
            }
        }
        catch (err) {
            return callback(err);
        }
    
        return callback(null, result);
    };
    
    
    internals.sign = function (name, value, options, callback) {
    
        if (value === undefined ||
            !options) {
    
            return Hoek.nextTick(callback)(null, value);
        }
    
        Iron.hmacWithPassword(options.password, options.integrity || Iron.defaults.integrity, [internals.macPrefix, name, value].join('\n'), function (err, mac) {
    
            if (err) {
                return callback(err);
            }
    
            var signed = value + '.' + mac.salt + '*' + mac.digest;
            return callback(null, signed);
        });
    };
    
    
    internals.Definitions.prototype.passThrough = function (header, fallback) {
    
        if (!this.names.length) {
            return header;
        }
    
        var exclude = [];
        for (var i = 0, il = this.names.length; i < il; ++i) {
            var name = this.names[i];
            var definition = this.cookies[name];
            var passCookie = definition.passThrough !== undefined ? definition.passThrough : fallback;
            if (!passCookie) {
                exclude.push(name);
            }
        }
    
        return exports.exclude(header, exclude);
    };
    
    
    exports.exclude = function (cookies, excludes) {
    
        var result = '';
        var verify = cookies.replace(internals.pairsRx, function ($0, $1, $2) {
    
            if (excludes.indexOf($1) === -1) {
                result += (result ? ';' : '') + $1 + '=' + $2;
            }
    
            return '';
        });
    
        return verify === '' ? result : Boom.badRequest('Invalid cookie header');
    };
    
  provide("statehood", module.exports);
}(global));

// pakmanager:subtext
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Crypto = require('crypto');
    var Fs = require('fs');
    var Os = require('os');
    var Path = require('path');
    var Stream = require('stream');
    var Zlib = require('zlib');
    var Boom = require('boom');
    var Content = require('content');
    var Hoek = require('hoek');
    var Pez = require('pez');
    var Qs = require('qs');
    var Wreck = require('wreck');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.parse = function (req, tap, options, next) {
    
        Hoek.assert(options, 'Missing options');
        Hoek.assert(options.parse !== undefined, 'Missing parse option setting');
        Hoek.assert(options.output !== undefined, 'Missing output option setting');
    
        var parser = new internals.Parser(req, tap, options, next);
        return parser.read();
    };
    
    
    internals.Parser = function (req, tap, options, next) {
    
        var self = this;
    
        this.req = req;
        this.settings = options;
        this.tap = tap;
    
        this.result = {};
    
        this.next = function (err) {
    
            return next(err, self.result);
        };
    };
    
    
    internals.Parser.prototype.read = function () {
    
        var next = this.next;
    
        // Content size
    
        var req = this.req;
        var contentLength = req.headers['content-length'];
        if (this.settings.maxBytes !== undefined &&
            contentLength &&
            parseInt(contentLength, 10) > this.settings.maxBytes) {
    
            return next(Boom.badRequest('Payload content length greater than maximum allowed: ' + this.settings.maxBytes));
        }
    
        // Content type
    
        var contentType = Content.type(this.settings.override || req.headers['content-type'] || 'application/json');     //  Defaults to 'application/json'
        if (contentType.isBoom) {
            return next(contentType);
        }
    
        this.result.contentType = contentType;
        this.result.mime = contentType.mime;
    
        if (this.settings.allow &&
            this.settings.allow.indexOf(contentType.mime) === -1) {
    
            return next(Boom.unsupportedMediaType());
        }
    
        // Parse: true
    
        if (this.settings.parse === true) {
            return this.parse(contentType);
        }
    
        // Parse: false, 'gunzip'
    
        return this.raw();
    };
    
    
    internals.Parser.prototype.parse = function (contentType) {
    
        var self = this;
    
        var next = this.next;
    
        var output = this.settings.output;      // Output: 'data', 'stream', 'file'
        var source = this.req;
    
        // Content-encoding
    
        var contentEncoding = source.headers['content-encoding'];
        if (contentEncoding === 'gzip' || contentEncoding === 'deflate') {
            var decoder = (contentEncoding === 'gzip' ? Zlib.createGunzip() : Zlib.createInflate());
            next = Hoek.once(next);                                                                     // Modify next() for async events
            this.next = next;
            decoder.once('error', function (err) {
    
                return next(Boom.badRequest('Invalid compressed payload', err));
            });
    
            source = source.pipe(decoder);
        }
    
        // Tap request
    
        if (this.tap) {
            source = source.pipe(this.tap);
        }
    
        // Multipart
    
        if (this.result.contentType.mime === 'multipart/form-data') {
            return this.multipart(source, contentType);
        }
    
        // Output: 'stream'
    
        if (output === 'stream') {
            this.result.payload = source;
            return next();
        }
    
        // Output: 'file'
    
        if (output === 'file') {
            this.writeFile(source, function (err, path, bytes) {
    
                if (err) {
                    return next(err);
                }
    
                self.result.payload = { path: path, bytes: bytes };
                return next();
            });
    
            return;
        }
    
        // Output: 'data'
    
        return Wreck.read(source, { timeout: this.settings.timeout, maxBytes: this.settings.maxBytes }, function (err, payload) {
    
            if (err) {
                return next(err);
            }
    
            self.result.payload = {};
    
            if (!payload.length) {
                return next();
            }
    
            internals.object(payload, self.result.contentType.mime, self.settings, function (err, result) {
    
                if (err) {
                    return next(err);
                }
    
                self.result.payload = result;
                return next();
            });
        });
    };
    
    
    internals.Parser.prototype.raw = function () {
    
        var self = this;
    
        var next = this.next;
    
        var output = this.settings.output;      // Output: 'data', 'stream', 'file'
        var source = this.req;
    
        // Content-encoding
    
        if (this.settings.parse === 'gunzip') {
            var contentEncoding = source.headers['content-encoding'];
            if (contentEncoding === 'gzip' || contentEncoding === 'deflate') {
                var decoder = (contentEncoding === 'gzip' ? Zlib.createGunzip() : Zlib.createInflate());
                next = Hoek.once(next);                                                                     // Modify next() for async events
    
                decoder.once('error', function (err) {
    
                    return next(Boom.badRequest('Invalid compressed payload', err));
                });
    
                source = source.pipe(decoder);
            }
        }
    
        // Setup source
    
        if (this.tap) {
            source = source.pipe(this.tap);
        }
    
        // Output: 'stream'
    
        if (output === 'stream') {
            this.result.payload = source;
            return next();
        }
    
        // Output: 'file'
    
        if (output === 'file') {
            this.writeFile(source, function (err, path, bytes) {
    
                if (err) {
                    return next(err);
                }
    
                self.result.payload = { path: path, bytes: bytes };
                return next();
            });
    
            return;
        }
    
        // Output: 'data'
    
        return Wreck.read(source, { timeout: this.settings.timeout, maxBytes: this.settings.maxBytes }, function (err, payload) {
    
            if (err) {
                return next(err);
            }
    
            self.result.payload = payload;
            return next();
        });
    };
    
    
    internals.object = function (payload, mime, options, next) {
    
        // Binary
    
        if (mime === 'application/octet-stream') {
            return next(null, payload);
        }
    
        // Text
    
        if (mime.match(/^text\/.+$/)) {
            return next(null, payload.toString('utf8'));
        }
    
        // JSON
    
        if (/^application\/(?:.+\+)?json$/.test(mime)) {
            return internals.jsonParse(payload, next);                      // Isolate try...catch for V8 optimization
        }
    
        // Form-encoded
    
        if (mime === 'application/x-www-form-urlencoded') {
            return next(null, Qs.parse(payload.toString('utf8'), options.qs));
        }
    
        return next(Boom.unsupportedMediaType());
    };
    
    
    internals.jsonParse = function (payload, next) {
    
        try {
            var parsed = JSON.parse(payload.toString('utf8'));
        }
        catch (err) {
            return next(Boom.badRequest('Invalid request payload JSON format', err));
        }
    
        return next(null, parsed);
    };
    
    
    internals.Parser.prototype.multipart = function (source, contentType) {
    
        var self = this;
    
        var next = this.next;
        next = Hoek.once(next);                                            // Modify next() for async events
        this.next = next;
    
        var dispenser = new Pez.Dispenser(contentType);
    
        var onError = function (err) {
    
            return next(Boom.badRequest('Invalid multipart payload format', err));
        };
    
        dispenser.once('error', onError);
    
        var arrayFields = false;
        var data = {};
        var finalize = function () {
    
            dispenser.removeListener('error', onError);
            dispenser.removeListener('part', onPart);
            dispenser.removeListener('field', onField);
            dispenser.removeListener('close', onClose);
    
            if (arrayFields) {
                data = Qs.parse(data, self.settings.qs);
            }
    
            self.result.payload = data;
            return next();
        };
    
        var set = function (name, value) {
    
            arrayFields = arrayFields || (name.indexOf('[') !== -1);
    
            if (!data.hasOwnProperty(name)) {
                data[name] = value;
            }
            else if (Array.isArray(data[name])) {
                data[name].push(value);
            }
            else {
                data[name] = [data[name], value];
            }
        };
    
        var pendingFiles = {};
        var nextId = 0;
        var closed = false;
    
        var onPart = function (part) {
    
            if (self.settings.output === 'file') {                                                  // Output: 'file'
                var id = nextId++;
                pendingFiles[id] = true;
                self.writeFile(part, function (err, path, bytes) {
    
                    delete pendingFiles[id];
    
                    if (err) {
                        return next(err);
                    }
    
                    var item = {
                        filename: part.filename,
                        path: path,
                        headers: part.headers,
                        bytes: bytes
                    };
    
                    set(part.name, item);
    
                    if (closed &&
                        !Object.keys(pendingFiles).length) {
    
                        return finalize(data);
                    }
                });
            }
            else {                                                                                  // Output: 'data'
                Wreck.read(part, {}, function (err, payload) {
    
                    // err handled by dispenser.once('error')
    
                    if (self.settings.output === 'stream') {                                        // Output: 'stream'
                        var item = Wreck.toReadableStream(payload);
    
                        item.hapi = {
                            filename: part.filename,
                            headers: part.headers
                        };
    
                        return set(part.name, item);
                    }
    
                    var ct = part.headers['content-type'] || '';
                    var mime = ct.split(';')[0].trim().toLowerCase();
    
                    if (!mime) {
                        return set(part.name, payload);
                    }
    
                    if (!payload.length) {
                        return set(part.name, {});
                    }
    
                    internals.object(payload, mime, self.settings, function (err, result) {
    
                        return set(part.name, err ? payload : result);
                    });
                });
            }
        };
    
        dispenser.on('part', onPart);
    
        var onField = function (name, value) {
    
            set(name, value);
        };
    
        dispenser.on('field', onField);
    
        var onClose = function () {
    
            if (Object.keys(pendingFiles).length) {
                closed = true;
                return;
            }
    
            return finalize(data);
        };
    
        dispenser.once('close', onClose);
    
        source.pipe(dispenser);
    };
    
    
    internals.Parser.prototype.writeFile = function (stream, callback) {
    
        var self = this;
    
        var path = Hoek.uniqueFilename(this.settings.uploads || Os.tmpDir());
        var file = Fs.createWriteStream(path, { flags: 'wx' });
        var counter = new internals.Counter();
    
        var finalize = Hoek.once(function (err) {
    
            self.req.removeListener('aborted', onAbort);
            file.removeListener('close', finalize);
            file.removeListener('error', finalize);
    
            if (!err) {
                return callback(null, path, counter.bytes);
            }
    
            file.destroy();
            Fs.unlink(path, function (/* fsErr */) {      // Ignore unlink errors
    
                return callback(err);
            });
        });
    
        file.once('close', finalize);
        file.once('error', finalize);
    
        var onAbort = function () {
    
            return finalize(Boom.badRequest('Client connection aborted'));
        };
    
        this.req.once('aborted', onAbort);
    
        stream.pipe(counter).pipe(file);
    };
    
    
    internals.Counter = function () {
    
        Stream.Transform.call(this);
        this.bytes = 0;
    };
    
    Hoek.inherits(internals.Counter, Stream.Transform);
    
    
    internals.Counter.prototype._transform = function (chunk, encoding, next) {
    
        this.bytes += chunk.length;
        return next(null, chunk);
    };
    
  provide("subtext", module.exports);
}(global));

// pakmanager:vision/lib/manager
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Fs = require('fs');
    var Path = require('path');
    var Boom = require('boom');
    var Hoek = require('hoek');
    var Joi = require('joi');
    var Items = require('items');
    // Additional helper modules required in constructor
    
    
    // Declare internals
    
    var internals = {};
    
    
    internals.defaults = {
        // defaultExtension: '',
        // path: '',
        // relativeTo: '',
        compileOptions: {},
        runtimeOptions: {},
        layout: false,
        layoutKeyword: 'content',
        encoding: 'utf8',
        isCached: true,
        allowAbsolutePaths: false,
        allowInsecureAccess: false,
        // partialsPath: '',
        contentType: 'text/html',
        compileMode: 'sync',
        context: null
    };
    
    
    internals.schema = {};
    
    
    internals.schema.viewOverride = Joi.object({
        path: [Joi.array().items(Joi.string()), Joi.string()],
        relativeTo: Joi.string(),
        compileOptions: Joi.object(),
        runtimeOptions: Joi.object(),
        layout: Joi.string().allow(false, true),
        layoutKeyword: Joi.string(),
        layoutPath: [Joi.array().items(Joi.string()), Joi.string()],
        encoding: Joi.string(),
        allowAbsolutePaths: Joi.boolean(),
        allowInsecureAccess: Joi.boolean(),
        contentType: Joi.string()
    });
    
    
    internals.schema.viewBase = internals.schema.viewOverride.keys({
        partialsPath: [Joi.array().items(Joi.string()), Joi.string()],
        helpersPath: [Joi.array().items(Joi.string()), Joi.string()],
        isCached: Joi.boolean(),
        compileMode: Joi.string().valid('sync', 'async'),
        defaultExtension: Joi.string()
    });
    
    
    internals.schema.manager = internals.schema.viewBase.keys({
        engines: Joi.object().required(),
        context: [Joi.object(), Joi.func()]
    });
    
    
    internals.schema.view = internals.schema.viewBase.keys({
        module: Joi.object({
            compile: Joi.func().required()
        })
            .options({ allowUnknown: true })
            .required()
    });
    
    
    exports = module.exports = internals.Manager = function (options) {
    
        var self = this;
    
        Joi.assert(options, internals.schema.manager);
    
        // Save non-defaults values
    
        var engines = options.engines;
        var defaultExtension = options.defaultExtension;
    
        // Clone options
    
        var defaults = Hoek.applyToDefaultsWithShallow(internals.defaults, options, ['engines', 'context']);
        delete defaults.engines;
        delete defaults.defaultExtension;
    
        // Prepare manager state
    
        var extensions = Object.keys(engines);
        Hoek.assert(extensions.length, 'Views manager requires at least one registered extension handler');
    
        this._context = defaults.context;
        this._engines = {};
        this._defaultExtension = defaultExtension || (extensions.length === 1 ? extensions[0] : '');
    
        // Load engines
    
        extensions.forEach(function (extension) {
    
            var config = engines[extension];
            var engine = {};
    
            if (config.compile &&
                typeof config.compile === 'function') {
    
                engine.module = config;
                engine.config = defaults;
            }
            else {
                Joi.assert(config, internals.schema.view);
    
                engine.module = config.module;
                engine.config = Hoek.applyToDefaultsWithShallow(defaults, config, ['module']);
            }
    
            engine.suffix = '.' + extension;
            engine.compileFunc = engine.module.compile;
    
            if (engine.config.compileMode === 'sync') {
                engine.compileFunc = function (str, opt, next) {
    
                    var compiled = null;
                    try {
                        compiled = engine.module.compile(str, opt);
                    }
                    catch (err) {
                        return next(err);
                    }
    
                    var renderer = function (context, runtimeOptions, renderNext) {
    
                        var rendered = null;
                        try {
                            rendered = compiled(context, runtimeOptions);
                        }
                        catch (err) {
                            return renderNext(err);
                        }
    
                        return renderNext(null, rendered);
                    };
    
                    return next(null, renderer);
                };
            }
    
            if (engine.config.isCached) {
                engine.cache = {};
            }
    
            // Load partials and helpers
    
            self._loadPartials(engine);
            self._loadHelpers(engine);
    
            // Set engine
    
            self._engines[extension] = engine;
        });
    };
    
    
    internals.Manager.prototype._loadPartials = function (engine) {
    
        if (!engine.config.partialsPath ||
            !engine.module.registerPartial ||
            typeof engine.module.registerPartial !== 'function') {
    
            return;
        }
    
        var load = function () {
    
            var partialsPaths = [].concat(engine.config.partialsPath);
    
            partialsPaths.forEach(function (partialsPath) {
    
                var path = internals.path(engine.config.relativeTo, partialsPath);
                var files = traverse(path);
                files.forEach(function (file) {
    
                    var offset = path.slice(-1) === Path.sep ? 0 : 1;
                    var name = file.slice(path.length + offset, -engine.suffix.length).replace(/\\/g, '/');
                    var src = Fs.readFileSync(file).toString(engine.config.encoding);
                    engine.module.registerPartial(name, src);
                });
            });
        };
    
        var traverse = function (path) {
    
            var files = [];
    
            Fs.readdirSync(path).forEach(function (file) {
    
                file = Path.join(path, file);
                var stat = Fs.statSync(file);
                if (stat.isDirectory()) {
                    files = files.concat(traverse(file));
                    return;
                }
    
                if (Path.basename(file)[0] !== '.' &&
                    Path.extname(file) === engine.suffix) {
    
                    files.push(file);
                }
            });
    
            return files;
        };
    
        load();
    };
    
    
    internals.Manager.prototype._loadHelpers = function (engine) {
    
        if (!engine.config.helpersPath ||
            !engine.module.registerHelper ||
            typeof engine.module.registerHelper !== 'function') {
    
            return;
        }
    
        var helpersPaths = [].concat(engine.config.helpersPath);
    
        helpersPaths.forEach(function (helpersPath) {
    
            var path = internals.path(engine.config.relativeTo, helpersPath);
            if (!Hoek.isAbsolutePath(path)) {
                path = Path.join(process.cwd(), path);
            }
    
            Fs.readdirSync(path).forEach(function (file) {
    
                file = Path.join(path, file);
                var stat = Fs.statSync(file);
                if (!stat.isDirectory() &&
                    Path.basename(file)[0] !== '.') {
    
                    try {
                        var helper = require(file);
                        if (typeof helper === 'function') {
                            var offset = path.slice(-1) === Path.sep ? 0 : 1;
                            var name = file.slice(path.length + offset, -Path.extname(file).length);
                            engine.module.registerHelper(name, helper);
                        }
                    }
                    catch (err) { }
                }
            });
        });
    };
    
    
    internals.Manager.prototype.render = function (filename, context, options, callback) {
    
        var self = this;
    
        options = options || {};
    
        if (this._context) {
            var base = typeof this._context === 'function' ? this._context() : this._context;
            if (context) {
                base = Hoek.shallow(base);
                var keys = Object.keys(context);
                for (var i = 0, il = keys.length; i < il; ++i) {
                    var key = keys[i];
                    base[key] = context[key];
                }
            }
    
            context = base;
        }
    
        context = context || {};
    
        var engine = null;
    
        var fileExtension = Path.extname(filename).slice(1);
        var extension = fileExtension || this._defaultExtension;
        if (!extension) {
            return callback(Boom.badImplementation('Unknown extension and no defaultExtension configured for view template: ' + filename));
        }
    
        engine = this._engines[extension];
        if (!engine) {
            return callback(Boom.badImplementation('No view engine found for file: ' + filename));
        }
    
        var settings = Hoek.applyToDefaults(engine.config, options);
    
        this._path(filename + (fileExtension ? '' : engine.suffix), settings, false, function (err, templatePath) {
    
            if (err) {
                return callback(err);
            }
    
            self._compile(templatePath, engine, settings, function (err, compiled) {
    
                if (err) {
                    return callback(err);
                }
    
                // No layout
    
                if (!settings.layout) {
                    compiled(context, settings.runtimeOptions, function (err, rendered) {
    
                        if (err) {
                            return callback(Boom.badImplementation(err.message, err));
                        }
    
                        return callback(null, rendered, settings);
                    });
    
                    return;
                }
    
                // With layout
    
                if (context.hasOwnProperty(settings.layoutKeyword)) {
                    return callback(Boom.badImplementation('settings.layoutKeyword conflict', { context: context, keyword: settings.layoutKeyword }));
                }
    
                self._path((settings.layout === true ? 'layout' : settings.layout) + engine.suffix, settings, true, function (err, layoutPath) {
    
                    if (err) {
                        return callback(err);
                    }
    
                    self._compile(layoutPath, engine, settings, function (err, layout) {
    
                        if (err) {
                            return callback(err);
                        }
    
                        compiled(context, settings.runtimeOptions, function (err, rendered) {
    
                            if (err) {
                                return callback(Boom.badImplementation(err.message, err));
                            }
    
                            context[settings.layoutKeyword] = rendered;
                            layout(context, settings.runtimeOptions, function (err, rendered) {
    
                                delete context[settings.layoutKeyword];
    
                                if (err) {
                                    return callback(Boom.badImplementation(err.message, err));
                                }
    
                                return callback(null, rendered, settings);
                            });
                        });
                    });
                });
            });
        });
    };
    
    
    internals.Manager.prototype._path = function (template, settings, isLayout, next) {
    
        // Validate path
    
        var isAbsolutePath = Hoek.isAbsolutePath(template);
        var isInsecurePath = template.match(/\.\.\//g);
    
        if (!settings.allowAbsolutePaths &&
            isAbsolutePath) {
    
            return next(Boom.badImplementation('Absolute paths are not allowed in views'));
        }
    
        if (!settings.allowInsecureAccess &&
            isInsecurePath) {
    
            return next(Boom.badImplementation('View paths cannot lookup templates outside root path (path includes one or more \'../\')'));
        }
    
        // Resolve path and extension
    
        var paths;
        if (isAbsolutePath) {
            paths = [template];
        }
        else {
            paths = [].concat((isLayout && settings.layoutPath) || settings.path);
    
            for (var i = 0, il = paths.length; i < il; ++i) {
                paths[i] = internals.path(settings.relativeTo, paths[i], template);
            }
        }
    
        Items.serial(paths, function (path, nextFile) {
    
            Fs.stat(path, function (err, stats) {
    
                if (!err &&
                    stats.isFile()) {
    
                    return next(null, path);
                }
    
                return nextFile();
            });
        },
        function () {
    
            return next(Boom.badImplementation('View file not found: `' + template + '`. Locations searched: [' + paths.join(',') + ']'));
        });
    };
    
    
    internals.path = function (base, path, file) {
    
        if (path &&
            Hoek.isAbsolutePath(path)) {
    
            return Path.join(path, file || '');
        }
    
        return Path.join(base || '', path || '', file || '');
    };
    
    
    internals.Manager.prototype._compile = function (template, engine, settings, callback) {
    
        if (engine.cache &&
            engine.cache[template]) {
    
            return callback(null, engine.cache[template]);
        }
    
        settings.compileOptions.filename = template;            // Pass the template to Jade via this copy of compileOptions
    
        // Read file
    
        Fs.readFile(template, { encoding: settings.encoding }, function (err, data) {
    
            if (err) {
                return callback(Boom.badImplementation('Failed to read view file: ' + template));
            }
    
            engine.compileFunc(data, settings.compileOptions, function (err, compiled) {
    
                if (err) {
                    return callback(Boom.wrap(err));
                }
    
                if (engine.cache) {
                    engine.cache[template] = compiled;
                }
    
                return callback(null, compiled);
            });
        });
    };
    
    
    internals.Manager.prototype._response = function (template, context, options, request) {
    
        Joi.assert(options, internals.schema.viewOverride);
    
        var source = {
            manager: this,
            template: template,
            context: context,
            options: options
        };
    
        return request.generateResponse(source, { variety: 'view', marshal: internals.marshal });
    };
    
    
    internals.marshal = function (response, callback) {
    
        var manager = response.source.manager;
    
        manager.render(response.source.template, response.source.context, response.source.options, function (err, rendered, config) {
    
            if (err) {
                return callback(err);
            }
    
            if (!response.headers['content-type']) {
                response.type(config.contentType);
            }
    
            response.encoding(config.encoding);
    
            return callback(null, rendered);
        });
    };
    
  provide("vision/lib/manager", module.exports);
}(global));

// pakmanager:vision/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Fs = require('fs');
    var Path = require('path');
    var Boom = require('boom');
    var Hoek = require('hoek');
    var Joi = require('joi');
    var Items = require('items');
    var Manager =  require('vision/lib/manager');
    // Additional helper modules required in constructor
    
    
    // Declare internals
    
    var internals = {};
    
    
    internals.schema = Joi.alternatives([
        Joi.string(),
        Joi.object({
            template: Joi.string(),
            context: Joi.object(),
            options: Joi.object()
        })
    ]);
    
    
    exports.register = function (server, options, next) {
    
        server.decorate('server', 'views', function (options) {
    
            Hoek.assert(options, 'Missing views options');
            this.realm.plugins.vision = this.realm.plugins.vision || {};
            Hoek.assert(!this.realm.plugins.vision.manager, 'Cannot set views manager more than once');
    
            if (!options.relativeTo &&
                this.realm.settings.files.relativeTo) {
    
                options = Hoek.shallow(options);
                options.relativeTo = this.realm.settings.files.relativeTo;
            }
    
            this.realm.plugins.vision.manager = new Manager(options);
        });
    
        server.decorate('server', 'render', function (template, context, options, callback) {
    
            callback = (typeof callback === 'function' ? callback : options);
            options = (options === callback ? {} : options);
    
            var vision = (this.realm.plugins.vision || this.root.realm.plugins.vision || {});
            Hoek.assert(vision.manager, 'Missing views manager');
            return vision.manager.render(template, context, options, callback);
        });
    
        server.handler('view', internals.handler);
    
        server.decorate('reply', 'view', function (template, context, options) {
    
            var realm = (this.realm.plugins.vision || this.request.server.realm.plugins.vision || {});
            Hoek.assert(realm.manager, 'Cannot render view without a views manager configured');
            return this.response(realm.manager._response(template, context, options, this.request));
        });
    
        return next();
    };
    
    exports.register.attributes = {
        pkg: require('../package.json')
    };
    
    
    internals.handler = function (route, options) {
    
        Joi.assert(options, internals.schema, 'Invalid view handler options (' + route.path + ')');
    
        if (typeof options === 'string') {
            options = { template: options };
        }
    
        var settings = {                                                // Shallow copy to allow making dynamic changes to context
            template: options.template,
            context: options.context,
            options: options.options
        };
    
        return function (request, reply) {
    
            var context = {
                params: request.params,
                payload: request.payload,
                query: request.query,
                pre: request.pre
            };
    
            if (settings.context) {                                     // Shallow copy to avoid cloning unknown objects
                var keys = Object.keys(settings.context);
                for (var i = 0, il = keys.length; i < il; ++i) {
                    var key = keys[i];
                    context[key] = settings.context[key];
                }
            }
    
            reply.view(settings.template, context, settings.options);
        };
    };
    
  provide("vision/lib", module.exports);
}(global));

// pakmanager:vision
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('vision/lib');
    
  provide("vision", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/utils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    exports.__esModule = true;
    exports.extend = extend;
    
    // Older IE versions do not directly support indexOf so we must implement our own, sadly.
    exports.indexOf = indexOf;
    exports.escapeExpression = escapeExpression;
    exports.isEmpty = isEmpty;
    exports.blockParams = blockParams;
    exports.appendContextPath = appendContextPath;
    var escape = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      '\'': '&#x27;',
      '`': '&#x60;'
    };
    
    var badChars = /[&<>"'`]/g,
        possible = /[&<>"'`]/;
    
    function escapeChar(chr) {
      return escape[chr];
    }
    
    function extend(obj /* , ...source */) {
      for (var i = 1; i < arguments.length; i++) {
        for (var key in arguments[i]) {
          if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
            obj[key] = arguments[i][key];
          }
        }
      }
    
      return obj;
    }
    
    var toString = Object.prototype.toString;
    
    exports.toString = toString;
    // Sourced from lodash
    // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
    /*eslint-disable func-style, no-var */
    var isFunction = function isFunction(value) {
      return typeof value === 'function';
    };
    // fallback for older versions of Chrome and Safari
    /* istanbul ignore next */
    if (isFunction(/x/)) {
      exports.isFunction = isFunction = function (value) {
        return typeof value === 'function' && toString.call(value) === '[object Function]';
      };
    }
    var isFunction;
    exports.isFunction = isFunction;
    /*eslint-enable func-style, no-var */
    
    /* istanbul ignore next */
    var isArray = Array.isArray || function (value) {
      return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
    };exports.isArray = isArray;
    
    function indexOf(array, value) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    }
    
    function escapeExpression(string) {
      if (typeof string !== 'string') {
        // don't escape SafeStrings, since they're already safe
        if (string && string.toHTML) {
          return string.toHTML();
        } else if (string == null) {
          return '';
        } else if (!string) {
          return string + '';
        }
    
        // Force a string conversion as this will be done by the append regardless and
        // the regex test will do this transparently behind the scenes, causing issues if
        // an object's to string has escaped characters in it.
        string = '' + string;
      }
    
      if (!possible.test(string)) {
        return string;
      }
      return string.replace(badChars, escapeChar);
    }
    
    function isEmpty(value) {
      if (!value && value !== 0) {
        return true;
      } else if (isArray(value) && value.length === 0) {
        return true;
      } else {
        return false;
      }
    }
    
    function blockParams(params, ids) {
      params.path = ids;
      return params;
    }
    
    function appendContextPath(contextPath, id) {
      return (contextPath ? contextPath + '.' : '') + id;
    }
  provide("handlebars/dist/cjs/handlebars/utils", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/exception
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    exports.__esModule = true;
    
    var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];
    
    function Exception(message, node) {
      var loc = node && node.loc,
          line = undefined,
          column = undefined;
      if (loc) {
        line = loc.start.line;
        column = loc.start.column;
    
        message += ' - ' + line + ':' + column;
      }
    
      var tmp = Error.prototype.constructor.call(this, message);
    
      // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
      for (var idx = 0; idx < errorProps.length; idx++) {
        this[errorProps[idx]] = tmp[errorProps[idx]];
      }
    
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, Exception);
      }
    
      if (loc) {
        this.lineNumber = line;
        this.column = column;
      }
    }
    
    Exception.prototype = new Error();
    
    exports['default'] = Exception;
    module.exports = exports['default'];
  provide("handlebars/dist/cjs/handlebars/exception", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/compiler/ast
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    exports.__esModule = true;
    var AST = {
      Program: function Program(statements, blockParams, strip, locInfo) {
        this.loc = locInfo;
        this.type = 'Program';
        this.body = statements;
    
        this.blockParams = blockParams;
        this.strip = strip;
      },
    
      MustacheStatement: function MustacheStatement(path, params, hash, escaped, strip, locInfo) {
        this.loc = locInfo;
        this.type = 'MustacheStatement';
    
        this.path = path;
        this.params = params || [];
        this.hash = hash;
        this.escaped = escaped;
    
        this.strip = strip;
      },
    
      BlockStatement: function BlockStatement(path, params, hash, program, inverse, openStrip, inverseStrip, closeStrip, locInfo) {
        this.loc = locInfo;
        this.type = 'BlockStatement';
    
        this.path = path;
        this.params = params || [];
        this.hash = hash;
        this.program = program;
        this.inverse = inverse;
    
        this.openStrip = openStrip;
        this.inverseStrip = inverseStrip;
        this.closeStrip = closeStrip;
      },
    
      PartialStatement: function PartialStatement(name, params, hash, strip, locInfo) {
        this.loc = locInfo;
        this.type = 'PartialStatement';
    
        this.name = name;
        this.params = params || [];
        this.hash = hash;
    
        this.indent = '';
        this.strip = strip;
      },
    
      ContentStatement: function ContentStatement(string, locInfo) {
        this.loc = locInfo;
        this.type = 'ContentStatement';
        this.original = this.value = string;
      },
    
      CommentStatement: function CommentStatement(comment, strip, locInfo) {
        this.loc = locInfo;
        this.type = 'CommentStatement';
        this.value = comment;
    
        this.strip = strip;
      },
    
      SubExpression: function SubExpression(path, params, hash, locInfo) {
        this.loc = locInfo;
    
        this.type = 'SubExpression';
        this.path = path;
        this.params = params || [];
        this.hash = hash;
      },
    
      PathExpression: function PathExpression(data, depth, parts, original, locInfo) {
        this.loc = locInfo;
        this.type = 'PathExpression';
    
        this.data = data;
        this.original = original;
        this.parts = parts;
        this.depth = depth;
      },
    
      StringLiteral: function StringLiteral(string, locInfo) {
        this.loc = locInfo;
        this.type = 'StringLiteral';
        this.original = this.value = string;
      },
    
      NumberLiteral: function NumberLiteral(number, locInfo) {
        this.loc = locInfo;
        this.type = 'NumberLiteral';
        this.original = this.value = Number(number);
      },
    
      BooleanLiteral: function BooleanLiteral(bool, locInfo) {
        this.loc = locInfo;
        this.type = 'BooleanLiteral';
        this.original = this.value = bool === 'true';
      },
    
      UndefinedLiteral: function UndefinedLiteral(locInfo) {
        this.loc = locInfo;
        this.type = 'UndefinedLiteral';
        this.original = this.value = undefined;
      },
    
      NullLiteral: function NullLiteral(locInfo) {
        this.loc = locInfo;
        this.type = 'NullLiteral';
        this.original = this.value = null;
      },
    
      Hash: function Hash(pairs, locInfo) {
        this.loc = locInfo;
        this.type = 'Hash';
        this.pairs = pairs;
      },
      HashPair: function HashPair(key, value, locInfo) {
        this.loc = locInfo;
        this.type = 'HashPair';
        this.key = key;
        this.value = value;
      },
    
      // Public API used to evaluate derived attributes regarding AST nodes
      helpers: {
        // a mustache is definitely a helper if:
        // * it is an eligible helper, and
        // * it has at least one parameter or hash segment
        helperExpression: function helperExpression(node) {
          return !!(node.type === 'SubExpression' || node.params.length || node.hash);
        },
    
        scopedId: function scopedId(path) {
          return /^\.|this\b/.test(path.original);
        },
    
        // an ID is simple if it only has one part, and that part is not
        // `..` or `this`.
        simpleId: function simpleId(path) {
          return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
        }
      }
    };
    
    // Must be exported as an object rather than the root of the module as the jison lexer
    // must modify the object to operate properly.
    exports['default'] = AST;
    module.exports = exports['default'];
  provide("handlebars/dist/cjs/handlebars/compiler/ast", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/base
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    exports.HandlebarsEnvironment = HandlebarsEnvironment;
    exports.createFrame = createFrame;
    
    var _import =  require('handlebars/dist/cjs/handlebars/utils');
    
    var Utils = _interopRequireWildcard(_import);
    
    var _Exception =  require('handlebars/dist/cjs/handlebars/exception');
    
    var _Exception2 = _interopRequireWildcard(_Exception);
    
    var VERSION = '3.0.1';
    exports.VERSION = VERSION;
    var COMPILER_REVISION = 6;
    
    exports.COMPILER_REVISION = COMPILER_REVISION;
    var REVISION_CHANGES = {
      1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
      2: '== 1.0.0-rc.3',
      3: '== 1.0.0-rc.4',
      4: '== 1.x.x',
      5: '== 2.0.0-alpha.x',
      6: '>= 2.0.0-beta.1'
    };
    
    exports.REVISION_CHANGES = REVISION_CHANGES;
    var isArray = Utils.isArray,
        isFunction = Utils.isFunction,
        toString = Utils.toString,
        objectType = '[object Object]';
    
    function HandlebarsEnvironment(helpers, partials) {
      this.helpers = helpers || {};
      this.partials = partials || {};
    
      registerDefaultHelpers(this);
    }
    
    HandlebarsEnvironment.prototype = {
      constructor: HandlebarsEnvironment,
    
      logger: logger,
      log: log,
    
      registerHelper: function registerHelper(name, fn) {
        if (toString.call(name) === objectType) {
          if (fn) {
            throw new _Exception2['default']('Arg not supported with multiple helpers');
          }
          Utils.extend(this.helpers, name);
        } else {
          this.helpers[name] = fn;
        }
      },
      unregisterHelper: function unregisterHelper(name) {
        delete this.helpers[name];
      },
    
      registerPartial: function registerPartial(name, partial) {
        if (toString.call(name) === objectType) {
          Utils.extend(this.partials, name);
        } else {
          if (typeof partial === 'undefined') {
            throw new _Exception2['default']('Attempting to register a partial as undefined');
          }
          this.partials[name] = partial;
        }
      },
      unregisterPartial: function unregisterPartial(name) {
        delete this.partials[name];
      }
    };
    
    function registerDefaultHelpers(instance) {
      instance.registerHelper('helperMissing', function () {
        if (arguments.length === 1) {
          // A missing field in a {{foo}} constuct.
          return undefined;
        } else {
          // Someone is actually trying to call something, blow up.
          throw new _Exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
        }
      });
    
      instance.registerHelper('blockHelperMissing', function (context, options) {
        var inverse = options.inverse,
            fn = options.fn;
    
        if (context === true) {
          return fn(this);
        } else if (context === false || context == null) {
          return inverse(this);
        } else if (isArray(context)) {
          if (context.length > 0) {
            if (options.ids) {
              options.ids = [options.name];
            }
    
            return instance.helpers.each(context, options);
          } else {
            return inverse(this);
          }
        } else {
          if (options.data && options.ids) {
            var data = createFrame(options.data);
            data.contextPath = Utils.appendContextPath(options.data.contextPath, options.name);
            options = { data: data };
          }
    
          return fn(context, options);
        }
      });
    
      instance.registerHelper('each', function (context, options) {
        if (!options) {
          throw new _Exception2['default']('Must pass iterator to #each');
        }
    
        var fn = options.fn,
            inverse = options.inverse,
            i = 0,
            ret = '',
            data = undefined,
            contextPath = undefined;
    
        if (options.data && options.ids) {
          contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
        }
    
        if (isFunction(context)) {
          context = context.call(this);
        }
    
        if (options.data) {
          data = createFrame(options.data);
        }
    
        function execIteration(field, index, last) {
          if (data) {
            data.key = field;
            data.index = index;
            data.first = index === 0;
            data.last = !!last;
    
            if (contextPath) {
              data.contextPath = contextPath + field;
            }
          }
    
          ret = ret + fn(context[field], {
            data: data,
            blockParams: Utils.blockParams([context[field], field], [contextPath + field, null])
          });
        }
    
        if (context && typeof context === 'object') {
          if (isArray(context)) {
            for (var j = context.length; i < j; i++) {
              execIteration(i, i, i === context.length - 1);
            }
          } else {
            var priorKey = undefined;
    
            for (var key in context) {
              if (context.hasOwnProperty(key)) {
                // We're running the iterations one step out of sync so we can detect
                // the last iteration without have to scan the object twice and create
                // an itermediate keys array.
                if (priorKey) {
                  execIteration(priorKey, i - 1);
                }
                priorKey = key;
                i++;
              }
            }
            if (priorKey) {
              execIteration(priorKey, i - 1, true);
            }
          }
        }
    
        if (i === 0) {
          ret = inverse(this);
        }
    
        return ret;
      });
    
      instance.registerHelper('if', function (conditional, options) {
        if (isFunction(conditional)) {
          conditional = conditional.call(this);
        }
    
        // Default behavior is to render the positive path if the value is truthy and not empty.
        // The `includeZero` option may be set to treat the condtional as purely not empty based on the
        // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
        if (!options.hash.includeZero && !conditional || Utils.isEmpty(conditional)) {
          return options.inverse(this);
        } else {
          return options.fn(this);
        }
      });
    
      instance.registerHelper('unless', function (conditional, options) {
        return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
      });
    
      instance.registerHelper('with', function (context, options) {
        if (isFunction(context)) {
          context = context.call(this);
        }
    
        var fn = options.fn;
    
        if (!Utils.isEmpty(context)) {
          if (options.data && options.ids) {
            var data = createFrame(options.data);
            data.contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]);
            options = { data: data };
          }
    
          return fn(context, options);
        } else {
          return options.inverse(this);
        }
      });
    
      instance.registerHelper('log', function (message, options) {
        var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
        instance.log(level, message);
      });
    
      instance.registerHelper('lookup', function (obj, field) {
        return obj && obj[field];
      });
    }
    
    var logger = {
      methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },
    
      // State enum
      DEBUG: 0,
      INFO: 1,
      WARN: 2,
      ERROR: 3,
      level: 1,
    
      // Can be overridden in the host environment
      log: function log(level, message) {
        if (typeof console !== 'undefined' && logger.level <= level) {
          var method = logger.methodMap[level];
          (console[method] || console.log).call(console, message); // eslint-disable-line no-console
        }
      }
    };
    
    exports.logger = logger;
    var log = logger.log;
    
    exports.log = log;
    
    function createFrame(object) {
      var frame = Utils.extend({}, object);
      frame._parent = object;
      return frame;
    }
    
    /* [args, ]options */
  provide("handlebars/dist/cjs/handlebars/base", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/compiler/visitor
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    
    var _Exception =  require('handlebars/dist/cjs/handlebars/exception');
    
    var _Exception2 = _interopRequireWildcard(_Exception);
    
    var _AST =  require('handlebars/dist/cjs/handlebars/compiler/ast');
    
    var _AST2 = _interopRequireWildcard(_AST);
    
    function Visitor() {
      this.parents = [];
    }
    
    Visitor.prototype = {
      constructor: Visitor,
      mutating: false,
    
      // Visits a given value. If mutating, will replace the value if necessary.
      acceptKey: function acceptKey(node, name) {
        var value = this.accept(node[name]);
        if (this.mutating) {
          // Hacky sanity check:
          if (value && (!value.type || !_AST2['default'][value.type])) {
            throw new _Exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
          }
          node[name] = value;
        }
      },
    
      // Performs an accept operation with added sanity check to ensure
      // required keys are not removed.
      acceptRequired: function acceptRequired(node, name) {
        this.acceptKey(node, name);
    
        if (!node[name]) {
          throw new _Exception2['default'](node.type + ' requires ' + name);
        }
      },
    
      // Traverses a given array. If mutating, empty respnses will be removed
      // for child elements.
      acceptArray: function acceptArray(array) {
        for (var i = 0, l = array.length; i < l; i++) {
          this.acceptKey(array, i);
    
          if (!array[i]) {
            array.splice(i, 1);
            i--;
            l--;
          }
        }
      },
    
      accept: function accept(object) {
        if (!object) {
          return;
        }
    
        if (this.current) {
          this.parents.unshift(this.current);
        }
        this.current = object;
    
        var ret = this[object.type](object);
    
        this.current = this.parents.shift();
    
        if (!this.mutating || ret) {
          return ret;
        } else if (ret !== false) {
          return object;
        }
      },
    
      Program: function Program(program) {
        this.acceptArray(program.body);
      },
    
      MustacheStatement: function MustacheStatement(mustache) {
        this.acceptRequired(mustache, 'path');
        this.acceptArray(mustache.params);
        this.acceptKey(mustache, 'hash');
      },
    
      BlockStatement: function BlockStatement(block) {
        this.acceptRequired(block, 'path');
        this.acceptArray(block.params);
        this.acceptKey(block, 'hash');
    
        this.acceptKey(block, 'program');
        this.acceptKey(block, 'inverse');
      },
    
      PartialStatement: function PartialStatement(partial) {
        this.acceptRequired(partial, 'name');
        this.acceptArray(partial.params);
        this.acceptKey(partial, 'hash');
      },
    
      ContentStatement: function ContentStatement() {},
      CommentStatement: function CommentStatement() {},
    
      SubExpression: function SubExpression(sexpr) {
        this.acceptRequired(sexpr, 'path');
        this.acceptArray(sexpr.params);
        this.acceptKey(sexpr, 'hash');
      },
    
      PathExpression: function PathExpression() {},
    
      StringLiteral: function StringLiteral() {},
      NumberLiteral: function NumberLiteral() {},
      BooleanLiteral: function BooleanLiteral() {},
      UndefinedLiteral: function UndefinedLiteral() {},
      NullLiteral: function NullLiteral() {},
    
      Hash: function Hash(hash) {
        this.acceptArray(hash.pairs);
      },
      HashPair: function HashPair(pair) {
        this.acceptRequired(pair, 'value');
      }
    };
    
    exports['default'] = Visitor;
    module.exports = exports['default'];
    /* content */ /* comment */ /* path */ /* string */ /* number */ /* bool */ /* literal */ /* literal */
  provide("handlebars/dist/cjs/handlebars/compiler/visitor", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/safe-string
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    exports.__esModule = true;
    // Build out our basic SafeString type
    function SafeString(string) {
      this.string = string;
    }
    
    SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
      return '' + this.string;
    };
    
    exports['default'] = SafeString;
    module.exports = exports['default'];
  provide("handlebars/dist/cjs/handlebars/safe-string", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/runtime
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    exports.checkRevision = checkRevision;
    
    // TODO: Remove this line and break up compilePartial
    
    exports.template = template;
    exports.wrapProgram = wrapProgram;
    exports.resolvePartial = resolvePartial;
    exports.invokePartial = invokePartial;
    exports.noop = noop;
    
    var _import =  require('handlebars/dist/cjs/handlebars/utils');
    
    var Utils = _interopRequireWildcard(_import);
    
    var _Exception =  require('handlebars/dist/cjs/handlebars/exception');
    
    var _Exception2 = _interopRequireWildcard(_Exception);
    
    var _COMPILER_REVISION$REVISION_CHANGES$createFrame =  require('handlebars/dist/cjs/handlebars/base');
    
    function checkRevision(compilerInfo) {
      var compilerRevision = compilerInfo && compilerInfo[0] || 1,
          currentRevision = _COMPILER_REVISION$REVISION_CHANGES$createFrame.COMPILER_REVISION;
    
      if (compilerRevision !== currentRevision) {
        if (compilerRevision < currentRevision) {
          var runtimeVersions = _COMPILER_REVISION$REVISION_CHANGES$createFrame.REVISION_CHANGES[currentRevision],
              compilerVersions = _COMPILER_REVISION$REVISION_CHANGES$createFrame.REVISION_CHANGES[compilerRevision];
          throw new _Exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
        } else {
          // Use the embedded version info since the runtime doesn't know about this revision yet
          throw new _Exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
        }
      }
    }
    
    function template(templateSpec, env) {
      /* istanbul ignore next */
      if (!env) {
        throw new _Exception2['default']('No environment passed to template');
      }
      if (!templateSpec || !templateSpec.main) {
        throw new _Exception2['default']('Unknown template object: ' + typeof templateSpec);
      }
    
      // Note: Using env.VM references rather than local var references throughout this section to allow
      // for external users to override these as psuedo-supported APIs.
      env.VM.checkRevision(templateSpec.compiler);
    
      function invokePartialWrapper(partial, context, options) {
        if (options.hash) {
          context = Utils.extend({}, context, options.hash);
        }
    
        partial = env.VM.resolvePartial.call(this, partial, context, options);
        var result = env.VM.invokePartial.call(this, partial, context, options);
    
        if (result == null && env.compile) {
          options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
          result = options.partials[options.name](context, options);
        }
        if (result != null) {
          if (options.indent) {
            var lines = result.split('\n');
            for (var i = 0, l = lines.length; i < l; i++) {
              if (!lines[i] && i + 1 === l) {
                break;
              }
    
              lines[i] = options.indent + lines[i];
            }
            result = lines.join('\n');
          }
          return result;
        } else {
          throw new _Exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
        }
      }
    
      // Just add water
      var container = {
        strict: function strict(obj, name) {
          if (!(name in obj)) {
            throw new _Exception2['default']('"' + name + '" not defined in ' + obj);
          }
          return obj[name];
        },
        lookup: function lookup(depths, name) {
          var len = depths.length;
          for (var i = 0; i < len; i++) {
            if (depths[i] && depths[i][name] != null) {
              return depths[i][name];
            }
          }
        },
        lambda: function lambda(current, context) {
          return typeof current === 'function' ? current.call(context) : current;
        },
    
        escapeExpression: Utils.escapeExpression,
        invokePartial: invokePartialWrapper,
    
        fn: function fn(i) {
          return templateSpec[i];
        },
    
        programs: [],
        program: function program(i, data, declaredBlockParams, blockParams, depths) {
          var programWrapper = this.programs[i],
              fn = this.fn(i);
          if (data || depths || blockParams || declaredBlockParams) {
            programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
          } else if (!programWrapper) {
            programWrapper = this.programs[i] = wrapProgram(this, i, fn);
          }
          return programWrapper;
        },
    
        data: function data(value, depth) {
          while (value && depth--) {
            value = value._parent;
          }
          return value;
        },
        merge: function merge(param, common) {
          var obj = param || common;
    
          if (param && common && param !== common) {
            obj = Utils.extend({}, common, param);
          }
    
          return obj;
        },
    
        noop: env.VM.noop,
        compilerInfo: templateSpec.compiler
      };
    
      function ret(context) {
        var options = arguments[1] === undefined ? {} : arguments[1];
    
        var data = options.data;
    
        ret._setup(options);
        if (!options.partial && templateSpec.useData) {
          data = initData(context, data);
        }
        var depths = undefined,
            blockParams = templateSpec.useBlockParams ? [] : undefined;
        if (templateSpec.useDepths) {
          depths = options.depths ? [context].concat(options.depths) : [context];
        }
    
        return templateSpec.main.call(container, context, container.helpers, container.partials, data, blockParams, depths);
      }
      ret.isTop = true;
    
      ret._setup = function (options) {
        if (!options.partial) {
          container.helpers = container.merge(options.helpers, env.helpers);
    
          if (templateSpec.usePartial) {
            container.partials = container.merge(options.partials, env.partials);
          }
        } else {
          container.helpers = options.helpers;
          container.partials = options.partials;
        }
      };
    
      ret._child = function (i, data, blockParams, depths) {
        if (templateSpec.useBlockParams && !blockParams) {
          throw new _Exception2['default']('must pass block params');
        }
        if (templateSpec.useDepths && !depths) {
          throw new _Exception2['default']('must pass parent depths');
        }
    
        return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
      };
      return ret;
    }
    
    function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
      function prog(context) {
        var options = arguments[1] === undefined ? {} : arguments[1];
    
        return fn.call(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), depths && [context].concat(depths));
      }
      prog.program = i;
      prog.depth = depths ? depths.length : 0;
      prog.blockParams = declaredBlockParams || 0;
      return prog;
    }
    
    function resolvePartial(partial, context, options) {
      if (!partial) {
        partial = options.partials[options.name];
      } else if (!partial.call && !options.name) {
        // This is a dynamic partial that returned a string
        options.name = partial;
        partial = options.partials[partial];
      }
      return partial;
    }
    
    function invokePartial(partial, context, options) {
      options.partial = true;
    
      if (partial === undefined) {
        throw new _Exception2['default']('The partial ' + options.name + ' could not be found');
      } else if (partial instanceof Function) {
        return partial(context, options);
      }
    }
    
    function noop() {
      return '';
    }
    
    function initData(context, data) {
      if (!data || !('root' in data)) {
        data = data ? _COMPILER_REVISION$REVISION_CHANGES$createFrame.createFrame(data) : {};
        data.root = context;
      }
      return data;
    }
  provide("handlebars/dist/cjs/handlebars/runtime", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/no-conflict
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    exports.__esModule = true;
    /*global window */
    
    exports['default'] = function (Handlebars) {
      /* istanbul ignore next */
      var root = typeof global !== 'undefined' ? global : window,
          $Handlebars = root.Handlebars;
      /* istanbul ignore next */
      Handlebars.noConflict = function () {
        if (root.Handlebars === Handlebars) {
          root.Handlebars = $Handlebars;
        }
      };
    };
    
    module.exports = exports['default'];
  provide("handlebars/dist/cjs/handlebars/no-conflict", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/compiler/parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    
    exports.__esModule = true;
    /* istanbul ignore next */
    /* Jison generated parser */
    var handlebars = (function () {
        var parser = { trace: function trace() {},
            yy: {},
            symbols_: { error: 2, root: 3, program: 4, EOF: 5, program_repetition0: 6, statement: 7, mustache: 8, block: 9, rawBlock: 10, partial: 11, content: 12, COMMENT: 13, CONTENT: 14, openRawBlock: 15, END_RAW_BLOCK: 16, OPEN_RAW_BLOCK: 17, helperName: 18, openRawBlock_repetition0: 19, openRawBlock_option0: 20, CLOSE_RAW_BLOCK: 21, openBlock: 22, block_option0: 23, closeBlock: 24, openInverse: 25, block_option1: 26, OPEN_BLOCK: 27, openBlock_repetition0: 28, openBlock_option0: 29, openBlock_option1: 30, CLOSE: 31, OPEN_INVERSE: 32, openInverse_repetition0: 33, openInverse_option0: 34, openInverse_option1: 35, openInverseChain: 36, OPEN_INVERSE_CHAIN: 37, openInverseChain_repetition0: 38, openInverseChain_option0: 39, openInverseChain_option1: 40, inverseAndProgram: 41, INVERSE: 42, inverseChain: 43, inverseChain_option0: 44, OPEN_ENDBLOCK: 45, OPEN: 46, mustache_repetition0: 47, mustache_option0: 48, OPEN_UNESCAPED: 49, mustache_repetition1: 50, mustache_option1: 51, CLOSE_UNESCAPED: 52, OPEN_PARTIAL: 53, partialName: 54, partial_repetition0: 55, partial_option0: 56, param: 57, sexpr: 58, OPEN_SEXPR: 59, sexpr_repetition0: 60, sexpr_option0: 61, CLOSE_SEXPR: 62, hash: 63, hash_repetition_plus0: 64, hashSegment: 65, ID: 66, EQUALS: 67, blockParams: 68, OPEN_BLOCK_PARAMS: 69, blockParams_repetition_plus0: 70, CLOSE_BLOCK_PARAMS: 71, path: 72, dataName: 73, STRING: 74, NUMBER: 75, BOOLEAN: 76, UNDEFINED: 77, NULL: 78, DATA: 79, pathSegments: 80, SEP: 81, $accept: 0, $end: 1 },
            terminals_: { 2: "error", 5: "EOF", 13: "COMMENT", 14: "CONTENT", 16: "END_RAW_BLOCK", 17: "OPEN_RAW_BLOCK", 21: "CLOSE_RAW_BLOCK", 27: "OPEN_BLOCK", 31: "CLOSE", 32: "OPEN_INVERSE", 37: "OPEN_INVERSE_CHAIN", 42: "INVERSE", 45: "OPEN_ENDBLOCK", 46: "OPEN", 49: "OPEN_UNESCAPED", 52: "CLOSE_UNESCAPED", 53: "OPEN_PARTIAL", 59: "OPEN_SEXPR", 62: "CLOSE_SEXPR", 66: "ID", 67: "EQUALS", 69: "OPEN_BLOCK_PARAMS", 71: "CLOSE_BLOCK_PARAMS", 74: "STRING", 75: "NUMBER", 76: "BOOLEAN", 77: "UNDEFINED", 78: "NULL", 79: "DATA", 81: "SEP" },
            productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [12, 1], [10, 3], [15, 5], [9, 4], [9, 4], [22, 6], [25, 6], [36, 6], [41, 2], [43, 3], [43, 1], [24, 3], [8, 5], [8, 5], [11, 5], [57, 1], [57, 1], [58, 5], [63, 1], [65, 3], [68, 3], [18, 1], [18, 1], [18, 1], [18, 1], [18, 1], [18, 1], [18, 1], [54, 1], [54, 1], [73, 2], [72, 1], [80, 3], [80, 1], [6, 0], [6, 2], [19, 0], [19, 2], [20, 0], [20, 1], [23, 0], [23, 1], [26, 0], [26, 1], [28, 0], [28, 2], [29, 0], [29, 1], [30, 0], [30, 1], [33, 0], [33, 2], [34, 0], [34, 1], [35, 0], [35, 1], [38, 0], [38, 2], [39, 0], [39, 1], [40, 0], [40, 1], [44, 0], [44, 1], [47, 0], [47, 2], [48, 0], [48, 1], [50, 0], [50, 2], [51, 0], [51, 1], [55, 0], [55, 2], [56, 0], [56, 1], [60, 0], [60, 2], [61, 0], [61, 1], [64, 1], [64, 2], [70, 1], [70, 2]],
            performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
    
                var $0 = $$.length - 1;
                switch (yystate) {
                    case 1:
                        return $$[$0 - 1];
                        break;
                    case 2:
                        this.$ = new yy.Program($$[$0], null, {}, yy.locInfo(this._$));
                        break;
                    case 3:
                        this.$ = $$[$0];
                        break;
                    case 4:
                        this.$ = $$[$0];
                        break;
                    case 5:
                        this.$ = $$[$0];
                        break;
                    case 6:
                        this.$ = $$[$0];
                        break;
                    case 7:
                        this.$ = $$[$0];
                        break;
                    case 8:
                        this.$ = new yy.CommentStatement(yy.stripComment($$[$0]), yy.stripFlags($$[$0], $$[$0]), yy.locInfo(this._$));
                        break;
                    case 9:
                        this.$ = new yy.ContentStatement($$[$0], yy.locInfo(this._$));
                        break;
                    case 10:
                        this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                        break;
                    case 11:
                        this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
                        break;
                    case 12:
                        this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
                        break;
                    case 13:
                        this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
                        break;
                    case 14:
                        this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                        break;
                    case 15:
                        this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                        break;
                    case 16:
                        this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                        break;
                    case 17:
                        this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
                        break;
                    case 18:
                        var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
                            program = new yy.Program([inverse], null, {}, yy.locInfo(this._$));
                        program.chained = true;
    
                        this.$ = { strip: $$[$0 - 2].strip, program: program, chain: true };
    
                        break;
                    case 19:
                        this.$ = $$[$0];
                        break;
                    case 20:
                        this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
                        break;
                    case 21:
                        this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                        break;
                    case 22:
                        this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                        break;
                    case 23:
                        this.$ = new yy.PartialStatement($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], yy.stripFlags($$[$0 - 4], $$[$0]), yy.locInfo(this._$));
                        break;
                    case 24:
                        this.$ = $$[$0];
                        break;
                    case 25:
                        this.$ = $$[$0];
                        break;
                    case 26:
                        this.$ = new yy.SubExpression($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], yy.locInfo(this._$));
                        break;
                    case 27:
                        this.$ = new yy.Hash($$[$0], yy.locInfo(this._$));
                        break;
                    case 28:
                        this.$ = new yy.HashPair(yy.id($$[$0 - 2]), $$[$0], yy.locInfo(this._$));
                        break;
                    case 29:
                        this.$ = yy.id($$[$0 - 1]);
                        break;
                    case 30:
                        this.$ = $$[$0];
                        break;
                    case 31:
                        this.$ = $$[$0];
                        break;
                    case 32:
                        this.$ = new yy.StringLiteral($$[$0], yy.locInfo(this._$));
                        break;
                    case 33:
                        this.$ = new yy.NumberLiteral($$[$0], yy.locInfo(this._$));
                        break;
                    case 34:
                        this.$ = new yy.BooleanLiteral($$[$0], yy.locInfo(this._$));
                        break;
                    case 35:
                        this.$ = new yy.UndefinedLiteral(yy.locInfo(this._$));
                        break;
                    case 36:
                        this.$ = new yy.NullLiteral(yy.locInfo(this._$));
                        break;
                    case 37:
                        this.$ = $$[$0];
                        break;
                    case 38:
                        this.$ = $$[$0];
                        break;
                    case 39:
                        this.$ = yy.preparePath(true, $$[$0], this._$);
                        break;
                    case 40:
                        this.$ = yy.preparePath(false, $$[$0], this._$);
                        break;
                    case 41:
                        $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });this.$ = $$[$0 - 2];
                        break;
                    case 42:
                        this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
                        break;
                    case 43:
                        this.$ = [];
                        break;
                    case 44:
                        $$[$0 - 1].push($$[$0]);
                        break;
                    case 45:
                        this.$ = [];
                        break;
                    case 46:
                        $$[$0 - 1].push($$[$0]);
                        break;
                    case 53:
                        this.$ = [];
                        break;
                    case 54:
                        $$[$0 - 1].push($$[$0]);
                        break;
                    case 59:
                        this.$ = [];
                        break;
                    case 60:
                        $$[$0 - 1].push($$[$0]);
                        break;
                    case 65:
                        this.$ = [];
                        break;
                    case 66:
                        $$[$0 - 1].push($$[$0]);
                        break;
                    case 73:
                        this.$ = [];
                        break;
                    case 74:
                        $$[$0 - 1].push($$[$0]);
                        break;
                    case 77:
                        this.$ = [];
                        break;
                    case 78:
                        $$[$0 - 1].push($$[$0]);
                        break;
                    case 81:
                        this.$ = [];
                        break;
                    case 82:
                        $$[$0 - 1].push($$[$0]);
                        break;
                    case 85:
                        this.$ = [];
                        break;
                    case 86:
                        $$[$0 - 1].push($$[$0]);
                        break;
                    case 89:
                        this.$ = [$$[$0]];
                        break;
                    case 90:
                        $$[$0 - 1].push($$[$0]);
                        break;
                    case 91:
                        this.$ = [$$[$0]];
                        break;
                    case 92:
                        $$[$0 - 1].push($$[$0]);
                        break;
                }
            },
            table: [{ 3: 1, 4: 2, 5: [2, 43], 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: [1, 11], 14: [1, 18], 15: 16, 17: [1, 21], 22: 14, 25: 15, 27: [1, 19], 32: [1, 20], 37: [2, 2], 42: [2, 2], 45: [2, 2], 46: [1, 12], 49: [1, 13], 53: [1, 17] }, { 1: [2, 1] }, { 5: [2, 44], 13: [2, 44], 14: [2, 44], 17: [2, 44], 27: [2, 44], 32: [2, 44], 37: [2, 44], 42: [2, 44], 45: [2, 44], 46: [2, 44], 49: [2, 44], 53: [2, 44] }, { 5: [2, 3], 13: [2, 3], 14: [2, 3], 17: [2, 3], 27: [2, 3], 32: [2, 3], 37: [2, 3], 42: [2, 3], 45: [2, 3], 46: [2, 3], 49: [2, 3], 53: [2, 3] }, { 5: [2, 4], 13: [2, 4], 14: [2, 4], 17: [2, 4], 27: [2, 4], 32: [2, 4], 37: [2, 4], 42: [2, 4], 45: [2, 4], 46: [2, 4], 49: [2, 4], 53: [2, 4] }, { 5: [2, 5], 13: [2, 5], 14: [2, 5], 17: [2, 5], 27: [2, 5], 32: [2, 5], 37: [2, 5], 42: [2, 5], 45: [2, 5], 46: [2, 5], 49: [2, 5], 53: [2, 5] }, { 5: [2, 6], 13: [2, 6], 14: [2, 6], 17: [2, 6], 27: [2, 6], 32: [2, 6], 37: [2, 6], 42: [2, 6], 45: [2, 6], 46: [2, 6], 49: [2, 6], 53: [2, 6] }, { 5: [2, 7], 13: [2, 7], 14: [2, 7], 17: [2, 7], 27: [2, 7], 32: [2, 7], 37: [2, 7], 42: [2, 7], 45: [2, 7], 46: [2, 7], 49: [2, 7], 53: [2, 7] }, { 5: [2, 8], 13: [2, 8], 14: [2, 8], 17: [2, 8], 27: [2, 8], 32: [2, 8], 37: [2, 8], 42: [2, 8], 45: [2, 8], 46: [2, 8], 49: [2, 8], 53: [2, 8] }, { 18: 22, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 33, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 4: 34, 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 37: [2, 43], 42: [2, 43], 45: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 4: 35, 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 42: [2, 43], 45: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 12: 36, 14: [1, 18] }, { 18: 38, 54: 37, 58: 39, 59: [1, 40], 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 5: [2, 9], 13: [2, 9], 14: [2, 9], 16: [2, 9], 17: [2, 9], 27: [2, 9], 32: [2, 9], 37: [2, 9], 42: [2, 9], 45: [2, 9], 46: [2, 9], 49: [2, 9], 53: [2, 9] }, { 18: 41, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 42, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 43, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 31: [2, 73], 47: 44, 59: [2, 73], 66: [2, 73], 74: [2, 73], 75: [2, 73], 76: [2, 73], 77: [2, 73], 78: [2, 73], 79: [2, 73] }, { 21: [2, 30], 31: [2, 30], 52: [2, 30], 59: [2, 30], 62: [2, 30], 66: [2, 30], 69: [2, 30], 74: [2, 30], 75: [2, 30], 76: [2, 30], 77: [2, 30], 78: [2, 30], 79: [2, 30] }, { 21: [2, 31], 31: [2, 31], 52: [2, 31], 59: [2, 31], 62: [2, 31], 66: [2, 31], 69: [2, 31], 74: [2, 31], 75: [2, 31], 76: [2, 31], 77: [2, 31], 78: [2, 31], 79: [2, 31] }, { 21: [2, 32], 31: [2, 32], 52: [2, 32], 59: [2, 32], 62: [2, 32], 66: [2, 32], 69: [2, 32], 74: [2, 32], 75: [2, 32], 76: [2, 32], 77: [2, 32], 78: [2, 32], 79: [2, 32] }, { 21: [2, 33], 31: [2, 33], 52: [2, 33], 59: [2, 33], 62: [2, 33], 66: [2, 33], 69: [2, 33], 74: [2, 33], 75: [2, 33], 76: [2, 33], 77: [2, 33], 78: [2, 33], 79: [2, 33] }, { 21: [2, 34], 31: [2, 34], 52: [2, 34], 59: [2, 34], 62: [2, 34], 66: [2, 34], 69: [2, 34], 74: [2, 34], 75: [2, 34], 76: [2, 34], 77: [2, 34], 78: [2, 34], 79: [2, 34] }, { 21: [2, 35], 31: [2, 35], 52: [2, 35], 59: [2, 35], 62: [2, 35], 66: [2, 35], 69: [2, 35], 74: [2, 35], 75: [2, 35], 76: [2, 35], 77: [2, 35], 78: [2, 35], 79: [2, 35] }, { 21: [2, 36], 31: [2, 36], 52: [2, 36], 59: [2, 36], 62: [2, 36], 66: [2, 36], 69: [2, 36], 74: [2, 36], 75: [2, 36], 76: [2, 36], 77: [2, 36], 78: [2, 36], 79: [2, 36] }, { 21: [2, 40], 31: [2, 40], 52: [2, 40], 59: [2, 40], 62: [2, 40], 66: [2, 40], 69: [2, 40], 74: [2, 40], 75: [2, 40], 76: [2, 40], 77: [2, 40], 78: [2, 40], 79: [2, 40], 81: [1, 45] }, { 66: [1, 32], 80: 46 }, { 21: [2, 42], 31: [2, 42], 52: [2, 42], 59: [2, 42], 62: [2, 42], 66: [2, 42], 69: [2, 42], 74: [2, 42], 75: [2, 42], 76: [2, 42], 77: [2, 42], 78: [2, 42], 79: [2, 42], 81: [2, 42] }, { 50: 47, 52: [2, 77], 59: [2, 77], 66: [2, 77], 74: [2, 77], 75: [2, 77], 76: [2, 77], 77: [2, 77], 78: [2, 77], 79: [2, 77] }, { 23: 48, 36: 50, 37: [1, 52], 41: 51, 42: [1, 53], 43: 49, 45: [2, 49] }, { 26: 54, 41: 55, 42: [1, 53], 45: [2, 51] }, { 16: [1, 56] }, { 31: [2, 81], 55: 57, 59: [2, 81], 66: [2, 81], 74: [2, 81], 75: [2, 81], 76: [2, 81], 77: [2, 81], 78: [2, 81], 79: [2, 81] }, { 31: [2, 37], 59: [2, 37], 66: [2, 37], 74: [2, 37], 75: [2, 37], 76: [2, 37], 77: [2, 37], 78: [2, 37], 79: [2, 37] }, { 31: [2, 38], 59: [2, 38], 66: [2, 38], 74: [2, 38], 75: [2, 38], 76: [2, 38], 77: [2, 38], 78: [2, 38], 79: [2, 38] }, { 18: 58, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 28: 59, 31: [2, 53], 59: [2, 53], 66: [2, 53], 69: [2, 53], 74: [2, 53], 75: [2, 53], 76: [2, 53], 77: [2, 53], 78: [2, 53], 79: [2, 53] }, { 31: [2, 59], 33: 60, 59: [2, 59], 66: [2, 59], 69: [2, 59], 74: [2, 59], 75: [2, 59], 76: [2, 59], 77: [2, 59], 78: [2, 59], 79: [2, 59] }, { 19: 61, 21: [2, 45], 59: [2, 45], 66: [2, 45], 74: [2, 45], 75: [2, 45], 76: [2, 45], 77: [2, 45], 78: [2, 45], 79: [2, 45] }, { 18: 65, 31: [2, 75], 48: 62, 57: 63, 58: 66, 59: [1, 40], 63: 64, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 66: [1, 70] }, { 21: [2, 39], 31: [2, 39], 52: [2, 39], 59: [2, 39], 62: [2, 39], 66: [2, 39], 69: [2, 39], 74: [2, 39], 75: [2, 39], 76: [2, 39], 77: [2, 39], 78: [2, 39], 79: [2, 39], 81: [1, 45] }, { 18: 65, 51: 71, 52: [2, 79], 57: 72, 58: 66, 59: [1, 40], 63: 73, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 24: 74, 45: [1, 75] }, { 45: [2, 50] }, { 4: 76, 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 37: [2, 43], 42: [2, 43], 45: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 45: [2, 19] }, { 18: 77, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 4: 78, 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 45: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 24: 79, 45: [1, 75] }, { 45: [2, 52] }, { 5: [2, 10], 13: [2, 10], 14: [2, 10], 17: [2, 10], 27: [2, 10], 32: [2, 10], 37: [2, 10], 42: [2, 10], 45: [2, 10], 46: [2, 10], 49: [2, 10], 53: [2, 10] }, { 18: 65, 31: [2, 83], 56: 80, 57: 81, 58: 66, 59: [1, 40], 63: 82, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 59: [2, 85], 60: 83, 62: [2, 85], 66: [2, 85], 74: [2, 85], 75: [2, 85], 76: [2, 85], 77: [2, 85], 78: [2, 85], 79: [2, 85] }, { 18: 65, 29: 84, 31: [2, 55], 57: 85, 58: 66, 59: [1, 40], 63: 86, 64: 67, 65: 68, 66: [1, 69], 69: [2, 55], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 65, 31: [2, 61], 34: 87, 57: 88, 58: 66, 59: [1, 40], 63: 89, 64: 67, 65: 68, 66: [1, 69], 69: [2, 61], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 65, 20: 90, 21: [2, 47], 57: 91, 58: 66, 59: [1, 40], 63: 92, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 31: [1, 93] }, { 31: [2, 74], 59: [2, 74], 66: [2, 74], 74: [2, 74], 75: [2, 74], 76: [2, 74], 77: [2, 74], 78: [2, 74], 79: [2, 74] }, { 31: [2, 76] }, { 21: [2, 24], 31: [2, 24], 52: [2, 24], 59: [2, 24], 62: [2, 24], 66: [2, 24], 69: [2, 24], 74: [2, 24], 75: [2, 24], 76: [2, 24], 77: [2, 24], 78: [2, 24], 79: [2, 24] }, { 21: [2, 25], 31: [2, 25], 52: [2, 25], 59: [2, 25], 62: [2, 25], 66: [2, 25], 69: [2, 25], 74: [2, 25], 75: [2, 25], 76: [2, 25], 77: [2, 25], 78: [2, 25], 79: [2, 25] }, { 21: [2, 27], 31: [2, 27], 52: [2, 27], 62: [2, 27], 65: 94, 66: [1, 95], 69: [2, 27] }, { 21: [2, 89], 31: [2, 89], 52: [2, 89], 62: [2, 89], 66: [2, 89], 69: [2, 89] }, { 21: [2, 42], 31: [2, 42], 52: [2, 42], 59: [2, 42], 62: [2, 42], 66: [2, 42], 67: [1, 96], 69: [2, 42], 74: [2, 42], 75: [2, 42], 76: [2, 42], 77: [2, 42], 78: [2, 42], 79: [2, 42], 81: [2, 42] }, { 21: [2, 41], 31: [2, 41], 52: [2, 41], 59: [2, 41], 62: [2, 41], 66: [2, 41], 69: [2, 41], 74: [2, 41], 75: [2, 41], 76: [2, 41], 77: [2, 41], 78: [2, 41], 79: [2, 41], 81: [2, 41] }, { 52: [1, 97] }, { 52: [2, 78], 59: [2, 78], 66: [2, 78], 74: [2, 78], 75: [2, 78], 76: [2, 78], 77: [2, 78], 78: [2, 78], 79: [2, 78] }, { 52: [2, 80] }, { 5: [2, 12], 13: [2, 12], 14: [2, 12], 17: [2, 12], 27: [2, 12], 32: [2, 12], 37: [2, 12], 42: [2, 12], 45: [2, 12], 46: [2, 12], 49: [2, 12], 53: [2, 12] }, { 18: 98, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 36: 50, 37: [1, 52], 41: 51, 42: [1, 53], 43: 100, 44: 99, 45: [2, 71] }, { 31: [2, 65], 38: 101, 59: [2, 65], 66: [2, 65], 69: [2, 65], 74: [2, 65], 75: [2, 65], 76: [2, 65], 77: [2, 65], 78: [2, 65], 79: [2, 65] }, { 45: [2, 17] }, { 5: [2, 13], 13: [2, 13], 14: [2, 13], 17: [2, 13], 27: [2, 13], 32: [2, 13], 37: [2, 13], 42: [2, 13], 45: [2, 13], 46: [2, 13], 49: [2, 13], 53: [2, 13] }, { 31: [1, 102] }, { 31: [2, 82], 59: [2, 82], 66: [2, 82], 74: [2, 82], 75: [2, 82], 76: [2, 82], 77: [2, 82], 78: [2, 82], 79: [2, 82] }, { 31: [2, 84] }, { 18: 65, 57: 104, 58: 66, 59: [1, 40], 61: 103, 62: [2, 87], 63: 105, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 30: 106, 31: [2, 57], 68: 107, 69: [1, 108] }, { 31: [2, 54], 59: [2, 54], 66: [2, 54], 69: [2, 54], 74: [2, 54], 75: [2, 54], 76: [2, 54], 77: [2, 54], 78: [2, 54], 79: [2, 54] }, { 31: [2, 56], 69: [2, 56] }, { 31: [2, 63], 35: 109, 68: 110, 69: [1, 108] }, { 31: [2, 60], 59: [2, 60], 66: [2, 60], 69: [2, 60], 74: [2, 60], 75: [2, 60], 76: [2, 60], 77: [2, 60], 78: [2, 60], 79: [2, 60] }, { 31: [2, 62], 69: [2, 62] }, { 21: [1, 111] }, { 21: [2, 46], 59: [2, 46], 66: [2, 46], 74: [2, 46], 75: [2, 46], 76: [2, 46], 77: [2, 46], 78: [2, 46], 79: [2, 46] }, { 21: [2, 48] }, { 5: [2, 21], 13: [2, 21], 14: [2, 21], 17: [2, 21], 27: [2, 21], 32: [2, 21], 37: [2, 21], 42: [2, 21], 45: [2, 21], 46: [2, 21], 49: [2, 21], 53: [2, 21] }, { 21: [2, 90], 31: [2, 90], 52: [2, 90], 62: [2, 90], 66: [2, 90], 69: [2, 90] }, { 67: [1, 96] }, { 18: 65, 57: 112, 58: 66, 59: [1, 40], 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 5: [2, 22], 13: [2, 22], 14: [2, 22], 17: [2, 22], 27: [2, 22], 32: [2, 22], 37: [2, 22], 42: [2, 22], 45: [2, 22], 46: [2, 22], 49: [2, 22], 53: [2, 22] }, { 31: [1, 113] }, { 45: [2, 18] }, { 45: [2, 72] }, { 18: 65, 31: [2, 67], 39: 114, 57: 115, 58: 66, 59: [1, 40], 63: 116, 64: 67, 65: 68, 66: [1, 69], 69: [2, 67], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 5: [2, 23], 13: [2, 23], 14: [2, 23], 17: [2, 23], 27: [2, 23], 32: [2, 23], 37: [2, 23], 42: [2, 23], 45: [2, 23], 46: [2, 23], 49: [2, 23], 53: [2, 23] }, { 62: [1, 117] }, { 59: [2, 86], 62: [2, 86], 66: [2, 86], 74: [2, 86], 75: [2, 86], 76: [2, 86], 77: [2, 86], 78: [2, 86], 79: [2, 86] }, { 62: [2, 88] }, { 31: [1, 118] }, { 31: [2, 58] }, { 66: [1, 120], 70: 119 }, { 31: [1, 121] }, { 31: [2, 64] }, { 14: [2, 11] }, { 21: [2, 28], 31: [2, 28], 52: [2, 28], 62: [2, 28], 66: [2, 28], 69: [2, 28] }, { 5: [2, 20], 13: [2, 20], 14: [2, 20], 17: [2, 20], 27: [2, 20], 32: [2, 20], 37: [2, 20], 42: [2, 20], 45: [2, 20], 46: [2, 20], 49: [2, 20], 53: [2, 20] }, { 31: [2, 69], 40: 122, 68: 123, 69: [1, 108] }, { 31: [2, 66], 59: [2, 66], 66: [2, 66], 69: [2, 66], 74: [2, 66], 75: [2, 66], 76: [2, 66], 77: [2, 66], 78: [2, 66], 79: [2, 66] }, { 31: [2, 68], 69: [2, 68] }, { 21: [2, 26], 31: [2, 26], 52: [2, 26], 59: [2, 26], 62: [2, 26], 66: [2, 26], 69: [2, 26], 74: [2, 26], 75: [2, 26], 76: [2, 26], 77: [2, 26], 78: [2, 26], 79: [2, 26] }, { 13: [2, 14], 14: [2, 14], 17: [2, 14], 27: [2, 14], 32: [2, 14], 37: [2, 14], 42: [2, 14], 45: [2, 14], 46: [2, 14], 49: [2, 14], 53: [2, 14] }, { 66: [1, 125], 71: [1, 124] }, { 66: [2, 91], 71: [2, 91] }, { 13: [2, 15], 14: [2, 15], 17: [2, 15], 27: [2, 15], 32: [2, 15], 42: [2, 15], 45: [2, 15], 46: [2, 15], 49: [2, 15], 53: [2, 15] }, { 31: [1, 126] }, { 31: [2, 70] }, { 31: [2, 29] }, { 66: [2, 92], 71: [2, 92] }, { 13: [2, 16], 14: [2, 16], 17: [2, 16], 27: [2, 16], 32: [2, 16], 37: [2, 16], 42: [2, 16], 45: [2, 16], 46: [2, 16], 49: [2, 16], 53: [2, 16] }],
            defaultActions: { 4: [2, 1], 49: [2, 50], 51: [2, 19], 55: [2, 52], 64: [2, 76], 73: [2, 80], 78: [2, 17], 82: [2, 84], 92: [2, 48], 99: [2, 18], 100: [2, 72], 105: [2, 88], 107: [2, 58], 110: [2, 64], 111: [2, 11], 123: [2, 70], 124: [2, 29] },
            parseError: function parseError(str, hash) {
                throw new Error(str);
            },
            parse: function parse(input) {
                var self = this,
                    stack = [0],
                    vstack = [null],
                    lstack = [],
                    table = this.table,
                    yytext = "",
                    yylineno = 0,
                    yyleng = 0,
                    recovering = 0,
                    TERROR = 2,
                    EOF = 1;
                this.lexer.setInput(input);
                this.lexer.yy = this.yy;
                this.yy.lexer = this.lexer;
                this.yy.parser = this;
                if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
                var yyloc = this.lexer.yylloc;
                lstack.push(yyloc);
                var ranges = this.lexer.options && this.lexer.options.ranges;
                if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
                function popStack(n) {
                    stack.length = stack.length - 2 * n;
                    vstack.length = vstack.length - n;
                    lstack.length = lstack.length - n;
                }
                function lex() {
                    var token;
                    token = self.lexer.lex() || 1;
                    if (typeof token !== "number") {
                        token = self.symbols_[token] || token;
                    }
                    return token;
                }
                var symbol,
                    preErrorSymbol,
                    state,
                    action,
                    a,
                    r,
                    yyval = {},
                    p,
                    len,
                    newState,
                    expected;
                while (true) {
                    state = stack[stack.length - 1];
                    if (this.defaultActions[state]) {
                        action = this.defaultActions[state];
                    } else {
                        if (symbol === null || typeof symbol == "undefined") {
                            symbol = lex();
                        }
                        action = table[state] && table[state][symbol];
                    }
                    if (typeof action === "undefined" || !action.length || !action[0]) {
                        var errStr = "";
                        if (!recovering) {
                            expected = [];
                            for (p in table[state]) if (this.terminals_[p] && p > 2) {
                                expected.push("'" + this.terminals_[p] + "'");
                            }
                            if (this.lexer.showPosition) {
                                errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                            } else {
                                errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                            }
                            this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
                        }
                    }
                    if (action[0] instanceof Array && action.length > 1) {
                        throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                    }
                    switch (action[0]) {
                        case 1:
                            stack.push(symbol);
                            vstack.push(this.lexer.yytext);
                            lstack.push(this.lexer.yylloc);
                            stack.push(action[1]);
                            symbol = null;
                            if (!preErrorSymbol) {
                                yyleng = this.lexer.yyleng;
                                yytext = this.lexer.yytext;
                                yylineno = this.lexer.yylineno;
                                yyloc = this.lexer.yylloc;
                                if (recovering > 0) recovering--;
                            } else {
                                symbol = preErrorSymbol;
                                preErrorSymbol = null;
                            }
                            break;
                        case 2:
                            len = this.productions_[action[1]][1];
                            yyval.$ = vstack[vstack.length - len];
                            yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                            if (ranges) {
                                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                            }
                            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                            if (typeof r !== "undefined") {
                                return r;
                            }
                            if (len) {
                                stack = stack.slice(0, -1 * len * 2);
                                vstack = vstack.slice(0, -1 * len);
                                lstack = lstack.slice(0, -1 * len);
                            }
                            stack.push(this.productions_[action[1]][0]);
                            vstack.push(yyval.$);
                            lstack.push(yyval._$);
                            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                            stack.push(newState);
                            break;
                        case 3:
                            return true;
                    }
                }
                return true;
            }
        };
        /* Jison generated lexer */
        var lexer = (function () {
            var lexer = { EOF: 1,
                parseError: function parseError(str, hash) {
                    if (this.yy.parser) {
                        this.yy.parser.parseError(str, hash);
                    } else {
                        throw new Error(str);
                    }
                },
                setInput: function setInput(input) {
                    this._input = input;
                    this._more = this._less = this.done = false;
                    this.yylineno = this.yyleng = 0;
                    this.yytext = this.matched = this.match = "";
                    this.conditionStack = ["INITIAL"];
                    this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
                    if (this.options.ranges) this.yylloc.range = [0, 0];
                    this.offset = 0;
                    return this;
                },
                input: function input() {
                    var ch = this._input[0];
                    this.yytext += ch;
                    this.yyleng++;
                    this.offset++;
                    this.match += ch;
                    this.matched += ch;
                    var lines = ch.match(/(?:\r\n?|\n).*/g);
                    if (lines) {
                        this.yylineno++;
                        this.yylloc.last_line++;
                    } else {
                        this.yylloc.last_column++;
                    }
                    if (this.options.ranges) this.yylloc.range[1]++;
    
                    this._input = this._input.slice(1);
                    return ch;
                },
                unput: function unput(ch) {
                    var len = ch.length;
                    var lines = ch.split(/(?:\r\n?|\n)/g);
    
                    this._input = ch + this._input;
                    this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
                    //this.yyleng -= len;
                    this.offset -= len;
                    var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                    this.match = this.match.substr(0, this.match.length - 1);
                    this.matched = this.matched.substr(0, this.matched.length - 1);
    
                    if (lines.length - 1) this.yylineno -= lines.length - 1;
                    var r = this.yylloc.range;
    
                    this.yylloc = { first_line: this.yylloc.first_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.first_column,
                        last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                    };
    
                    if (this.options.ranges) {
                        this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                    }
                    return this;
                },
                more: function more() {
                    this._more = true;
                    return this;
                },
                less: function less(n) {
                    this.unput(this.match.slice(n));
                },
                pastInput: function pastInput() {
                    var past = this.matched.substr(0, this.matched.length - this.match.length);
                    return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
                },
                upcomingInput: function upcomingInput() {
                    var next = this.match;
                    if (next.length < 20) {
                        next += this._input.substr(0, 20 - next.length);
                    }
                    return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
                },
                showPosition: function showPosition() {
                    var pre = this.pastInput();
                    var c = new Array(pre.length + 1).join("-");
                    return pre + this.upcomingInput() + "\n" + c + "^";
                },
                next: function next() {
                    if (this.done) {
                        return this.EOF;
                    }
                    if (!this._input) this.done = true;
    
                    var token, match, tempMatch, index, col, lines;
                    if (!this._more) {
                        this.yytext = "";
                        this.match = "";
                    }
                    var rules = this._currentRules();
                    for (var i = 0; i < rules.length; i++) {
                        tempMatch = this._input.match(this.rules[rules[i]]);
                        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                            match = tempMatch;
                            index = i;
                            if (!this.options.flex) break;
                        }
                    }
                    if (match) {
                        lines = match[0].match(/(?:\r\n?|\n).*/g);
                        if (lines) this.yylineno += lines.length;
                        this.yylloc = { first_line: this.yylloc.last_line,
                            last_line: this.yylineno + 1,
                            first_column: this.yylloc.last_column,
                            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length };
                        this.yytext += match[0];
                        this.match += match[0];
                        this.matches = match;
                        this.yyleng = this.yytext.length;
                        if (this.options.ranges) {
                            this.yylloc.range = [this.offset, this.offset += this.yyleng];
                        }
                        this._more = false;
                        this._input = this._input.slice(match[0].length);
                        this.matched += match[0];
                        token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                        if (this.done && this._input) this.done = false;
                        if (token) {
                            return token;
                        } else {
                            return;
                        }
                    }
                    if (this._input === "") {
                        return this.EOF;
                    } else {
                        return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno });
                    }
                },
                lex: function lex() {
                    var r = this.next();
                    if (typeof r !== "undefined") {
                        return r;
                    } else {
                        return this.lex();
                    }
                },
                begin: function begin(condition) {
                    this.conditionStack.push(condition);
                },
                popState: function popState() {
                    return this.conditionStack.pop();
                },
                _currentRules: function _currentRules() {
                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                },
                topState: function topState() {
                    return this.conditionStack[this.conditionStack.length - 2];
                },
                pushState: function begin(condition) {
                    this.begin(condition);
                } };
            lexer.options = {};
            lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
    
                function strip(start, end) {
                    return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
                }
    
                var YYSTATE = YY_START;
                switch ($avoiding_name_collisions) {
                    case 0:
                        if (yy_.yytext.slice(-2) === "\\\\") {
                            strip(0, 1);
                            this.begin("mu");
                        } else if (yy_.yytext.slice(-1) === "\\") {
                            strip(0, 1);
                            this.begin("emu");
                        } else {
                            this.begin("mu");
                        }
                        if (yy_.yytext) {
                            return 14;
                        }break;
                    case 1:
                        return 14;
                        break;
                    case 2:
                        this.popState();
                        return 14;
    
                        break;
                    case 3:
                        yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);
                        this.popState();
                        return 16;
    
                        break;
                    case 4:
                        return 14;
                        break;
                    case 5:
                        this.popState();
                        return 13;
    
                        break;
                    case 6:
                        return 59;
                        break;
                    case 7:
                        return 62;
                        break;
                    case 8:
                        return 17;
                        break;
                    case 9:
                        this.popState();
                        this.begin("raw");
                        return 21;
    
                        break;
                    case 10:
                        return 53;
                        break;
                    case 11:
                        return 27;
                        break;
                    case 12:
                        return 45;
                        break;
                    case 13:
                        this.popState();return 42;
                        break;
                    case 14:
                        this.popState();return 42;
                        break;
                    case 15:
                        return 32;
                        break;
                    case 16:
                        return 37;
                        break;
                    case 17:
                        return 49;
                        break;
                    case 18:
                        return 46;
                        break;
                    case 19:
                        this.unput(yy_.yytext);
                        this.popState();
                        this.begin("com");
    
                        break;
                    case 20:
                        this.popState();
                        return 13;
    
                        break;
                    case 21:
                        return 46;
                        break;
                    case 22:
                        return 67;
                        break;
                    case 23:
                        return 66;
                        break;
                    case 24:
                        return 66;
                        break;
                    case 25:
                        return 81;
                        break;
                    case 26:
                        // ignore whitespace
                        break;
                    case 27:
                        this.popState();return 52;
                        break;
                    case 28:
                        this.popState();return 31;
                        break;
                    case 29:
                        yy_.yytext = strip(1, 2).replace(/\\"/g, "\"");return 74;
                        break;
                    case 30:
                        yy_.yytext = strip(1, 2).replace(/\\'/g, "'");return 74;
                        break;
                    case 31:
                        return 79;
                        break;
                    case 32:
                        return 76;
                        break;
                    case 33:
                        return 76;
                        break;
                    case 34:
                        return 77;
                        break;
                    case 35:
                        return 78;
                        break;
                    case 36:
                        return 75;
                        break;
                    case 37:
                        return 69;
                        break;
                    case 38:
                        return 71;
                        break;
                    case 39:
                        return 66;
                        break;
                    case 40:
                        return 66;
                        break;
                    case 41:
                        return "INVALID";
                        break;
                    case 42:
                        return 5;
                        break;
                }
            };
            lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]*?(?=(\{\{\{\{\/)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[[^\]]*\])/, /^(?:.)/, /^(?:$)/];
            lexer.conditions = { mu: { rules: [6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42], inclusive: false }, emu: { rules: [2], inclusive: false }, com: { rules: [5], inclusive: false }, raw: { rules: [3, 4], inclusive: false }, INITIAL: { rules: [0, 1, 42], inclusive: true } };
            return lexer;
        })();
        parser.lexer = lexer;
        function Parser() {
            this.yy = {};
        }Parser.prototype = parser;parser.Parser = Parser;
        return new Parser();
    })();exports["default"] = handlebars;
    module.exports = exports["default"];
  provide("handlebars/dist/cjs/handlebars/compiler/parser", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/compiler/whitespace-control
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    
    var _Visitor =  require('handlebars/dist/cjs/handlebars/compiler/visitor');
    
    var _Visitor2 = _interopRequireWildcard(_Visitor);
    
    function WhitespaceControl() {}
    WhitespaceControl.prototype = new _Visitor2['default']();
    
    WhitespaceControl.prototype.Program = function (program) {
      var isRoot = !this.isRootSeen;
      this.isRootSeen = true;
    
      var body = program.body;
      for (var i = 0, l = body.length; i < l; i++) {
        var current = body[i],
            strip = this.accept(current);
    
        if (!strip) {
          continue;
        }
    
        var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
            _isNextWhitespace = isNextWhitespace(body, i, isRoot),
            openStandalone = strip.openStandalone && _isPrevWhitespace,
            closeStandalone = strip.closeStandalone && _isNextWhitespace,
            inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
    
        if (strip.close) {
          omitRight(body, i, true);
        }
        if (strip.open) {
          omitLeft(body, i, true);
        }
    
        if (inlineStandalone) {
          omitRight(body, i);
    
          if (omitLeft(body, i)) {
            // If we are on a standalone node, save the indent info for partials
            if (current.type === 'PartialStatement') {
              // Pull out the whitespace from the final line
              current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
            }
          }
        }
        if (openStandalone) {
          omitRight((current.program || current.inverse).body);
    
          // Strip out the previous content node if it's whitespace only
          omitLeft(body, i);
        }
        if (closeStandalone) {
          // Always strip the next node
          omitRight(body, i);
    
          omitLeft((current.inverse || current.program).body);
        }
      }
    
      return program;
    };
    WhitespaceControl.prototype.BlockStatement = function (block) {
      this.accept(block.program);
      this.accept(block.inverse);
    
      // Find the inverse program that is involed with whitespace stripping.
      var program = block.program || block.inverse,
          inverse = block.program && block.inverse,
          firstInverse = inverse,
          lastInverse = inverse;
    
      if (inverse && inverse.chained) {
        firstInverse = inverse.body[0].program;
    
        // Walk the inverse chain to find the last inverse that is actually in the chain.
        while (lastInverse.chained) {
          lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
        }
      }
    
      var strip = {
        open: block.openStrip.open,
        close: block.closeStrip.close,
    
        // Determine the standalone candiacy. Basically flag our content as being possibly standalone
        // so our parent can determine if we actually are standalone
        openStandalone: isNextWhitespace(program.body),
        closeStandalone: isPrevWhitespace((firstInverse || program).body)
      };
    
      if (block.openStrip.close) {
        omitRight(program.body, null, true);
      }
    
      if (inverse) {
        var inverseStrip = block.inverseStrip;
    
        if (inverseStrip.open) {
          omitLeft(program.body, null, true);
        }
    
        if (inverseStrip.close) {
          omitRight(firstInverse.body, null, true);
        }
        if (block.closeStrip.open) {
          omitLeft(lastInverse.body, null, true);
        }
    
        // Find standalone else statments
        if (isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
          omitLeft(program.body);
          omitRight(firstInverse.body);
        }
      } else if (block.closeStrip.open) {
        omitLeft(program.body, null, true);
      }
    
      return strip;
    };
    
    WhitespaceControl.prototype.MustacheStatement = function (mustache) {
      return mustache.strip;
    };
    
    WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
      /* istanbul ignore next */
      var strip = node.strip || {};
      return {
        inlineStandalone: true,
        open: strip.open,
        close: strip.close
      };
    };
    
    function isPrevWhitespace(body, i, isRoot) {
      if (i === undefined) {
        i = body.length;
      }
    
      // Nodes that end with newlines are considered whitespace (but are special
      // cased for strip operations)
      var prev = body[i - 1],
          sibling = body[i - 2];
      if (!prev) {
        return isRoot;
      }
    
      if (prev.type === 'ContentStatement') {
        return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
      }
    }
    function isNextWhitespace(body, i, isRoot) {
      if (i === undefined) {
        i = -1;
      }
    
      var next = body[i + 1],
          sibling = body[i + 2];
      if (!next) {
        return isRoot;
      }
    
      if (next.type === 'ContentStatement') {
        return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
      }
    }
    
    // Marks the node to the right of the position as omitted.
    // I.e. {{foo}}' ' will mark the ' ' node as omitted.
    //
    // If i is undefined, then the first child will be marked as such.
    //
    // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
    // content is met.
    function omitRight(body, i, multiple) {
      var current = body[i == null ? 0 : i + 1];
      if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
        return;
      }
    
      var original = current.value;
      current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
      current.rightStripped = current.value !== original;
    }
    
    // Marks the node to the left of the position as omitted.
    // I.e. ' '{{foo}} will mark the ' ' node as omitted.
    //
    // If i is undefined then the last child will be marked as such.
    //
    // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
    // content is met.
    function omitLeft(body, i, multiple) {
      var current = body[i == null ? body.length - 1 : i - 1];
      if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
        return;
      }
    
      // We omit the last node if it's whitespace only and not preceeded by a non-content node.
      var original = current.value;
      current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
      current.leftStripped = current.value !== original;
      return current.leftStripped;
    }
    
    exports['default'] = WhitespaceControl;
    module.exports = exports['default'];
  provide("handlebars/dist/cjs/handlebars/compiler/whitespace-control", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/compiler/helpers
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    exports.SourceLocation = SourceLocation;
    exports.id = id;
    exports.stripFlags = stripFlags;
    exports.stripComment = stripComment;
    exports.preparePath = preparePath;
    exports.prepareMustache = prepareMustache;
    exports.prepareRawBlock = prepareRawBlock;
    exports.prepareBlock = prepareBlock;
    
    var _Exception =  require('handlebars/dist/cjs/handlebars/exception');
    
    var _Exception2 = _interopRequireWildcard(_Exception);
    
    function SourceLocation(source, locInfo) {
      this.source = source;
      this.start = {
        line: locInfo.first_line,
        column: locInfo.first_column
      };
      this.end = {
        line: locInfo.last_line,
        column: locInfo.last_column
      };
    }
    
    function id(token) {
      if (/^\[.*\]$/.test(token)) {
        return token.substr(1, token.length - 2);
      } else {
        return token;
      }
    }
    
    function stripFlags(open, close) {
      return {
        open: open.charAt(2) === '~',
        close: close.charAt(close.length - 3) === '~'
      };
    }
    
    function stripComment(comment) {
      return comment.replace(/^\{\{~?\!-?-?/, '').replace(/-?-?~?\}\}$/, '');
    }
    
    function preparePath(data, parts, locInfo) {
      locInfo = this.locInfo(locInfo);
    
      var original = data ? '@' : '',
          dig = [],
          depth = 0,
          depthString = '';
    
      for (var i = 0, l = parts.length; i < l; i++) {
        var part = parts[i].part,
    
        // If we have [] syntax then we do not treat path references as operators,
        // i.e. foo.[this] resolves to approximately context.foo['this']
        isLiteral = parts[i].original !== part;
        original += (parts[i].separator || '') + part;
    
        if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
          if (dig.length > 0) {
            throw new _Exception2['default']('Invalid path: ' + original, { loc: locInfo });
          } else if (part === '..') {
            depth++;
            depthString += '../';
          }
        } else {
          dig.push(part);
        }
      }
    
      return new this.PathExpression(data, depth, dig, original, locInfo);
    }
    
    function prepareMustache(path, params, hash, open, strip, locInfo) {
      // Must use charAt to support IE pre-10
      var escapeFlag = open.charAt(3) || open.charAt(2),
          escaped = escapeFlag !== '{' && escapeFlag !== '&';
    
      return new this.MustacheStatement(path, params, hash, escaped, strip, this.locInfo(locInfo));
    }
    
    function prepareRawBlock(openRawBlock, content, close, locInfo) {
      if (openRawBlock.path.original !== close) {
        var errorNode = { loc: openRawBlock.path.loc };
    
        throw new _Exception2['default'](openRawBlock.path.original + ' doesn\'t match ' + close, errorNode);
      }
    
      locInfo = this.locInfo(locInfo);
      var program = new this.Program([content], null, {}, locInfo);
    
      return new this.BlockStatement(openRawBlock.path, openRawBlock.params, openRawBlock.hash, program, undefined, {}, {}, {}, locInfo);
    }
    
    function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
      // When we are chaining inverse calls, we will not have a close path
      if (close && close.path && openBlock.path.original !== close.path.original) {
        var errorNode = { loc: openBlock.path.loc };
    
        throw new _Exception2['default'](openBlock.path.original + ' doesn\'t match ' + close.path.original, errorNode);
      }
    
      program.blockParams = openBlock.blockParams;
    
      var inverse = undefined,
          inverseStrip = undefined;
    
      if (inverseAndProgram) {
        if (inverseAndProgram.chain) {
          inverseAndProgram.program.body[0].closeStrip = close.strip;
        }
    
        inverseStrip = inverseAndProgram.strip;
        inverse = inverseAndProgram.program;
      }
    
      if (inverted) {
        inverted = inverse;
        inverse = program;
        program = inverted;
      }
    
      return new this.BlockStatement(openBlock.path, openBlock.params, openBlock.hash, program, inverse, openBlock.strip, inverseStrip, close && close.strip, this.locInfo(locInfo));
    }
  provide("handlebars/dist/cjs/handlebars/compiler/helpers", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/compiler/code-gen
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    exports.__esModule = true;
    /*global define */
    
    var _isArray =  require('handlebars/dist/cjs/handlebars/utils');
    
    var SourceNode = undefined;
    
    try {
      /* istanbul ignore next */
      if (typeof define !== 'function' || !define.amd) {
        // We don't support this in AMD environments. For these environments, we asusme that
        // they are running on the browser and thus have no need for the source-map library.
        var SourceMap = require('source-map');
        SourceNode = SourceMap.SourceNode;
      }
    } catch (err) {}
    
    /* istanbul ignore if: tested but not covered in istanbul due to dist build  */
    if (!SourceNode) {
      SourceNode = function (line, column, srcFile, chunks) {
        this.src = '';
        if (chunks) {
          this.add(chunks);
        }
      };
      /* istanbul ignore next */
      SourceNode.prototype = {
        add: function add(chunks) {
          if (_isArray.isArray(chunks)) {
            chunks = chunks.join('');
          }
          this.src += chunks;
        },
        prepend: function prepend(chunks) {
          if (_isArray.isArray(chunks)) {
            chunks = chunks.join('');
          }
          this.src = chunks + this.src;
        },
        toStringWithSourceMap: function toStringWithSourceMap() {
          return { code: this.toString() };
        },
        toString: function toString() {
          return this.src;
        }
      };
    }
    
    function castChunk(chunk, codeGen, loc) {
      if (_isArray.isArray(chunk)) {
        var ret = [];
    
        for (var i = 0, len = chunk.length; i < len; i++) {
          ret.push(codeGen.wrap(chunk[i], loc));
        }
        return ret;
      } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
        // Handle primitives that the SourceNode will throw up on
        return chunk + '';
      }
      return chunk;
    }
    
    function CodeGen(srcFile) {
      this.srcFile = srcFile;
      this.source = [];
    }
    
    CodeGen.prototype = {
      prepend: function prepend(source, loc) {
        this.source.unshift(this.wrap(source, loc));
      },
      push: function push(source, loc) {
        this.source.push(this.wrap(source, loc));
      },
    
      merge: function merge() {
        var source = this.empty();
        this.each(function (line) {
          source.add(['  ', line, '\n']);
        });
        return source;
      },
    
      each: function each(iter) {
        for (var i = 0, len = this.source.length; i < len; i++) {
          iter(this.source[i]);
        }
      },
    
      empty: function empty() {
        var loc = arguments[0] === undefined ? this.currentLocation || { start: {} } : arguments[0];
    
        return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
      },
      wrap: function wrap(chunk) {
        var loc = arguments[1] === undefined ? this.currentLocation || { start: {} } : arguments[1];
    
        if (chunk instanceof SourceNode) {
          return chunk;
        }
    
        chunk = castChunk(chunk, this, loc);
    
        return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
      },
    
      functionCall: function functionCall(fn, type, params) {
        params = this.generateList(params);
        return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
      },
    
      quotedString: function quotedString(str) {
        return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
        .replace(/\u2029/g, '\\u2029') + '"';
      },
    
      objectLiteral: function objectLiteral(obj) {
        var pairs = [];
    
        for (var key in obj) {
          if (obj.hasOwnProperty(key)) {
            var value = castChunk(obj[key], this);
            if (value !== 'undefined') {
              pairs.push([this.quotedString(key), ':', value]);
            }
          }
        }
    
        var ret = this.generateList(pairs);
        ret.prepend('{');
        ret.add('}');
        return ret;
      },
    
      generateList: function generateList(entries, loc) {
        var ret = this.empty(loc);
    
        for (var i = 0, len = entries.length; i < len; i++) {
          if (i) {
            ret.add(',');
          }
    
          ret.add(castChunk(entries[i], this, loc));
        }
    
        return ret;
      },
    
      generateArray: function generateArray(entries, loc) {
        var ret = this.generateList(entries, loc);
        ret.prepend('[');
        ret.add(']');
    
        return ret;
      }
    };
    
    exports['default'] = CodeGen;
    module.exports = exports['default'];
    
    /* NOP */
  provide("handlebars/dist/cjs/handlebars/compiler/code-gen", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars.runtime
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    
    var _import =  require('handlebars/dist/cjs/handlebars/base');
    
    var base = _interopRequireWildcard(_import);
    
    // Each of these augment the Handlebars object. No need to setup here.
    // (This is done to easily share code between commonjs and browse envs)
    
    var _SafeString =  require('handlebars/dist/cjs/handlebars/safe-string');
    
    var _SafeString2 = _interopRequireWildcard(_SafeString);
    
    var _Exception =  require('handlebars/dist/cjs/handlebars/exception');
    
    var _Exception2 = _interopRequireWildcard(_Exception);
    
    var _import2 =  require('handlebars/dist/cjs/handlebars/utils');
    
    var Utils = _interopRequireWildcard(_import2);
    
    var _import3 =  require('handlebars/dist/cjs/handlebars/runtime');
    
    var runtime = _interopRequireWildcard(_import3);
    
    var _noConflict =  require('handlebars/dist/cjs/handlebars/no-conflict');
    
    var _noConflict2 = _interopRequireWildcard(_noConflict);
    
    // For compatibility and usage outside of module systems, make the Handlebars object a namespace
    function create() {
      var hb = new base.HandlebarsEnvironment();
    
      Utils.extend(hb, base);
      hb.SafeString = _SafeString2['default'];
      hb.Exception = _Exception2['default'];
      hb.Utils = Utils;
      hb.escapeExpression = Utils.escapeExpression;
    
      hb.VM = runtime;
      hb.template = function (spec) {
        return runtime.template(spec, hb);
      };
    
      return hb;
    }
    
    var inst = create();
    inst.create = create;
    
    _noConflict2['default'](inst);
    
    inst['default'] = inst;
    
    exports['default'] = inst;
    module.exports = exports['default'];
  provide("handlebars/dist/cjs/handlebars.runtime", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/compiler/base
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    exports.parse = parse;
    
    var _parser =  require('handlebars/dist/cjs/handlebars/compiler/parser');
    
    var _parser2 = _interopRequireWildcard(_parser);
    
    var _AST =  require('handlebars/dist/cjs/handlebars/compiler/ast');
    
    var _AST2 = _interopRequireWildcard(_AST);
    
    var _WhitespaceControl =  require('handlebars/dist/cjs/handlebars/compiler/whitespace-control');
    
    var _WhitespaceControl2 = _interopRequireWildcard(_WhitespaceControl);
    
    var _import =  require('handlebars/dist/cjs/handlebars/compiler/helpers');
    
    var Helpers = _interopRequireWildcard(_import);
    
    var _extend =  require('handlebars/dist/cjs/handlebars/utils');
    
    exports.parser = _parser2['default'];
    
    var yy = {};
    _extend.extend(yy, Helpers, _AST2['default']);
    
    function parse(input, options) {
      // Just return if an already-compiled AST was passed in.
      if (input.type === 'Program') {
        return input;
      }
    
      _parser2['default'].yy = yy;
    
      // Altering the shared object here, but this is ok as parser is a sync operation
      yy.locInfo = function (locInfo) {
        return new yy.SourceLocation(options && options.srcName, locInfo);
      };
    
      var strip = new _WhitespaceControl2['default']();
      return strip.accept(_parser2['default'].parse(input));
    }
  provide("handlebars/dist/cjs/handlebars/compiler/base", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/compiler/compiler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    exports.Compiler = Compiler;
    exports.precompile = precompile;
    exports.compile = compile;
    
    var _Exception =  require('handlebars/dist/cjs/handlebars/exception');
    
    var _Exception2 = _interopRequireWildcard(_Exception);
    
    var _isArray$indexOf =  require('handlebars/dist/cjs/handlebars/utils');
    
    var _AST =  require('handlebars/dist/cjs/handlebars/compiler/ast');
    
    var _AST2 = _interopRequireWildcard(_AST);
    
    var slice = [].slice;
    
    function Compiler() {}
    
    // the foundHelper register will disambiguate helper lookup from finding a
    // function in a context. This is necessary for mustache compatibility, which
    // requires that context functions in blocks are evaluated by blockHelperMissing,
    // and then proceed as if the resulting value was provided to blockHelperMissing.
    
    Compiler.prototype = {
      compiler: Compiler,
    
      equals: function equals(other) {
        var len = this.opcodes.length;
        if (other.opcodes.length !== len) {
          return false;
        }
    
        for (var i = 0; i < len; i++) {
          var opcode = this.opcodes[i],
              otherOpcode = other.opcodes[i];
          if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
            return false;
          }
        }
    
        // We know that length is the same between the two arrays because they are directly tied
        // to the opcode behavior above.
        len = this.children.length;
        for (var i = 0; i < len; i++) {
          if (!this.children[i].equals(other.children[i])) {
            return false;
          }
        }
    
        return true;
      },
    
      guid: 0,
    
      compile: function compile(program, options) {
        this.sourceNode = [];
        this.opcodes = [];
        this.children = [];
        this.options = options;
        this.stringParams = options.stringParams;
        this.trackIds = options.trackIds;
    
        options.blockParams = options.blockParams || [];
    
        // These changes will propagate to the other compiler components
        var knownHelpers = options.knownHelpers;
        options.knownHelpers = {
          helperMissing: true,
          blockHelperMissing: true,
          each: true,
          'if': true,
          unless: true,
          'with': true,
          log: true,
          lookup: true
        };
        if (knownHelpers) {
          for (var _name in knownHelpers) {
            if (_name in knownHelpers) {
              options.knownHelpers[_name] = knownHelpers[_name];
            }
          }
        }
    
        return this.accept(program);
      },
    
      compileProgram: function compileProgram(program) {
        var childCompiler = new this.compiler(),
            // eslint-disable-line new-cap
        result = childCompiler.compile(program, this.options),
            guid = this.guid++;
    
        this.usePartial = this.usePartial || result.usePartial;
    
        this.children[guid] = result;
        this.useDepths = this.useDepths || result.useDepths;
    
        return guid;
      },
    
      accept: function accept(node) {
        this.sourceNode.unshift(node);
        var ret = this[node.type](node);
        this.sourceNode.shift();
        return ret;
      },
    
      Program: function Program(program) {
        this.options.blockParams.unshift(program.blockParams);
    
        var body = program.body,
            bodyLength = body.length;
        for (var i = 0; i < bodyLength; i++) {
          this.accept(body[i]);
        }
    
        this.options.blockParams.shift();
    
        this.isSimple = bodyLength === 1;
        this.blockParams = program.blockParams ? program.blockParams.length : 0;
    
        return this;
      },
    
      BlockStatement: function BlockStatement(block) {
        transformLiteralToPath(block);
    
        var program = block.program,
            inverse = block.inverse;
    
        program = program && this.compileProgram(program);
        inverse = inverse && this.compileProgram(inverse);
    
        var type = this.classifySexpr(block);
    
        if (type === 'helper') {
          this.helperSexpr(block, program, inverse);
        } else if (type === 'simple') {
          this.simpleSexpr(block);
    
          // now that the simple mustache is resolved, we need to
          // evaluate it by executing `blockHelperMissing`
          this.opcode('pushProgram', program);
          this.opcode('pushProgram', inverse);
          this.opcode('emptyHash');
          this.opcode('blockValue', block.path.original);
        } else {
          this.ambiguousSexpr(block, program, inverse);
    
          // now that the simple mustache is resolved, we need to
          // evaluate it by executing `blockHelperMissing`
          this.opcode('pushProgram', program);
          this.opcode('pushProgram', inverse);
          this.opcode('emptyHash');
          this.opcode('ambiguousBlockValue');
        }
    
        this.opcode('append');
      },
    
      PartialStatement: function PartialStatement(partial) {
        this.usePartial = true;
    
        var params = partial.params;
        if (params.length > 1) {
          throw new _Exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
        } else if (!params.length) {
          params.push({ type: 'PathExpression', parts: [], depth: 0 });
        }
    
        var partialName = partial.name.original,
            isDynamic = partial.name.type === 'SubExpression';
        if (isDynamic) {
          this.accept(partial.name);
        }
    
        this.setupFullMustacheParams(partial, undefined, undefined, true);
    
        var indent = partial.indent || '';
        if (this.options.preventIndent && indent) {
          this.opcode('appendContent', indent);
          indent = '';
        }
    
        this.opcode('invokePartial', isDynamic, partialName, indent);
        this.opcode('append');
      },
    
      MustacheStatement: function MustacheStatement(mustache) {
        this.SubExpression(mustache); // eslint-disable-line new-cap
    
        if (mustache.escaped && !this.options.noEscape) {
          this.opcode('appendEscaped');
        } else {
          this.opcode('append');
        }
      },
    
      ContentStatement: function ContentStatement(content) {
        if (content.value) {
          this.opcode('appendContent', content.value);
        }
      },
    
      CommentStatement: function CommentStatement() {},
    
      SubExpression: function SubExpression(sexpr) {
        transformLiteralToPath(sexpr);
        var type = this.classifySexpr(sexpr);
    
        if (type === 'simple') {
          this.simpleSexpr(sexpr);
        } else if (type === 'helper') {
          this.helperSexpr(sexpr);
        } else {
          this.ambiguousSexpr(sexpr);
        }
      },
      ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
        var path = sexpr.path,
            name = path.parts[0],
            isBlock = program != null || inverse != null;
    
        this.opcode('getContext', path.depth);
    
        this.opcode('pushProgram', program);
        this.opcode('pushProgram', inverse);
    
        this.accept(path);
    
        this.opcode('invokeAmbiguous', name, isBlock);
      },
    
      simpleSexpr: function simpleSexpr(sexpr) {
        this.accept(sexpr.path);
        this.opcode('resolvePossibleLambda');
      },
    
      helperSexpr: function helperSexpr(sexpr, program, inverse) {
        var params = this.setupFullMustacheParams(sexpr, program, inverse),
            path = sexpr.path,
            name = path.parts[0];
    
        if (this.options.knownHelpers[name]) {
          this.opcode('invokeKnownHelper', params.length, name);
        } else if (this.options.knownHelpersOnly) {
          throw new _Exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
        } else {
          path.falsy = true;
    
          this.accept(path);
          this.opcode('invokeHelper', params.length, path.original, _AST2['default'].helpers.simpleId(path));
        }
      },
    
      PathExpression: function PathExpression(path) {
        this.addDepth(path.depth);
        this.opcode('getContext', path.depth);
    
        var name = path.parts[0],
            scoped = _AST2['default'].helpers.scopedId(path),
            blockParamId = !path.depth && !scoped && this.blockParamIndex(name);
    
        if (blockParamId) {
          this.opcode('lookupBlockParam', blockParamId, path.parts);
        } else if (!name) {
          // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
          this.opcode('pushContext');
        } else if (path.data) {
          this.options.data = true;
          this.opcode('lookupData', path.depth, path.parts);
        } else {
          this.opcode('lookupOnContext', path.parts, path.falsy, scoped);
        }
      },
    
      StringLiteral: function StringLiteral(string) {
        this.opcode('pushString', string.value);
      },
    
      NumberLiteral: function NumberLiteral(number) {
        this.opcode('pushLiteral', number.value);
      },
    
      BooleanLiteral: function BooleanLiteral(bool) {
        this.opcode('pushLiteral', bool.value);
      },
    
      UndefinedLiteral: function UndefinedLiteral() {
        this.opcode('pushLiteral', 'undefined');
      },
    
      NullLiteral: function NullLiteral() {
        this.opcode('pushLiteral', 'null');
      },
    
      Hash: function Hash(hash) {
        var pairs = hash.pairs,
            i = 0,
            l = pairs.length;
    
        this.opcode('pushHash');
    
        for (; i < l; i++) {
          this.pushParam(pairs[i].value);
        }
        while (i--) {
          this.opcode('assignToHash', pairs[i].key);
        }
        this.opcode('popHash');
      },
    
      // HELPERS
      opcode: function opcode(name) {
        this.opcodes.push({ opcode: name, args: slice.call(arguments, 1), loc: this.sourceNode[0].loc });
      },
    
      addDepth: function addDepth(depth) {
        if (!depth) {
          return;
        }
    
        this.useDepths = true;
      },
    
      classifySexpr: function classifySexpr(sexpr) {
        var isSimple = _AST2['default'].helpers.simpleId(sexpr.path);
    
        var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);
    
        // a mustache is an eligible helper if:
        // * its id is simple (a single part, not `this` or `..`)
        var isHelper = !isBlockParam && _AST2['default'].helpers.helperExpression(sexpr);
    
        // if a mustache is an eligible helper but not a definite
        // helper, it is ambiguous, and will be resolved in a later
        // pass or at runtime.
        var isEligible = !isBlockParam && (isHelper || isSimple);
    
        // if ambiguous, we can possibly resolve the ambiguity now
        // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
        if (isEligible && !isHelper) {
          var _name2 = sexpr.path.parts[0],
              options = this.options;
    
          if (options.knownHelpers[_name2]) {
            isHelper = true;
          } else if (options.knownHelpersOnly) {
            isEligible = false;
          }
        }
    
        if (isHelper) {
          return 'helper';
        } else if (isEligible) {
          return 'ambiguous';
        } else {
          return 'simple';
        }
      },
    
      pushParams: function pushParams(params) {
        for (var i = 0, l = params.length; i < l; i++) {
          this.pushParam(params[i]);
        }
      },
    
      pushParam: function pushParam(val) {
        var value = val.value != null ? val.value : val.original || '';
    
        if (this.stringParams) {
          if (value.replace) {
            value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
          }
    
          if (val.depth) {
            this.addDepth(val.depth);
          }
          this.opcode('getContext', val.depth || 0);
          this.opcode('pushStringParam', value, val.type);
    
          if (val.type === 'SubExpression') {
            // SubExpressions get evaluated and passed in
            // in string params mode.
            this.accept(val);
          }
        } else {
          if (this.trackIds) {
            var blockParamIndex = undefined;
            if (val.parts && !_AST2['default'].helpers.scopedId(val) && !val.depth) {
              blockParamIndex = this.blockParamIndex(val.parts[0]);
            }
            if (blockParamIndex) {
              var blockParamChild = val.parts.slice(1).join('.');
              this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
            } else {
              value = val.original || value;
              if (value.replace) {
                value = value.replace(/^\.\//g, '').replace(/^\.$/g, '');
              }
    
              this.opcode('pushId', val.type, value);
            }
          }
          this.accept(val);
        }
      },
    
      setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
        var params = sexpr.params;
        this.pushParams(params);
    
        this.opcode('pushProgram', program);
        this.opcode('pushProgram', inverse);
    
        if (sexpr.hash) {
          this.accept(sexpr.hash);
        } else {
          this.opcode('emptyHash', omitEmpty);
        }
    
        return params;
      },
    
      blockParamIndex: function blockParamIndex(name) {
        for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
          var blockParams = this.options.blockParams[depth],
              param = blockParams && _isArray$indexOf.indexOf(blockParams, name);
          if (blockParams && param >= 0) {
            return [depth, param];
          }
        }
      }
    };
    
    function precompile(input, options, env) {
      if (input == null || typeof input !== 'string' && input.type !== 'Program') {
        throw new _Exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
      }
    
      options = options || {};
      if (!('data' in options)) {
        options.data = true;
      }
      if (options.compat) {
        options.useDepths = true;
      }
    
      var ast = env.parse(input, options),
          environment = new env.Compiler().compile(ast, options);
      return new env.JavaScriptCompiler().compile(environment, options);
    }
    
    function compile(input, _x, env) {
      var options = arguments[1] === undefined ? {} : arguments[1];
    
      if (input == null || typeof input !== 'string' && input.type !== 'Program') {
        throw new _Exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
      }
    
      if (!('data' in options)) {
        options.data = true;
      }
      if (options.compat) {
        options.useDepths = true;
      }
    
      var compiled = undefined;
    
      function compileInput() {
        var ast = env.parse(input, options),
            environment = new env.Compiler().compile(ast, options),
            templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
        return env.template(templateSpec);
      }
    
      // Template is only compiled on first use and cached after that point.
      function ret(context, execOptions) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled.call(this, context, execOptions);
      }
      ret._setup = function (setupOptions) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled._setup(setupOptions);
      };
      ret._child = function (i, data, blockParams, depths) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled._child(i, data, blockParams, depths);
      };
      return ret;
    }
    
    function argEquals(a, b) {
      if (a === b) {
        return true;
      }
    
      if (_isArray$indexOf.isArray(a) && _isArray$indexOf.isArray(b) && a.length === b.length) {
        for (var i = 0; i < a.length; i++) {
          if (!argEquals(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
    }
    
    function transformLiteralToPath(sexpr) {
      if (!sexpr.path.parts) {
        var literal = sexpr.path;
        // Casting to string here to make false and 0 literal values play nicely with the rest
        // of the system.
        sexpr.path = new _AST2['default'].PathExpression(false, 0, [literal.original + ''], literal.original + '', literal.loc);
      }
    }
  provide("handlebars/dist/cjs/handlebars/compiler/compiler", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/compiler/javascript-compiler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    
    var _COMPILER_REVISION$REVISION_CHANGES =  require('handlebars/dist/cjs/handlebars/base');
    
    var _Exception =  require('handlebars/dist/cjs/handlebars/exception');
    
    var _Exception2 = _interopRequireWildcard(_Exception);
    
    var _isArray =  require('handlebars/dist/cjs/handlebars/utils');
    
    var _CodeGen =  require('handlebars/dist/cjs/handlebars/compiler/code-gen');
    
    var _CodeGen2 = _interopRequireWildcard(_CodeGen);
    
    function Literal(value) {
      this.value = value;
    }
    
    function JavaScriptCompiler() {}
    
    JavaScriptCompiler.prototype = {
      // PUBLIC API: You can override these methods in a subclass to provide
      // alternative compiled forms for name lookup and buffering semantics
      nameLookup: function nameLookup(parent, name /* , type*/) {
        if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
          return [parent, '.', name];
        } else {
          return [parent, '[\'', name, '\']'];
        }
      },
      depthedLookup: function depthedLookup(name) {
        return [this.aliasable('this.lookup'), '(depths, "', name, '")'];
      },
    
      compilerInfo: function compilerInfo() {
        var revision = _COMPILER_REVISION$REVISION_CHANGES.COMPILER_REVISION,
            versions = _COMPILER_REVISION$REVISION_CHANGES.REVISION_CHANGES[revision];
        return [revision, versions];
      },
    
      appendToBuffer: function appendToBuffer(source, location, explicit) {
        // Force a source as this simplifies the merge logic.
        if (!_isArray.isArray(source)) {
          source = [source];
        }
        source = this.source.wrap(source, location);
    
        if (this.environment.isSimple) {
          return ['return ', source, ';'];
        } else if (explicit) {
          // This is a case where the buffer operation occurs as a child of another
          // construct, generally braces. We have to explicitly output these buffer
          // operations to ensure that the emitted code goes in the correct location.
          return ['buffer += ', source, ';'];
        } else {
          source.appendToBuffer = true;
          return source;
        }
      },
    
      initializeBuffer: function initializeBuffer() {
        return this.quotedString('');
      },
      // END PUBLIC API
    
      compile: function compile(environment, options, context, asObject) {
        this.environment = environment;
        this.options = options;
        this.stringParams = this.options.stringParams;
        this.trackIds = this.options.trackIds;
        this.precompile = !asObject;
    
        this.name = this.environment.name;
        this.isChild = !!context;
        this.context = context || {
          programs: [],
          environments: []
        };
    
        this.preamble();
    
        this.stackSlot = 0;
        this.stackVars = [];
        this.aliases = {};
        this.registers = { list: [] };
        this.hashes = [];
        this.compileStack = [];
        this.inlineStack = [];
        this.blockParams = [];
    
        this.compileChildren(environment, options);
    
        this.useDepths = this.useDepths || environment.useDepths || this.options.compat;
        this.useBlockParams = this.useBlockParams || environment.useBlockParams;
    
        var opcodes = environment.opcodes,
            opcode = undefined,
            firstLoc = undefined,
            i = undefined,
            l = undefined;
    
        for (i = 0, l = opcodes.length; i < l; i++) {
          opcode = opcodes[i];
    
          this.source.currentLocation = opcode.loc;
          firstLoc = firstLoc || opcode.loc;
          this[opcode.opcode].apply(this, opcode.args);
        }
    
        // Flush any trailing content that might be pending.
        this.source.currentLocation = firstLoc;
        this.pushSource('');
    
        /* istanbul ignore next */
        if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
          throw new _Exception2['default']('Compile completed with content left on stack');
        }
    
        var fn = this.createFunctionContext(asObject);
        if (!this.isChild) {
          var ret = {
            compiler: this.compilerInfo(),
            main: fn
          };
          var programs = this.context.programs;
          for (i = 0, l = programs.length; i < l; i++) {
            if (programs[i]) {
              ret[i] = programs[i];
            }
          }
    
          if (this.environment.usePartial) {
            ret.usePartial = true;
          }
          if (this.options.data) {
            ret.useData = true;
          }
          if (this.useDepths) {
            ret.useDepths = true;
          }
          if (this.useBlockParams) {
            ret.useBlockParams = true;
          }
          if (this.options.compat) {
            ret.compat = true;
          }
    
          if (!asObject) {
            ret.compiler = JSON.stringify(ret.compiler);
    
            this.source.currentLocation = { start: { line: 1, column: 0 } };
            ret = this.objectLiteral(ret);
    
            if (options.srcName) {
              ret = ret.toStringWithSourceMap({ file: options.destName });
              ret.map = ret.map && ret.map.toString();
            } else {
              ret = ret.toString();
            }
          } else {
            ret.compilerOptions = this.options;
          }
    
          return ret;
        } else {
          return fn;
        }
      },
    
      preamble: function preamble() {
        // track the last context pushed into place to allow skipping the
        // getContext opcode when it would be a noop
        this.lastContext = 0;
        this.source = new _CodeGen2['default'](this.options.srcName);
      },
    
      createFunctionContext: function createFunctionContext(asObject) {
        var varDeclarations = '';
    
        var locals = this.stackVars.concat(this.registers.list);
        if (locals.length > 0) {
          varDeclarations += ', ' + locals.join(', ');
        }
    
        // Generate minimizer alias mappings
        //
        // When using true SourceNodes, this will update all references to the given alias
        // as the source nodes are reused in situ. For the non-source node compilation mode,
        // aliases will not be used, but this case is already being run on the client and
        // we aren't concern about minimizing the template size.
        var aliasCount = 0;
        for (var alias in this.aliases) {
          // eslint-disable-line guard-for-in
          var node = this.aliases[alias];
    
          if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) {
            varDeclarations += ', alias' + ++aliasCount + '=' + alias;
            node.children[0] = 'alias' + aliasCount;
          }
        }
    
        var params = ['depth0', 'helpers', 'partials', 'data'];
    
        if (this.useBlockParams || this.useDepths) {
          params.push('blockParams');
        }
        if (this.useDepths) {
          params.push('depths');
        }
    
        // Perform a second pass over the output to merge content when possible
        var source = this.mergeSource(varDeclarations);
    
        if (asObject) {
          params.push(source);
    
          return Function.apply(this, params);
        } else {
          return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
        }
      },
      mergeSource: function mergeSource(varDeclarations) {
        var isSimple = this.environment.isSimple,
            appendOnly = !this.forceBuffer,
            appendFirst = undefined,
            sourceSeen = undefined,
            bufferStart = undefined,
            bufferEnd = undefined;
        this.source.each(function (line) {
          if (line.appendToBuffer) {
            if (bufferStart) {
              line.prepend('  + ');
            } else {
              bufferStart = line;
            }
            bufferEnd = line;
          } else {
            if (bufferStart) {
              if (!sourceSeen) {
                appendFirst = true;
              } else {
                bufferStart.prepend('buffer += ');
              }
              bufferEnd.add(';');
              bufferStart = bufferEnd = undefined;
            }
    
            sourceSeen = true;
            if (!isSimple) {
              appendOnly = false;
            }
          }
        });
    
        if (appendOnly) {
          if (bufferStart) {
            bufferStart.prepend('return ');
            bufferEnd.add(';');
          } else if (!sourceSeen) {
            this.source.push('return "";');
          }
        } else {
          varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());
    
          if (bufferStart) {
            bufferStart.prepend('return buffer + ');
            bufferEnd.add(';');
          } else {
            this.source.push('return buffer;');
          }
        }
    
        if (varDeclarations) {
          this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
        }
    
        return this.source.merge();
      },
    
      // [blockValue]
      //
      // On stack, before: hash, inverse, program, value
      // On stack, after: return value of blockHelperMissing
      //
      // The purpose of this opcode is to take a block of the form
      // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
      // replace it on the stack with the result of properly
      // invoking blockHelperMissing.
      blockValue: function blockValue(name) {
        var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
            params = [this.contextName(0)];
        this.setupHelperArgs(name, 0, params);
    
        var blockName = this.popStack();
        params.splice(1, 0, blockName);
    
        this.push(this.source.functionCall(blockHelperMissing, 'call', params));
      },
    
      // [ambiguousBlockValue]
      //
      // On stack, before: hash, inverse, program, value
      // Compiler value, before: lastHelper=value of last found helper, if any
      // On stack, after, if no lastHelper: same as [blockValue]
      // On stack, after, if lastHelper: value
      ambiguousBlockValue: function ambiguousBlockValue() {
        // We're being a bit cheeky and reusing the options value from the prior exec
        var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
            params = [this.contextName(0)];
        this.setupHelperArgs('', 0, params, true);
    
        this.flushInline();
    
        var current = this.topStack();
        params.splice(1, 0, current);
    
        this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
      },
    
      // [appendContent]
      //
      // On stack, before: ...
      // On stack, after: ...
      //
      // Appends the string value of `content` to the current buffer
      appendContent: function appendContent(content) {
        if (this.pendingContent) {
          content = this.pendingContent + content;
        } else {
          this.pendingLocation = this.source.currentLocation;
        }
    
        this.pendingContent = content;
      },
    
      // [append]
      //
      // On stack, before: value, ...
      // On stack, after: ...
      //
      // Coerces `value` to a String and appends it to the current buffer.
      //
      // If `value` is truthy, or 0, it is coerced into a string and appended
      // Otherwise, the empty string is appended
      append: function append() {
        if (this.isInline()) {
          this.replaceStack(function (current) {
            return [' != null ? ', current, ' : ""'];
          });
    
          this.pushSource(this.appendToBuffer(this.popStack()));
        } else {
          var local = this.popStack();
          this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
          if (this.environment.isSimple) {
            this.pushSource(['else { ', this.appendToBuffer('\'\'', undefined, true), ' }']);
          }
        }
      },
    
      // [appendEscaped]
      //
      // On stack, before: value, ...
      // On stack, after: ...
      //
      // Escape `value` and append it to the buffer
      appendEscaped: function appendEscaped() {
        this.pushSource(this.appendToBuffer([this.aliasable('this.escapeExpression'), '(', this.popStack(), ')']));
      },
    
      // [getContext]
      //
      // On stack, before: ...
      // On stack, after: ...
      // Compiler value, after: lastContext=depth
      //
      // Set the value of the `lastContext` compiler value to the depth
      getContext: function getContext(depth) {
        this.lastContext = depth;
      },
    
      // [pushContext]
      //
      // On stack, before: ...
      // On stack, after: currentContext, ...
      //
      // Pushes the value of the current context onto the stack.
      pushContext: function pushContext() {
        this.pushStackLiteral(this.contextName(this.lastContext));
      },
    
      // [lookupOnContext]
      //
      // On stack, before: ...
      // On stack, after: currentContext[name], ...
      //
      // Looks up the value of `name` on the current context and pushes
      // it onto the stack.
      lookupOnContext: function lookupOnContext(parts, falsy, scoped) {
        var i = 0;
    
        if (!scoped && this.options.compat && !this.lastContext) {
          // The depthed query is expected to handle the undefined logic for the root level that
          // is implemented below, so we evaluate that directly in compat mode
          this.push(this.depthedLookup(parts[i++]));
        } else {
          this.pushContext();
        }
    
        this.resolvePath('context', parts, i, falsy);
      },
    
      // [lookupBlockParam]
      //
      // On stack, before: ...
      // On stack, after: blockParam[name], ...
      //
      // Looks up the value of `parts` on the given block param and pushes
      // it onto the stack.
      lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
        this.useBlockParams = true;
    
        this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
        this.resolvePath('context', parts, 1);
      },
    
      // [lookupData]
      //
      // On stack, before: ...
      // On stack, after: data, ...
      //
      // Push the data lookup operator
      lookupData: function lookupData(depth, parts) {
        if (!depth) {
          this.pushStackLiteral('data');
        } else {
          this.pushStackLiteral('this.data(data, ' + depth + ')');
        }
    
        this.resolvePath('data', parts, 0, true);
      },
    
      resolvePath: function resolvePath(type, parts, i, falsy) {
        var _this = this;
    
        if (this.options.strict || this.options.assumeObjects) {
          this.push(strictLookup(this.options.strict, this, parts, type));
          return;
        }
    
        var len = parts.length;
        for (; i < len; i++) {
          /*eslint-disable no-loop-func */
          this.replaceStack(function (current) {
            var lookup = _this.nameLookup(current, parts[i], type);
            // We want to ensure that zero and false are handled properly if the context (falsy flag)
            // needs to have the special handling for these values.
            if (!falsy) {
              return [' != null ? ', lookup, ' : ', current];
            } else {
              // Otherwise we can use generic falsy handling
              return [' && ', lookup];
            }
          });
          /*eslint-enable no-loop-func */
        }
      },
    
      // [resolvePossibleLambda]
      //
      // On stack, before: value, ...
      // On stack, after: resolved value, ...
      //
      // If the `value` is a lambda, replace it on the stack by
      // the return value of the lambda
      resolvePossibleLambda: function resolvePossibleLambda() {
        this.push([this.aliasable('this.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
      },
    
      // [pushStringParam]
      //
      // On stack, before: ...
      // On stack, after: string, currentContext, ...
      //
      // This opcode is designed for use in string mode, which
      // provides the string value of a parameter along with its
      // depth rather than resolving it immediately.
      pushStringParam: function pushStringParam(string, type) {
        this.pushContext();
        this.pushString(type);
    
        // If it's a subexpression, the string result
        // will be pushed after this opcode.
        if (type !== 'SubExpression') {
          if (typeof string === 'string') {
            this.pushString(string);
          } else {
            this.pushStackLiteral(string);
          }
        }
      },
    
      emptyHash: function emptyHash(omitEmpty) {
        if (this.trackIds) {
          this.push('{}'); // hashIds
        }
        if (this.stringParams) {
          this.push('{}'); // hashContexts
          this.push('{}'); // hashTypes
        }
        this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
      },
      pushHash: function pushHash() {
        if (this.hash) {
          this.hashes.push(this.hash);
        }
        this.hash = { values: [], types: [], contexts: [], ids: [] };
      },
      popHash: function popHash() {
        var hash = this.hash;
        this.hash = this.hashes.pop();
    
        if (this.trackIds) {
          this.push(this.objectLiteral(hash.ids));
        }
        if (this.stringParams) {
          this.push(this.objectLiteral(hash.contexts));
          this.push(this.objectLiteral(hash.types));
        }
    
        this.push(this.objectLiteral(hash.values));
      },
    
      // [pushString]
      //
      // On stack, before: ...
      // On stack, after: quotedString(string), ...
      //
      // Push a quoted version of `string` onto the stack
      pushString: function pushString(string) {
        this.pushStackLiteral(this.quotedString(string));
      },
    
      // [pushLiteral]
      //
      // On stack, before: ...
      // On stack, after: value, ...
      //
      // Pushes a value onto the stack. This operation prevents
      // the compiler from creating a temporary variable to hold
      // it.
      pushLiteral: function pushLiteral(value) {
        this.pushStackLiteral(value);
      },
    
      // [pushProgram]
      //
      // On stack, before: ...
      // On stack, after: program(guid), ...
      //
      // Push a program expression onto the stack. This takes
      // a compile-time guid and converts it into a runtime-accessible
      // expression.
      pushProgram: function pushProgram(guid) {
        if (guid != null) {
          this.pushStackLiteral(this.programExpression(guid));
        } else {
          this.pushStackLiteral(null);
        }
      },
    
      // [invokeHelper]
      //
      // On stack, before: hash, inverse, program, params..., ...
      // On stack, after: result of helper invocation
      //
      // Pops off the helper's parameters, invokes the helper,
      // and pushes the helper's return value onto the stack.
      //
      // If the helper is not found, `helperMissing` is called.
      invokeHelper: function invokeHelper(paramSize, name, isSimple) {
        var nonHelper = this.popStack(),
            helper = this.setupHelper(paramSize, name),
            simple = isSimple ? [helper.name, ' || '] : '';
    
        var lookup = ['('].concat(simple, nonHelper);
        if (!this.options.strict) {
          lookup.push(' || ', this.aliasable('helpers.helperMissing'));
        }
        lookup.push(')');
    
        this.push(this.source.functionCall(lookup, 'call', helper.callParams));
      },
    
      // [invokeKnownHelper]
      //
      // On stack, before: hash, inverse, program, params..., ...
      // On stack, after: result of helper invocation
      //
      // This operation is used when the helper is known to exist,
      // so a `helperMissing` fallback is not required.
      invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
        var helper = this.setupHelper(paramSize, name);
        this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
      },
    
      // [invokeAmbiguous]
      //
      // On stack, before: hash, inverse, program, params..., ...
      // On stack, after: result of disambiguation
      //
      // This operation is used when an expression like `{{foo}}`
      // is provided, but we don't know at compile-time whether it
      // is a helper or a path.
      //
      // This operation emits more code than the other options,
      // and can be avoided by passing the `knownHelpers` and
      // `knownHelpersOnly` flags at compile-time.
      invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
        this.useRegister('helper');
    
        var nonHelper = this.popStack();
    
        this.emptyHash();
        var helper = this.setupHelper(0, name, helperCall);
    
        var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');
    
        var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
        if (!this.options.strict) {
          lookup[0] = '(helper = ';
          lookup.push(' != null ? helper : ', this.aliasable('helpers.helperMissing'));
        }
    
        this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
      },
    
      // [invokePartial]
      //
      // On stack, before: context, ...
      // On stack after: result of partial invocation
      //
      // This operation pops off a context, invokes a partial with that context,
      // and pushes the result of the invocation back.
      invokePartial: function invokePartial(isDynamic, name, indent) {
        var params = [],
            options = this.setupParams(name, 1, params, false);
    
        if (isDynamic) {
          name = this.popStack();
          delete options.name;
        }
    
        if (indent) {
          options.indent = JSON.stringify(indent);
        }
        options.helpers = 'helpers';
        options.partials = 'partials';
    
        if (!isDynamic) {
          params.unshift(this.nameLookup('partials', name, 'partial'));
        } else {
          params.unshift(name);
        }
    
        if (this.options.compat) {
          options.depths = 'depths';
        }
        options = this.objectLiteral(options);
        params.push(options);
    
        this.push(this.source.functionCall('this.invokePartial', '', params));
      },
    
      // [assignToHash]
      //
      // On stack, before: value, ..., hash, ...
      // On stack, after: ..., hash, ...
      //
      // Pops a value off the stack and assigns it to the current hash
      assignToHash: function assignToHash(key) {
        var value = this.popStack(),
            context = undefined,
            type = undefined,
            id = undefined;
    
        if (this.trackIds) {
          id = this.popStack();
        }
        if (this.stringParams) {
          type = this.popStack();
          context = this.popStack();
        }
    
        var hash = this.hash;
        if (context) {
          hash.contexts[key] = context;
        }
        if (type) {
          hash.types[key] = type;
        }
        if (id) {
          hash.ids[key] = id;
        }
        hash.values[key] = value;
      },
    
      pushId: function pushId(type, name, child) {
        if (type === 'BlockParam') {
          this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
        } else if (type === 'PathExpression') {
          this.pushString(name);
        } else if (type === 'SubExpression') {
          this.pushStackLiteral('true');
        } else {
          this.pushStackLiteral('null');
        }
      },
    
      // HELPERS
    
      compiler: JavaScriptCompiler,
    
      compileChildren: function compileChildren(environment, options) {
        var children = environment.children,
            child = undefined,
            compiler = undefined;
    
        for (var i = 0, l = children.length; i < l; i++) {
          child = children[i];
          compiler = new this.compiler(); // eslint-disable-line new-cap
    
          var index = this.matchExistingProgram(child);
    
          if (index == null) {
            this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
            index = this.context.programs.length;
            child.index = index;
            child.name = 'program' + index;
            this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
            this.context.environments[index] = child;
    
            this.useDepths = this.useDepths || compiler.useDepths;
            this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
          } else {
            child.index = index;
            child.name = 'program' + index;
    
            this.useDepths = this.useDepths || child.useDepths;
            this.useBlockParams = this.useBlockParams || child.useBlockParams;
          }
        }
      },
      matchExistingProgram: function matchExistingProgram(child) {
        for (var i = 0, len = this.context.environments.length; i < len; i++) {
          var environment = this.context.environments[i];
          if (environment && environment.equals(child)) {
            return i;
          }
        }
      },
    
      programExpression: function programExpression(guid) {
        var child = this.environment.children[guid],
            programParams = [child.index, 'data', child.blockParams];
    
        if (this.useBlockParams || this.useDepths) {
          programParams.push('blockParams');
        }
        if (this.useDepths) {
          programParams.push('depths');
        }
    
        return 'this.program(' + programParams.join(', ') + ')';
      },
    
      useRegister: function useRegister(name) {
        if (!this.registers[name]) {
          this.registers[name] = true;
          this.registers.list.push(name);
        }
      },
    
      push: function push(expr) {
        if (!(expr instanceof Literal)) {
          expr = this.source.wrap(expr);
        }
    
        this.inlineStack.push(expr);
        return expr;
      },
    
      pushStackLiteral: function pushStackLiteral(item) {
        this.push(new Literal(item));
      },
    
      pushSource: function pushSource(source) {
        if (this.pendingContent) {
          this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
          this.pendingContent = undefined;
        }
    
        if (source) {
          this.source.push(source);
        }
      },
    
      replaceStack: function replaceStack(callback) {
        var prefix = ['('],
            stack = undefined,
            createdStack = undefined,
            usedLiteral = undefined;
    
        /* istanbul ignore next */
        if (!this.isInline()) {
          throw new _Exception2['default']('replaceStack on non-inline');
        }
    
        // We want to merge the inline statement into the replacement statement via ','
        var top = this.popStack(true);
    
        if (top instanceof Literal) {
          // Literals do not need to be inlined
          stack = [top.value];
          prefix = ['(', stack];
          usedLiteral = true;
        } else {
          // Get or create the current stack name for use by the inline
          createdStack = true;
          var _name = this.incrStack();
    
          prefix = ['((', this.push(_name), ' = ', top, ')'];
          stack = this.topStack();
        }
    
        var item = callback.call(this, stack);
    
        if (!usedLiteral) {
          this.popStack();
        }
        if (createdStack) {
          this.stackSlot--;
        }
        this.push(prefix.concat(item, ')'));
      },
    
      incrStack: function incrStack() {
        this.stackSlot++;
        if (this.stackSlot > this.stackVars.length) {
          this.stackVars.push('stack' + this.stackSlot);
        }
        return this.topStackName();
      },
      topStackName: function topStackName() {
        return 'stack' + this.stackSlot;
      },
      flushInline: function flushInline() {
        var inlineStack = this.inlineStack;
        this.inlineStack = [];
        for (var i = 0, len = inlineStack.length; i < len; i++) {
          var entry = inlineStack[i];
          /* istanbul ignore if */
          if (entry instanceof Literal) {
            this.compileStack.push(entry);
          } else {
            var stack = this.incrStack();
            this.pushSource([stack, ' = ', entry, ';']);
            this.compileStack.push(stack);
          }
        }
      },
      isInline: function isInline() {
        return this.inlineStack.length;
      },
    
      popStack: function popStack(wrapped) {
        var inline = this.isInline(),
            item = (inline ? this.inlineStack : this.compileStack).pop();
    
        if (!wrapped && item instanceof Literal) {
          return item.value;
        } else {
          if (!inline) {
            /* istanbul ignore next */
            if (!this.stackSlot) {
              throw new _Exception2['default']('Invalid stack pop');
            }
            this.stackSlot--;
          }
          return item;
        }
      },
    
      topStack: function topStack() {
        var stack = this.isInline() ? this.inlineStack : this.compileStack,
            item = stack[stack.length - 1];
    
        /* istanbul ignore if */
        if (item instanceof Literal) {
          return item.value;
        } else {
          return item;
        }
      },
    
      contextName: function contextName(context) {
        if (this.useDepths && context) {
          return 'depths[' + context + ']';
        } else {
          return 'depth' + context;
        }
      },
    
      quotedString: function quotedString(str) {
        return this.source.quotedString(str);
      },
    
      objectLiteral: function objectLiteral(obj) {
        return this.source.objectLiteral(obj);
      },
    
      aliasable: function aliasable(name) {
        var ret = this.aliases[name];
        if (ret) {
          ret.referenceCount++;
          return ret;
        }
    
        ret = this.aliases[name] = this.source.wrap(name);
        ret.aliasable = true;
        ret.referenceCount = 1;
    
        return ret;
      },
    
      setupHelper: function setupHelper(paramSize, name, blockHelper) {
        var params = [],
            paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
        var foundHelper = this.nameLookup('helpers', name, 'helper');
    
        return {
          params: params,
          paramsInit: paramsInit,
          name: foundHelper,
          callParams: [this.contextName(0)].concat(params)
        };
      },
    
      setupParams: function setupParams(helper, paramSize, params) {
        var options = {},
            contexts = [],
            types = [],
            ids = [],
            param = undefined;
    
        options.name = this.quotedString(helper);
        options.hash = this.popStack();
    
        if (this.trackIds) {
          options.hashIds = this.popStack();
        }
        if (this.stringParams) {
          options.hashTypes = this.popStack();
          options.hashContexts = this.popStack();
        }
    
        var inverse = this.popStack(),
            program = this.popStack();
    
        // Avoid setting fn and inverse if neither are set. This allows
        // helpers to do a check for `if (options.fn)`
        if (program || inverse) {
          options.fn = program || 'this.noop';
          options.inverse = inverse || 'this.noop';
        }
    
        // The parameters go on to the stack in order (making sure that they are evaluated in order)
        // so we need to pop them off the stack in reverse order
        var i = paramSize;
        while (i--) {
          param = this.popStack();
          params[i] = param;
    
          if (this.trackIds) {
            ids[i] = this.popStack();
          }
          if (this.stringParams) {
            types[i] = this.popStack();
            contexts[i] = this.popStack();
          }
        }
    
        if (this.trackIds) {
          options.ids = this.source.generateArray(ids);
        }
        if (this.stringParams) {
          options.types = this.source.generateArray(types);
          options.contexts = this.source.generateArray(contexts);
        }
    
        if (this.options.data) {
          options.data = 'data';
        }
        if (this.useBlockParams) {
          options.blockParams = 'blockParams';
        }
        return options;
      },
    
      setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
        var options = this.setupParams(helper, paramSize, params, true);
        options = this.objectLiteral(options);
        if (useRegister) {
          this.useRegister('options');
          params.push('options');
          return ['options=', options];
        } else {
          params.push(options);
          return '';
        }
      }
    };
    
    (function () {
      var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');
    
      var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
    
      for (var i = 0, l = reservedWords.length; i < l; i++) {
        compilerWords[reservedWords[i]] = true;
      }
    })();
    
    JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
      return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
    };
    
    function strictLookup(requireTerminal, compiler, parts, type) {
      var stack = compiler.popStack(),
          i = 0,
          len = parts.length;
      if (requireTerminal) {
        len--;
      }
    
      for (; i < len; i++) {
        stack = compiler.nameLookup(stack, parts[i], type);
      }
    
      if (requireTerminal) {
        return [compiler.aliasable('this.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];
      } else {
        return stack;
      }
    }
    
    exports['default'] = JavaScriptCompiler;
    module.exports = exports['default'];
  provide("handlebars/dist/cjs/handlebars/compiler/javascript-compiler", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    
    var _runtime =  require('handlebars/dist/cjs/handlebars.runtime');
    
    var _runtime2 = _interopRequireWildcard(_runtime);
    
    // Compiler imports
    
    var _AST =  require('handlebars/dist/cjs/handlebars/compiler/ast');
    
    var _AST2 = _interopRequireWildcard(_AST);
    
    var _Parser$parse =  require('handlebars/dist/cjs/handlebars/compiler/base');
    
    var _Compiler$compile$precompile =  require('handlebars/dist/cjs/handlebars/compiler/compiler');
    
    var _JavaScriptCompiler =  require('handlebars/dist/cjs/handlebars/compiler/javascript-compiler');
    
    var _JavaScriptCompiler2 = _interopRequireWildcard(_JavaScriptCompiler);
    
    var _Visitor =  require('handlebars/dist/cjs/handlebars/compiler/visitor');
    
    var _Visitor2 = _interopRequireWildcard(_Visitor);
    
    var _noConflict =  require('handlebars/dist/cjs/handlebars/no-conflict');
    
    var _noConflict2 = _interopRequireWildcard(_noConflict);
    
    var _create = _runtime2['default'].create;
    function create() {
      var hb = _create();
    
      hb.compile = function (input, options) {
        return _Compiler$compile$precompile.compile(input, options, hb);
      };
      hb.precompile = function (input, options) {
        return _Compiler$compile$precompile.precompile(input, options, hb);
      };
    
      hb.AST = _AST2['default'];
      hb.Compiler = _Compiler$compile$precompile.Compiler;
      hb.JavaScriptCompiler = _JavaScriptCompiler2['default'];
      hb.Parser = _Parser$parse.parser;
      hb.parse = _Parser$parse.parse;
    
      return hb;
    }
    
    var inst = create();
    inst.create = create;
    
    _noConflict2['default'](inst);
    
    inst.Visitor = _Visitor2['default'];
    
    inst['default'] = inst;
    
    exports['default'] = inst;
    module.exports = exports['default'];
  provide("handlebars/dist/cjs/handlebars", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/compiler/printer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    exports.print = print;
    exports.PrintVisitor = PrintVisitor;
    /*eslint-disable new-cap */
    
    var _Visitor =  require('handlebars/dist/cjs/handlebars/compiler/visitor');
    
    var _Visitor2 = _interopRequireWildcard(_Visitor);
    
    function print(ast) {
      return new PrintVisitor().accept(ast);
    }
    
    function PrintVisitor() {
      this.padding = 0;
    }
    
    PrintVisitor.prototype = new _Visitor2['default']();
    
    PrintVisitor.prototype.pad = function (string) {
      var out = '';
    
      for (var i = 0, l = this.padding; i < l; i++) {
        out = out + '  ';
      }
    
      out = out + string + '\n';
      return out;
    };
    
    PrintVisitor.prototype.Program = function (program) {
      var out = '',
          body = program.body,
          i = undefined,
          l = undefined;
    
      if (program.blockParams) {
        var blockParams = 'BLOCK PARAMS: [';
        for (i = 0, l = program.blockParams.length; i < l; i++) {
          blockParams += ' ' + program.blockParams[i];
        }
        blockParams += ' ]';
        out += this.pad(blockParams);
      }
    
      for (i = 0, l = body.length; i < l; i++) {
        out = out + this.accept(body[i]);
      }
    
      this.padding--;
    
      return out;
    };
    
    PrintVisitor.prototype.MustacheStatement = function (mustache) {
      return this.pad('{{ ' + this.SubExpression(mustache) + ' }}');
    };
    
    PrintVisitor.prototype.BlockStatement = function (block) {
      var out = '';
    
      out = out + this.pad('BLOCK:');
      this.padding++;
      out = out + this.pad(this.SubExpression(block));
      if (block.program) {
        out = out + this.pad('PROGRAM:');
        this.padding++;
        out = out + this.accept(block.program);
        this.padding--;
      }
      if (block.inverse) {
        if (block.program) {
          this.padding++;
        }
        out = out + this.pad('{{^}}');
        this.padding++;
        out = out + this.accept(block.inverse);
        this.padding--;
        if (block.program) {
          this.padding--;
        }
      }
      this.padding--;
    
      return out;
    };
    
    PrintVisitor.prototype.PartialStatement = function (partial) {
      var content = 'PARTIAL:' + partial.name.original;
      if (partial.params[0]) {
        content += ' ' + this.accept(partial.params[0]);
      }
      if (partial.hash) {
        content += ' ' + this.accept(partial.hash);
      }
      return this.pad('{{> ' + content + ' }}');
    };
    
    PrintVisitor.prototype.ContentStatement = function (content) {
      return this.pad('CONTENT[ \'' + content.value + '\' ]');
    };
    
    PrintVisitor.prototype.CommentStatement = function (comment) {
      return this.pad('{{! \'' + comment.value + '\' }}');
    };
    
    PrintVisitor.prototype.SubExpression = function (sexpr) {
      var params = sexpr.params,
          paramStrings = [],
          hash = undefined;
    
      for (var i = 0, l = params.length; i < l; i++) {
        paramStrings.push(this.accept(params[i]));
      }
    
      params = '[' + paramStrings.join(', ') + ']';
    
      hash = sexpr.hash ? ' ' + this.accept(sexpr.hash) : '';
    
      return this.accept(sexpr.path) + ' ' + params + hash;
    };
    
    PrintVisitor.prototype.PathExpression = function (id) {
      var path = id.parts.join('/');
      return (id.data ? '@' : '') + 'PATH:' + path;
    };
    
    PrintVisitor.prototype.StringLiteral = function (string) {
      return '"' + string.value + '"';
    };
    
    PrintVisitor.prototype.NumberLiteral = function (number) {
      return 'NUMBER{' + number.value + '}';
    };
    
    PrintVisitor.prototype.BooleanLiteral = function (bool) {
      return 'BOOLEAN{' + bool.value + '}';
    };
    
    PrintVisitor.prototype.UndefinedLiteral = function () {
      return 'UNDEFINED';
    };
    
    PrintVisitor.prototype.NullLiteral = function () {
      return 'NULL';
    };
    
    PrintVisitor.prototype.Hash = function (hash) {
      var pairs = hash.pairs,
          joinedPairs = [];
    
      for (var i = 0, l = pairs.length; i < l; i++) {
        joinedPairs.push(this.accept(pairs[i]));
      }
    
      return 'HASH{' + joinedPairs.join(', ') + '}';
    };
    PrintVisitor.prototype.HashPair = function (pair) {
      return pair.key + '=' + this.accept(pair.value);
    };
    /*eslint-enable new-cap */
  provide("handlebars/dist/cjs/handlebars/compiler/printer", module.exports);
}(global));

// pakmanager:handlebars
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // USAGE:
    // var handlebars =  require('handlebars');
    /* eslint-disable no-var */
    
    // var local = handlebars.create();
    
    var handlebars =  require('handlebars/dist/cjs/handlebars')['default'];
    
    var printer =  require('handlebars/dist/cjs/handlebars/compiler/printer');
    handlebars.PrintVisitor = printer.PrintVisitor;
    handlebars.print = printer.print;
    
    module.exports = handlebars;
    
    // Publish a Node.js require() handler for .handlebars and .hbs files
    function extension(module, filename) {
      var fs = require('fs');
      var templateString = fs.readFileSync(filename, 'utf8');
      module.exports = handlebars.compile(templateString);
    }
    /* istanbul ignore else */
    if (typeof require !== 'undefined' && require.extensions) {
      require.extensions['.handlebars'] = extension;
      require.extensions['.hbs'] = extension;
    }
    
  provide("handlebars", module.exports);
}(global));

// pakmanager:shortid/lib/random/random-from-seed
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    // Found this seed-based random generator somewhere
    // Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)
    
    var seed = 1;
    
    /**
     * return a random number based on a seed
     * @param seed
     * @returns {number}
     */
    function getNextValue() {
        seed = (seed * 9301 + 49297) % 233280;
        return seed/(233280.0);
    }
    
    function setSeed(_seed_) {
        seed = _seed_;
    }
    
    module.exports = {
        nextValue: getNextValue,
        seed: setSeed
    };
    
  provide("shortid/lib/random/random-from-seed", module.exports);
}(global));

// pakmanager:shortid/lib/random/random-byte
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var crypto = require('crypto');
    var randomBytes = crypto.randomBytes;
    
    function randomByte() {
        return randomBytes(1)[0] & 0x30;
    }
    
    module.exports = randomByte;
    
  provide("shortid/lib/random/random-byte", module.exports);
}(global));

// pakmanager:shortid/lib/alphabet
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var randomFromSeed =  require('shortid/lib/random/random-from-seed');
    
    var ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';
    var alphabet;
    var previousSeed;
    
    var shuffled;
    
    function reset() {
        shuffled = false;
    }
    
    function setCharacters(_alphabet_) {
        if (!_alphabet_) {
            if (alphabet !== ORIGINAL) {
                alphabet = ORIGINAL;
                reset();
            }
            return;
        }
    
        if (_alphabet_ === alphabet) {
            return;
        }
    
        if (_alphabet_.length !== ORIGINAL.length) {
            throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);
        }
    
        var unique = _alphabet_.split('').filter(function(item, ind, arr){
           return ind !== arr.lastIndexOf(item);
        });
    
        if (unique.length) {
            throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));
        }
    
        alphabet = _alphabet_;
        reset();
    }
    
    function characters(_alphabet_) {
        setCharacters(_alphabet_);
        return alphabet;
    }
    
    function setSeed(seed) {
        randomFromSeed.seed(seed);
        if (previousSeed !== seed) {
            reset();
            previousSeed = seed;
        }
    }
    
    function shuffle() {
        if (!alphabet) {
            setCharacters(ORIGINAL);
        }
    
        var sourceArray = alphabet.split('');
        var targetArray = [];
        var r = randomFromSeed.nextValue();
        var characterIndex;
    
        while (sourceArray.length > 0) {
            r = randomFromSeed.nextValue();
            characterIndex = Math.floor(r * sourceArray.length);
            targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
        }
        return targetArray.join('');
    }
    
    function getShuffled() {
        if (shuffled) {
            return shuffled;
        }
        shuffled = shuffle();
        return shuffled;
    }
    
    /**
     * lookup shuffled letter
     * @param index
     * @returns {string}
     */
    function lookup(index) {
        var alphabetShuffled = getShuffled();
        return alphabetShuffled[index];
    }
    
    module.exports = {
        characters: characters,
        seed: setSeed,
        lookup: lookup,
        shuffled: getShuffled
    };
    
  provide("shortid/lib/alphabet", module.exports);
}(global));

// pakmanager:shortid/lib/encode
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var randomByte =  require('shortid/lib/random/random-byte');
    
    function encode(lookup, number) {
        var loopCounter = 0;
        var done;
    
        var str = '';
    
        while (!done) {
            str = str + lookup( ( (number >> (4 * loopCounter)) & 0x0f ) | randomByte() );
            done = number < (Math.pow(16, loopCounter + 1 ) );
            loopCounter++;
        }
        return str;
    }
    
    module.exports = encode;
    
  provide("shortid/lib/encode", module.exports);
}(global));

// pakmanager:shortid/lib/decode
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var alphabet =  require('shortid/lib/alphabet');
    
    /**
     * Decode the id to get the version and worker
     * Mainly for debugging and testing.
     * @param id - the shortid-generated id.
     */
    function decode(id) {
        var characters = alphabet.shuffled();
        return {
            version: characters.indexOf(id.substr(0, 1)) & 0x0f,
            worker: characters.indexOf(id.substr(1, 1)) & 0x0f
        };
    }
    
    module.exports = decode;
    
  provide("shortid/lib/decode", module.exports);
}(global));

// pakmanager:shortid/lib/is-valid
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var alphabet =  require('shortid/lib/alphabet');
    
    function isShortId(id) {
        if (!id || typeof id !== 'string' || id.length < 6 ) {
            return false;
        }
    
        var characters = alphabet.characters();
        var invalidCharacters = id.split('').map(function(char){
            if (characters.indexOf(char) === -1) {
                return char;
            }
        }).join('').split('').join('');
    
        return invalidCharacters.length === 0;
    }
    
    module.exports = isShortId;
    
  provide("shortid/lib/is-valid", module.exports);
}(global));

// pakmanager:shortid/lib/util/cluster-worker-id
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports = parseInt(process.env.NODE_UNIQUE_ID || 0, 10);
    
  provide("shortid/lib/util/cluster-worker-id", module.exports);
}(global));

// pakmanager:shortid
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var alphabet =  require('shortid/lib/alphabet');
    var encode =  require('shortid/lib/encode');
    var decode =  require('shortid/lib/decode');
    var isValid =  require('shortid/lib/is-valid');
    
    // Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.
    // This number should be updated every year or so to keep the generated id short.
    // To regenerate `new Date() - 0` and bump the version. Always bump the version!
    var REDUCE_TIME = 1426452414093;
    
    // don't change unless we change the algos or REDUCE_TIME
    // must be an integer and less than 16
    var version = 5;
    
    // if you are using cluster or multiple servers use this to make each instance
    // has a unique value for worker
    // Note: I don't know if this is automatically set when using third
    // party cluster solutions such as pm2.
    var clusterWorkerId =  require('shortid/lib/util/cluster-worker-id') || 0;
    
    // Counter is used when shortid is called multiple times in one second.
    var counter;
    
    // Remember the last time shortid was called in case counter is needed.
    var previousSeconds;
    
    /**
     * Generate unique id
     * Returns string id
     */
    function generate() {
    
        var str = '';
    
        var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);
    
        if (seconds === previousSeconds) {
            counter++;
        } else {
            counter = 0;
            previousSeconds = seconds;
        }
    
        str = str + encode(alphabet.lookup, version);
        str = str + encode(alphabet.lookup, clusterWorkerId);
        if (counter > 0) {
            str = str + encode(alphabet.lookup, counter);
        }
        str = str + encode(alphabet.lookup, seconds);
    
        return str;
    }
    
    
    /**
     * Set the seed.
     * Highly recommended if you don't want people to try to figure out your id schema.
     * exposed as shortid.seed(int)
     * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.
     */
    function seed(seedValue) {
        alphabet.seed(seedValue);
        return module.exports;
    }
    
    /**
     * Set the cluster worker or machine id
     * exposed as shortid.worker(int)
     * @param workerId worker must be positive integer.  Number less than 16 is recommended.
     * returns shortid module so it can be chained.
     */
    function worker(workerId) {
        clusterWorkerId = workerId;
        return module.exports;
    }
    
    /**
     *
     * sets new characters to use in the alphabet
     * returns the shuffled alphabet
     */
    function characters(newCharacters) {
        if (newCharacters !== undefined) {
            alphabet.characters(newCharacters);
        }
    
        return alphabet.shuffled();
    }
    
    
    // Export all other functions as properties of the generate function
    module.exports = generate;
    module.exports.generate = generate;
    module.exports.seed = seed;
    module.exports.worker = worker;
    module.exports.characters = characters;
    module.exports.decode = decode;
    module.exports.isValid = isValid;
    
  provide("shortid", module.exports);
}(global));

// pakmanager:bluebird/js/main/es5.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var isES5 = (function(){
        "use strict";
        return this === undefined;
    })();
    
    if (isES5) {
        module.exports = {
            freeze: Object.freeze,
            defineProperty: Object.defineProperty,
            getDescriptor: Object.getOwnPropertyDescriptor,
            keys: Object.keys,
            names: Object.getOwnPropertyNames,
            getPrototypeOf: Object.getPrototypeOf,
            isArray: Array.isArray,
            isES5: isES5,
            propertyIsWritable: function(obj, prop) {
                var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
                return !!(!descriptor || descriptor.writable || descriptor.set);
            }
        };
    } else {
        var has = {}.hasOwnProperty;
        var str = {}.toString;
        var proto = {}.constructor.prototype;
    
        var ObjectKeys = function (o) {
            var ret = [];
            for (var key in o) {
                if (has.call(o, key)) {
                    ret.push(key);
                }
            }
            return ret;
        };
    
        var ObjectGetDescriptor = function(o, key) {
            return {value: o[key]};
        };
    
        var ObjectDefineProperty = function (o, key, desc) {
            o[key] = desc.value;
            return o;
        };
    
        var ObjectFreeze = function (obj) {
            return obj;
        };
    
        var ObjectGetPrototypeOf = function (obj) {
            try {
                return Object(obj).constructor.prototype;
            }
            catch (e) {
                return proto;
            }
        };
    
        var ArrayIsArray = function (obj) {
            try {
                return str.call(obj) === "[object Array]";
            }
            catch(e) {
                return false;
            }
        };
    
        module.exports = {
            isArray: ArrayIsArray,
            keys: ObjectKeys,
            names: ObjectKeys,
            defineProperty: ObjectDefineProperty,
            getDescriptor: ObjectGetDescriptor,
            freeze: ObjectFreeze,
            getPrototypeOf: ObjectGetPrototypeOf,
            isES5: isES5,
            propertyIsWritable: function() {
                return true;
            }
        };
    }
    
  provide("bluebird/js/main/es5.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/util
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var es5 =  require('bluebird/js/main/es5.js');
    var canEvaluate = typeof navigator == "undefined";
    var haveGetters = (function(){
        try {
            var o = {};
            es5.defineProperty(o, "f", {
                get: function () {
                    return 3;
                }
            });
            return o.f === 3;
        }
        catch (e) {
            return false;
        }
    
    })();
    
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
        try {
            var target = tryCatchTarget;
            tryCatchTarget = null;
            return target.apply(this, arguments);
        } catch (e) {
            errorObj.e = e;
            return errorObj;
        }
    }
    function tryCatch(fn) {
        tryCatchTarget = fn;
        return tryCatcher;
    }
    
    var inherits = function(Child, Parent) {
        var hasProp = {}.hasOwnProperty;
    
        function T() {
            this.constructor = Child;
            this.constructor$ = Parent;
            for (var propertyName in Parent.prototype) {
                if (hasProp.call(Parent.prototype, propertyName) &&
                    propertyName.charAt(propertyName.length-1) !== "$"
               ) {
                    this[propertyName + "$"] = Parent.prototype[propertyName];
                }
            }
        }
        T.prototype = Parent.prototype;
        Child.prototype = new T();
        return Child.prototype;
    };
    
    
    function isPrimitive(val) {
        return val == null || val === true || val === false ||
            typeof val === "string" || typeof val === "number";
    
    }
    
    function isObject(value) {
        return !isPrimitive(value);
    }
    
    function maybeWrapAsError(maybeError) {
        if (!isPrimitive(maybeError)) return maybeError;
    
        return new Error(safeToString(maybeError));
    }
    
    function withAppended(target, appendee) {
        var len = target.length;
        var ret = new Array(len + 1);
        var i;
        for (i = 0; i < len; ++i) {
            ret[i] = target[i];
        }
        ret[i] = appendee;
        return ret;
    }
    
    function getDataPropertyOrDefault(obj, key, defaultValue) {
        if (es5.isES5) {
            var desc = Object.getOwnPropertyDescriptor(obj, key);
    
            if (desc != null) {
                return desc.get == null && desc.set == null
                        ? desc.value
                        : defaultValue;
            }
        } else {
            return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
        }
    }
    
    function notEnumerableProp(obj, name, value) {
        if (isPrimitive(obj)) return obj;
        var descriptor = {
            value: value,
            configurable: true,
            enumerable: false,
            writable: true
        };
        es5.defineProperty(obj, name, descriptor);
        return obj;
    }
    
    function thrower(r) {
        throw r;
    }
    
    var inheritedDataKeys = (function() {
        var excludedPrototypes = [
            Array.prototype,
            Object.prototype,
            Function.prototype
        ];
    
        var isExcludedProto = function(val) {
            for (var i = 0; i < excludedPrototypes.length; ++i) {
                if (excludedPrototypes[i] === val) {
                    return true;
                }
            }
            return false;
        };
    
        if (es5.isES5) {
            var getKeys = Object.getOwnPropertyNames;
            return function(obj) {
                var ret = [];
                var visitedKeys = Object.create(null);
                while (obj != null && !isExcludedProto(obj)) {
                    var keys;
                    try {
                        keys = getKeys(obj);
                    } catch (e) {
                        return ret;
                    }
                    for (var i = 0; i < keys.length; ++i) {
                        var key = keys[i];
                        if (visitedKeys[key]) continue;
                        visitedKeys[key] = true;
                        var desc = Object.getOwnPropertyDescriptor(obj, key);
                        if (desc != null && desc.get == null && desc.set == null) {
                            ret.push(key);
                        }
                    }
                    obj = es5.getPrototypeOf(obj);
                }
                return ret;
            };
        } else {
            var hasProp = {}.hasOwnProperty;
            return function(obj) {
                if (isExcludedProto(obj)) return [];
                var ret = [];
    
                /*jshint forin:false */
                enumeration: for (var key in obj) {
                    if (hasProp.call(obj, key)) {
                        ret.push(key);
                    } else {
                        for (var i = 0; i < excludedPrototypes.length; ++i) {
                            if (hasProp.call(excludedPrototypes[i], key)) {
                                continue enumeration;
                            }
                        }
                        ret.push(key);
                    }
                }
                return ret;
            };
        }
    
    })();
    
    var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
    function isClass(fn) {
        try {
            if (typeof fn === "function") {
                var keys = es5.names(fn.prototype);
    
                var hasMethods = es5.isES5 && keys.length > 1;
                var hasMethodsOtherThanConstructor = keys.length > 0 &&
                    !(keys.length === 1 && keys[0] === "constructor");
                var hasThisAssignmentAndStaticMethods =
                    thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
    
                if (hasMethods || hasMethodsOtherThanConstructor ||
                    hasThisAssignmentAndStaticMethods) {
                    return true;
                }
            }
            return false;
        } catch (e) {
            return false;
        }
    }
    
    function toFastProperties(obj) {
        /*jshint -W027,-W055,-W031*/
        function f() {}
        f.prototype = obj;
        var l = 8;
        while (l--) new f();
        return obj;
        eval(obj);
    }
    
    var rident = /^[a-z$_][a-z$_0-9]*$/i;
    function isIdentifier(str) {
        return rident.test(str);
    }
    
    function filledRange(count, prefix, suffix) {
        var ret = new Array(count);
        for(var i = 0; i < count; ++i) {
            ret[i] = prefix + i + suffix;
        }
        return ret;
    }
    
    function safeToString(obj) {
        try {
            return obj + "";
        } catch (e) {
            return "[no string representation]";
        }
    }
    
    function markAsOriginatingFromRejection(e) {
        try {
            notEnumerableProp(e, "isOperational", true);
        }
        catch(ignore) {}
    }
    
    function originatesFromRejection(e) {
        if (e == null) return false;
        return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
            e["isOperational"] === true);
    }
    
    function canAttachTrace(obj) {
        return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
    }
    
    var ensureErrorObject = (function() {
        if (!("stack" in new Error())) {
            return function(value) {
                if (canAttachTrace(value)) return value;
                try {throw new Error(safeToString(value));}
                catch(err) {return err;}
            };
        } else {
            return function(value) {
                if (canAttachTrace(value)) return value;
                return new Error(safeToString(value));
            };
        }
    })();
    
    function classString(obj) {
        return {}.toString.call(obj);
    }
    
    function copyDescriptors(from, to, filter) {
        var keys = es5.names(from);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (filter(key)) {
                try {
                    es5.defineProperty(to, key, es5.getDescriptor(from, key));
                } catch (ignore) {}
            }
        }
    }
    
    var ret = {
        isClass: isClass,
        isIdentifier: isIdentifier,
        inheritedDataKeys: inheritedDataKeys,
        getDataPropertyOrDefault: getDataPropertyOrDefault,
        thrower: thrower,
        isArray: es5.isArray,
        haveGetters: haveGetters,
        notEnumerableProp: notEnumerableProp,
        isPrimitive: isPrimitive,
        isObject: isObject,
        canEvaluate: canEvaluate,
        errorObj: errorObj,
        tryCatch: tryCatch,
        inherits: inherits,
        withAppended: withAppended,
        maybeWrapAsError: maybeWrapAsError,
        toFastProperties: toFastProperties,
        filledRange: filledRange,
        toString: safeToString,
        canAttachTrace: canAttachTrace,
        ensureErrorObject: ensureErrorObject,
        originatesFromRejection: originatesFromRejection,
        markAsOriginatingFromRejection: markAsOriginatingFromRejection,
        classString: classString,
        copyDescriptors: copyDescriptors,
        hasDevTools: typeof chrome !== "undefined" && chrome &&
                     typeof chrome.loadTimes === "function",
        isNode: typeof process !== "undefined" &&
            classString(process).toLowerCase() === "[object process]"
    };
    ret.isRecentNode = ret.isNode && (function() {
        var version = process.versions.node.split(".").map(Number);
        return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
    })();
    
    if (ret.isNode) ret.toFastProperties(process);
    
    try {throw new Error(); } catch (e) {ret.lastLineError = e;}
    module.exports = ret;
    
  provide("bluebird/js/main/util", module.exports);
}(global));

// pakmanager:bluebird/js/main/util.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var es5 =  require('bluebird/js/main/es5.js');
    var canEvaluate = typeof navigator == "undefined";
    var haveGetters = (function(){
        try {
            var o = {};
            es5.defineProperty(o, "f", {
                get: function () {
                    return 3;
                }
            });
            return o.f === 3;
        }
        catch (e) {
            return false;
        }
    
    })();
    
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
        try {
            var target = tryCatchTarget;
            tryCatchTarget = null;
            return target.apply(this, arguments);
        } catch (e) {
            errorObj.e = e;
            return errorObj;
        }
    }
    function tryCatch(fn) {
        tryCatchTarget = fn;
        return tryCatcher;
    }
    
    var inherits = function(Child, Parent) {
        var hasProp = {}.hasOwnProperty;
    
        function T() {
            this.constructor = Child;
            this.constructor$ = Parent;
            for (var propertyName in Parent.prototype) {
                if (hasProp.call(Parent.prototype, propertyName) &&
                    propertyName.charAt(propertyName.length-1) !== "$"
               ) {
                    this[propertyName + "$"] = Parent.prototype[propertyName];
                }
            }
        }
        T.prototype = Parent.prototype;
        Child.prototype = new T();
        return Child.prototype;
    };
    
    
    function isPrimitive(val) {
        return val == null || val === true || val === false ||
            typeof val === "string" || typeof val === "number";
    
    }
    
    function isObject(value) {
        return !isPrimitive(value);
    }
    
    function maybeWrapAsError(maybeError) {
        if (!isPrimitive(maybeError)) return maybeError;
    
        return new Error(safeToString(maybeError));
    }
    
    function withAppended(target, appendee) {
        var len = target.length;
        var ret = new Array(len + 1);
        var i;
        for (i = 0; i < len; ++i) {
            ret[i] = target[i];
        }
        ret[i] = appendee;
        return ret;
    }
    
    function getDataPropertyOrDefault(obj, key, defaultValue) {
        if (es5.isES5) {
            var desc = Object.getOwnPropertyDescriptor(obj, key);
    
            if (desc != null) {
                return desc.get == null && desc.set == null
                        ? desc.value
                        : defaultValue;
            }
        } else {
            return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
        }
    }
    
    function notEnumerableProp(obj, name, value) {
        if (isPrimitive(obj)) return obj;
        var descriptor = {
            value: value,
            configurable: true,
            enumerable: false,
            writable: true
        };
        es5.defineProperty(obj, name, descriptor);
        return obj;
    }
    
    function thrower(r) {
        throw r;
    }
    
    var inheritedDataKeys = (function() {
        var excludedPrototypes = [
            Array.prototype,
            Object.prototype,
            Function.prototype
        ];
    
        var isExcludedProto = function(val) {
            for (var i = 0; i < excludedPrototypes.length; ++i) {
                if (excludedPrototypes[i] === val) {
                    return true;
                }
            }
            return false;
        };
    
        if (es5.isES5) {
            var getKeys = Object.getOwnPropertyNames;
            return function(obj) {
                var ret = [];
                var visitedKeys = Object.create(null);
                while (obj != null && !isExcludedProto(obj)) {
                    var keys;
                    try {
                        keys = getKeys(obj);
                    } catch (e) {
                        return ret;
                    }
                    for (var i = 0; i < keys.length; ++i) {
                        var key = keys[i];
                        if (visitedKeys[key]) continue;
                        visitedKeys[key] = true;
                        var desc = Object.getOwnPropertyDescriptor(obj, key);
                        if (desc != null && desc.get == null && desc.set == null) {
                            ret.push(key);
                        }
                    }
                    obj = es5.getPrototypeOf(obj);
                }
                return ret;
            };
        } else {
            var hasProp = {}.hasOwnProperty;
            return function(obj) {
                if (isExcludedProto(obj)) return [];
                var ret = [];
    
                /*jshint forin:false */
                enumeration: for (var key in obj) {
                    if (hasProp.call(obj, key)) {
                        ret.push(key);
                    } else {
                        for (var i = 0; i < excludedPrototypes.length; ++i) {
                            if (hasProp.call(excludedPrototypes[i], key)) {
                                continue enumeration;
                            }
                        }
                        ret.push(key);
                    }
                }
                return ret;
            };
        }
    
    })();
    
    var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
    function isClass(fn) {
        try {
            if (typeof fn === "function") {
                var keys = es5.names(fn.prototype);
    
                var hasMethods = es5.isES5 && keys.length > 1;
                var hasMethodsOtherThanConstructor = keys.length > 0 &&
                    !(keys.length === 1 && keys[0] === "constructor");
                var hasThisAssignmentAndStaticMethods =
                    thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
    
                if (hasMethods || hasMethodsOtherThanConstructor ||
                    hasThisAssignmentAndStaticMethods) {
                    return true;
                }
            }
            return false;
        } catch (e) {
            return false;
        }
    }
    
    function toFastProperties(obj) {
        /*jshint -W027,-W055,-W031*/
        function f() {}
        f.prototype = obj;
        var l = 8;
        while (l--) new f();
        return obj;
        eval(obj);
    }
    
    var rident = /^[a-z$_][a-z$_0-9]*$/i;
    function isIdentifier(str) {
        return rident.test(str);
    }
    
    function filledRange(count, prefix, suffix) {
        var ret = new Array(count);
        for(var i = 0; i < count; ++i) {
            ret[i] = prefix + i + suffix;
        }
        return ret;
    }
    
    function safeToString(obj) {
        try {
            return obj + "";
        } catch (e) {
            return "[no string representation]";
        }
    }
    
    function markAsOriginatingFromRejection(e) {
        try {
            notEnumerableProp(e, "isOperational", true);
        }
        catch(ignore) {}
    }
    
    function originatesFromRejection(e) {
        if (e == null) return false;
        return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
            e["isOperational"] === true);
    }
    
    function canAttachTrace(obj) {
        return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
    }
    
    var ensureErrorObject = (function() {
        if (!("stack" in new Error())) {
            return function(value) {
                if (canAttachTrace(value)) return value;
                try {throw new Error(safeToString(value));}
                catch(err) {return err;}
            };
        } else {
            return function(value) {
                if (canAttachTrace(value)) return value;
                return new Error(safeToString(value));
            };
        }
    })();
    
    function classString(obj) {
        return {}.toString.call(obj);
    }
    
    function copyDescriptors(from, to, filter) {
        var keys = es5.names(from);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (filter(key)) {
                try {
                    es5.defineProperty(to, key, es5.getDescriptor(from, key));
                } catch (ignore) {}
            }
        }
    }
    
    var ret = {
        isClass: isClass,
        isIdentifier: isIdentifier,
        inheritedDataKeys: inheritedDataKeys,
        getDataPropertyOrDefault: getDataPropertyOrDefault,
        thrower: thrower,
        isArray: es5.isArray,
        haveGetters: haveGetters,
        notEnumerableProp: notEnumerableProp,
        isPrimitive: isPrimitive,
        isObject: isObject,
        canEvaluate: canEvaluate,
        errorObj: errorObj,
        tryCatch: tryCatch,
        inherits: inherits,
        withAppended: withAppended,
        maybeWrapAsError: maybeWrapAsError,
        toFastProperties: toFastProperties,
        filledRange: filledRange,
        toString: safeToString,
        canAttachTrace: canAttachTrace,
        ensureErrorObject: ensureErrorObject,
        originatesFromRejection: originatesFromRejection,
        markAsOriginatingFromRejection: markAsOriginatingFromRejection,
        classString: classString,
        copyDescriptors: copyDescriptors,
        hasDevTools: typeof chrome !== "undefined" && chrome &&
                     typeof chrome.loadTimes === "function",
        isNode: typeof process !== "undefined" &&
            classString(process).toLowerCase() === "[object process]"
    };
    ret.isRecentNode = ret.isNode && (function() {
        var version = process.versions.node.split(".").map(Number);
        return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
    })();
    
    if (ret.isNode) ret.toFastProperties(process);
    
    try {throw new Error(); } catch (e) {ret.lastLineError = e;}
    module.exports = ret;
    
  provide("bluebird/js/main/util.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/schedule.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var schedule;
    var util =  require('bluebird/js/main/util');
    var noAsyncScheduler = function() {
        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
    };
    if (util.isNode && typeof MutationObserver === "undefined") {
        var GlobalSetImmediate = global.setImmediate;
        var ProcessNextTick = process.nextTick;
        schedule = util.isRecentNode
                    ? function(fn) { GlobalSetImmediate.call(global, fn); }
                    : function(fn) { ProcessNextTick.call(process, fn); };
    } else if ((typeof MutationObserver !== "undefined") &&
              !(typeof window !== "undefined" &&
                window.navigator &&
                window.navigator.standalone)) {
        schedule = function(fn) {
            var div = document.createElement("div");
            var observer = new MutationObserver(fn);
            observer.observe(div, {attributes: true});
            return function() { div.classList.toggle("foo"); };
        };
        schedule.isStatic = true;
    } else if (typeof setImmediate !== "undefined") {
        schedule = function (fn) {
            setImmediate(fn);
        };
    } else if (typeof setTimeout !== "undefined") {
        schedule = function (fn) {
            setTimeout(fn, 0);
        };
    } else {
        schedule = noAsyncScheduler;
    }
    module.exports = schedule;
    
  provide("bluebird/js/main/schedule.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/queue.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    function arrayMove(src, srcIndex, dst, dstIndex, len) {
        for (var j = 0; j < len; ++j) {
            dst[j + dstIndex] = src[j + srcIndex];
            src[j + srcIndex] = void 0;
        }
    }
    
    function Queue(capacity) {
        this._capacity = capacity;
        this._length = 0;
        this._front = 0;
    }
    
    Queue.prototype._willBeOverCapacity = function (size) {
        return this._capacity < size;
    };
    
    Queue.prototype._pushOne = function (arg) {
        var length = this.length();
        this._checkCapacity(length + 1);
        var i = (this._front + length) & (this._capacity - 1);
        this[i] = arg;
        this._length = length + 1;
    };
    
    Queue.prototype._unshiftOne = function(value) {
        var capacity = this._capacity;
        this._checkCapacity(this.length() + 1);
        var front = this._front;
        var i = (((( front - 1 ) &
                        ( capacity - 1) ) ^ capacity ) - capacity );
        this[i] = value;
        this._front = i;
        this._length = this.length() + 1;
    };
    
    Queue.prototype.unshift = function(fn, receiver, arg) {
        this._unshiftOne(arg);
        this._unshiftOne(receiver);
        this._unshiftOne(fn);
    };
    
    Queue.prototype.push = function (fn, receiver, arg) {
        var length = this.length() + 3;
        if (this._willBeOverCapacity(length)) {
            this._pushOne(fn);
            this._pushOne(receiver);
            this._pushOne(arg);
            return;
        }
        var j = this._front + length - 3;
        this._checkCapacity(length);
        var wrapMask = this._capacity - 1;
        this[(j + 0) & wrapMask] = fn;
        this[(j + 1) & wrapMask] = receiver;
        this[(j + 2) & wrapMask] = arg;
        this._length = length;
    };
    
    Queue.prototype.shift = function () {
        var front = this._front,
            ret = this[front];
    
        this[front] = undefined;
        this._front = (front + 1) & (this._capacity - 1);
        this._length--;
        return ret;
    };
    
    Queue.prototype.length = function () {
        return this._length;
    };
    
    Queue.prototype._checkCapacity = function (size) {
        if (this._capacity < size) {
            this._resizeTo(this._capacity << 1);
        }
    };
    
    Queue.prototype._resizeTo = function (capacity) {
        var oldCapacity = this._capacity;
        this._capacity = capacity;
        var front = this._front;
        var length = this._length;
        var moveItemsCount = (front + length) & (oldCapacity - 1);
        arrayMove(this, 0, this, oldCapacity, moveItemsCount);
    };
    
    module.exports = Queue;
    
  provide("bluebird/js/main/queue.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/errors.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var es5 =  require('bluebird/js/main/es5.js');
    var Objectfreeze = es5.freeze;
    var util =  require('bluebird/js/main/util.js');
    var inherits = util.inherits;
    var notEnumerableProp = util.notEnumerableProp;
    
    function subError(nameProperty, defaultMessage) {
        function SubError(message) {
            if (!(this instanceof SubError)) return new SubError(message);
            notEnumerableProp(this, "message",
                typeof message === "string" ? message : defaultMessage);
            notEnumerableProp(this, "name", nameProperty);
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
            } else {
                Error.call(this);
            }
        }
        inherits(SubError, Error);
        return SubError;
    }
    
    var _TypeError, _RangeError;
    var Warning = subError("Warning", "warning");
    var CancellationError = subError("CancellationError", "cancellation error");
    var TimeoutError = subError("TimeoutError", "timeout error");
    var AggregateError = subError("AggregateError", "aggregate error");
    try {
        _TypeError = TypeError;
        _RangeError = RangeError;
    } catch(e) {
        _TypeError = subError("TypeError", "type error");
        _RangeError = subError("RangeError", "range error");
    }
    
    var methods = ("join pop push shift unshift slice filter forEach some " +
        "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
    
    for (var i = 0; i < methods.length; ++i) {
        if (typeof Array.prototype[methods[i]] === "function") {
            AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
        }
    }
    
    es5.defineProperty(AggregateError.prototype, "length", {
        value: 0,
        configurable: false,
        writable: true,
        enumerable: true
    });
    AggregateError.prototype["isOperational"] = true;
    var level = 0;
    AggregateError.prototype.toString = function() {
        var indent = Array(level * 4 + 1).join(" ");
        var ret = "\n" + indent + "AggregateError of:" + "\n";
        level++;
        indent = Array(level * 4 + 1).join(" ");
        for (var i = 0; i < this.length; ++i) {
            var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
            var lines = str.split("\n");
            for (var j = 0; j < lines.length; ++j) {
                lines[j] = indent + lines[j];
            }
            str = lines.join("\n");
            ret += str + "\n";
        }
        level--;
        return ret;
    };
    
    function OperationalError(message) {
        if (!(this instanceof OperationalError))
            return new OperationalError(message);
        notEnumerableProp(this, "name", "OperationalError");
        notEnumerableProp(this, "message", message);
        this.cause = message;
        this["isOperational"] = true;
    
        if (message instanceof Error) {
            notEnumerableProp(this, "message", message.message);
            notEnumerableProp(this, "stack", message.stack);
        } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    
    }
    inherits(OperationalError, Error);
    
    var errorTypes = Error["__BluebirdErrorTypes__"];
    if (!errorTypes) {
        errorTypes = Objectfreeze({
            CancellationError: CancellationError,
            TimeoutError: TimeoutError,
            OperationalError: OperationalError,
            RejectionError: OperationalError,
            AggregateError: AggregateError
        });
        notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
    }
    
    module.exports = {
        Error: Error,
        TypeError: _TypeError,
        RangeError: _RangeError,
        CancellationError: errorTypes.CancellationError,
        OperationalError: errorTypes.OperationalError,
        TimeoutError: errorTypes.TimeoutError,
        AggregateError: errorTypes.AggregateError,
        Warning: Warning
    };
    
  provide("bluebird/js/main/errors.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/async.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var firstLineError;
    try {throw new Error(); } catch (e) {firstLineError = e;}
    var schedule =  require('bluebird/js/main/schedule.js');
    var Queue =  require('bluebird/js/main/queue.js');
    var util =  require('bluebird/js/main/util.js');
    
    function Async() {
        this._isTickUsed = false;
        this._lateQueue = new Queue(16);
        this._normalQueue = new Queue(16);
        this._trampolineEnabled = true;
        var self = this;
        this.drainQueues = function () {
            self._drainQueues();
        };
        this._schedule =
            schedule.isStatic ? schedule(this.drainQueues) : schedule;
    }
    
    Async.prototype.disableTrampolineIfNecessary = function() {
        if (util.hasDevTools) {
            this._trampolineEnabled = false;
        }
    };
    
    Async.prototype.enableTrampoline = function() {
        if (!this._trampolineEnabled) {
            this._trampolineEnabled = true;
            this._schedule = function(fn) {
                setTimeout(fn, 0);
            };
        }
    };
    
    Async.prototype.haveItemsQueued = function () {
        return this._normalQueue.length() > 0;
    };
    
    Async.prototype.throwLater = function(fn, arg) {
        if (arguments.length === 1) {
            arg = fn;
            fn = function () { throw arg; };
        }
        if (typeof setTimeout !== "undefined") {
            setTimeout(function() {
                fn(arg);
            }, 0);
        } else try {
            this._schedule(function() {
                fn(arg);
            });
        } catch (e) {
            throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
        }
    };
    
    function AsyncInvokeLater(fn, receiver, arg) {
        this._lateQueue.push(fn, receiver, arg);
        this._queueTick();
    }
    
    function AsyncInvoke(fn, receiver, arg) {
        this._normalQueue.push(fn, receiver, arg);
        this._queueTick();
    }
    
    function AsyncSettlePromises(promise) {
        this._normalQueue._pushOne(promise);
        this._queueTick();
    }
    
    if (!util.hasDevTools) {
        Async.prototype.invokeLater = AsyncInvokeLater;
        Async.prototype.invoke = AsyncInvoke;
        Async.prototype.settlePromises = AsyncSettlePromises;
    } else {
        if (schedule.isStatic) {
            schedule = function(fn) { setTimeout(fn, 0); };
        }
        Async.prototype.invokeLater = function (fn, receiver, arg) {
            if (this._trampolineEnabled) {
                AsyncInvokeLater.call(this, fn, receiver, arg);
            } else {
                this._schedule(function() {
                    setTimeout(function() {
                        fn.call(receiver, arg);
                    }, 100);
                });
            }
        };
    
        Async.prototype.invoke = function (fn, receiver, arg) {
            if (this._trampolineEnabled) {
                AsyncInvoke.call(this, fn, receiver, arg);
            } else {
                this._schedule(function() {
                    fn.call(receiver, arg);
                });
            }
        };
    
        Async.prototype.settlePromises = function(promise) {
            if (this._trampolineEnabled) {
                AsyncSettlePromises.call(this, promise);
            } else {
                this._schedule(function() {
                    promise._settlePromises();
                });
            }
        };
    }
    
    Async.prototype.invokeFirst = function (fn, receiver, arg) {
        this._normalQueue.unshift(fn, receiver, arg);
        this._queueTick();
    };
    
    Async.prototype._drainQueue = function(queue) {
        while (queue.length() > 0) {
            var fn = queue.shift();
            if (typeof fn !== "function") {
                fn._settlePromises();
                continue;
            }
            var receiver = queue.shift();
            var arg = queue.shift();
            fn.call(receiver, arg);
        }
    };
    
    Async.prototype._drainQueues = function () {
        this._drainQueue(this._normalQueue);
        this._reset();
        this._drainQueue(this._lateQueue);
    };
    
    Async.prototype._queueTick = function () {
        if (!this._isTickUsed) {
            this._isTickUsed = true;
            this._schedule(this.drainQueues);
        }
    };
    
    Async.prototype._reset = function () {
        this._isTickUsed = false;
    };
    
    module.exports = new Async();
    module.exports.firstLineError = firstLineError;
    
  provide("bluebird/js/main/async.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/promise_resolver.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var util =  require('bluebird/js/main/util.js');
    var maybeWrapAsError = util.maybeWrapAsError;
    var errors =  require('bluebird/js/main/errors.js');
    var TimeoutError = errors.TimeoutError;
    var OperationalError = errors.OperationalError;
    var haveGetters = util.haveGetters;
    var es5 =  require('bluebird/js/main/es5.js');
    
    function isUntypedError(obj) {
        return obj instanceof Error &&
            es5.getPrototypeOf(obj) === Error.prototype;
    }
    
    var rErrorKey = /^(?:name|message|stack|cause)$/;
    function wrapAsOperationalError(obj) {
        var ret;
        if (isUntypedError(obj)) {
            ret = new OperationalError(obj);
            ret.name = obj.name;
            ret.message = obj.message;
            ret.stack = obj.stack;
            var keys = es5.keys(obj);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (!rErrorKey.test(key)) {
                    ret[key] = obj[key];
                }
            }
            return ret;
        }
        util.markAsOriginatingFromRejection(obj);
        return obj;
    }
    
    function nodebackForPromise(promise) {
        return function(err, value) {
            if (promise === null) return;
    
            if (err) {
                var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
                promise._attachExtraTrace(wrapped);
                promise._reject(wrapped);
            } else if (arguments.length > 2) {
                var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
                promise._fulfill(args);
            } else {
                promise._fulfill(value);
            }
    
            promise = null;
        };
    }
    
    
    var PromiseResolver;
    if (!haveGetters) {
        PromiseResolver = function (promise) {
            this.promise = promise;
            this.asCallback = nodebackForPromise(promise);
            this.callback = this.asCallback;
        };
    }
    else {
        PromiseResolver = function (promise) {
            this.promise = promise;
        };
    }
    if (haveGetters) {
        var prop = {
            get: function() {
                return nodebackForPromise(this.promise);
            }
        };
        es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
        es5.defineProperty(PromiseResolver.prototype, "callback", prop);
    }
    
    PromiseResolver._nodebackForPromise = nodebackForPromise;
    
    PromiseResolver.prototype.toString = function () {
        return "[object PromiseResolver]";
    };
    
    PromiseResolver.prototype.resolve =
    PromiseResolver.prototype.fulfill = function (value) {
        if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
        }
        this.promise._resolveCallback(value);
    };
    
    PromiseResolver.prototype.reject = function (reason) {
        if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
        }
        this.promise._rejectCallback(reason);
    };
    
    PromiseResolver.prototype.progress = function (value) {
        if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
        }
        this.promise._progress(value);
    };
    
    PromiseResolver.prototype.cancel = function (err) {
        this.promise.cancel(err);
    };
    
    PromiseResolver.prototype.timeout = function () {
        this.reject(new TimeoutError("timeout"));
    };
    
    PromiseResolver.prototype.isResolved = function () {
        return this.promise.isResolved();
    };
    
    PromiseResolver.prototype.toJSON = function () {
        return this.promise.toJSON();
    };
    
    module.exports = PromiseResolver;
    
  provide("bluebird/js/main/promise_resolver.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/errors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var es5 =  require('bluebird/js/main/es5.js');
    var Objectfreeze = es5.freeze;
    var util =  require('bluebird/js/main/util.js');
    var inherits = util.inherits;
    var notEnumerableProp = util.notEnumerableProp;
    
    function subError(nameProperty, defaultMessage) {
        function SubError(message) {
            if (!(this instanceof SubError)) return new SubError(message);
            notEnumerableProp(this, "message",
                typeof message === "string" ? message : defaultMessage);
            notEnumerableProp(this, "name", nameProperty);
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
            } else {
                Error.call(this);
            }
        }
        inherits(SubError, Error);
        return SubError;
    }
    
    var _TypeError, _RangeError;
    var Warning = subError("Warning", "warning");
    var CancellationError = subError("CancellationError", "cancellation error");
    var TimeoutError = subError("TimeoutError", "timeout error");
    var AggregateError = subError("AggregateError", "aggregate error");
    try {
        _TypeError = TypeError;
        _RangeError = RangeError;
    } catch(e) {
        _TypeError = subError("TypeError", "type error");
        _RangeError = subError("RangeError", "range error");
    }
    
    var methods = ("join pop push shift unshift slice filter forEach some " +
        "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
    
    for (var i = 0; i < methods.length; ++i) {
        if (typeof Array.prototype[methods[i]] === "function") {
            AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
        }
    }
    
    es5.defineProperty(AggregateError.prototype, "length", {
        value: 0,
        configurable: false,
        writable: true,
        enumerable: true
    });
    AggregateError.prototype["isOperational"] = true;
    var level = 0;
    AggregateError.prototype.toString = function() {
        var indent = Array(level * 4 + 1).join(" ");
        var ret = "\n" + indent + "AggregateError of:" + "\n";
        level++;
        indent = Array(level * 4 + 1).join(" ");
        for (var i = 0; i < this.length; ++i) {
            var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
            var lines = str.split("\n");
            for (var j = 0; j < lines.length; ++j) {
                lines[j] = indent + lines[j];
            }
            str = lines.join("\n");
            ret += str + "\n";
        }
        level--;
        return ret;
    };
    
    function OperationalError(message) {
        if (!(this instanceof OperationalError))
            return new OperationalError(message);
        notEnumerableProp(this, "name", "OperationalError");
        notEnumerableProp(this, "message", message);
        this.cause = message;
        this["isOperational"] = true;
    
        if (message instanceof Error) {
            notEnumerableProp(this, "message", message.message);
            notEnumerableProp(this, "stack", message.stack);
        } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    
    }
    inherits(OperationalError, Error);
    
    var errorTypes = Error["__BluebirdErrorTypes__"];
    if (!errorTypes) {
        errorTypes = Objectfreeze({
            CancellationError: CancellationError,
            TimeoutError: TimeoutError,
            OperationalError: OperationalError,
            RejectionError: OperationalError,
            AggregateError: AggregateError
        });
        notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
    }
    
    module.exports = {
        Error: Error,
        TypeError: _TypeError,
        RangeError: _RangeError,
        CancellationError: errorTypes.CancellationError,
        OperationalError: errorTypes.OperationalError,
        TimeoutError: errorTypes.TimeoutError,
        AggregateError: errorTypes.AggregateError,
        Warning: Warning
    };
    
  provide("bluebird/js/main/errors", module.exports);
}(global));

// pakmanager:bluebird/js/main/thenables.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL) {
    var util =  require('bluebird/js/main/util.js');
    var errorObj = util.errorObj;
    var isObject = util.isObject;
    
    function tryConvertToPromise(obj, context) {
        if (isObject(obj)) {
            if (obj instanceof Promise) {
                return obj;
            }
            else if (isAnyBluebirdPromise(obj)) {
                var ret = new Promise(INTERNAL);
                obj._then(
                    ret._fulfillUnchecked,
                    ret._rejectUncheckedCheckError,
                    ret._progressUnchecked,
                    ret,
                    null
                );
                return ret;
            }
            var then = util.tryCatch(getThen)(obj);
            if (then === errorObj) {
                if (context) context._pushContext();
                var ret = Promise.reject(then.e);
                if (context) context._popContext();
                return ret;
            } else if (typeof then === "function") {
                return doThenable(obj, then, context);
            }
        }
        return obj;
    }
    
    function getThen(obj) {
        return obj.then;
    }
    
    var hasProp = {}.hasOwnProperty;
    function isAnyBluebirdPromise(obj) {
        return hasProp.call(obj, "_promise0");
    }
    
    function doThenable(x, then, context) {
        var promise = new Promise(INTERNAL);
        var ret = promise;
        if (context) context._pushContext();
        promise._captureStackTrace();
        if (context) context._popContext();
        var synchronous = true;
        var result = util.tryCatch(then).call(x,
                                            resolveFromThenable,
                                            rejectFromThenable,
                                            progressFromThenable);
        synchronous = false;
        if (promise && result === errorObj) {
            promise._rejectCallback(result.e, true, true);
            promise = null;
        }
    
        function resolveFromThenable(value) {
            if (!promise) return;
            promise._resolveCallback(value);
            promise = null;
        }
    
        function rejectFromThenable(reason) {
            if (!promise) return;
            promise._rejectCallback(reason, synchronous, true);
            promise = null;
        }
    
        function progressFromThenable(value) {
            if (!promise) return;
            if (typeof promise._progress === "function") {
                promise._progress(value);
            }
        }
        return ret;
    }
    
    return tryConvertToPromise;
    };
    
  provide("bluebird/js/main/thenables.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/promise_array.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL, tryConvertToPromise,
        apiRejection) {
    var util =  require('bluebird/js/main/util.js');
    var isArray = util.isArray;
    
    function toResolutionValue(val) {
        switch(val) {
        case -2: return [];
        case -3: return {};
        }
    }
    
    function PromiseArray(values) {
        var promise = this._promise = new Promise(INTERNAL);
        var parent;
        if (values instanceof Promise) {
            parent = values;
            promise._propagateFrom(parent, 1 | 4);
        }
        this._values = values;
        this._length = 0;
        this._totalResolved = 0;
        this._init(undefined, -2);
    }
    PromiseArray.prototype.length = function () {
        return this._length;
    };
    
    PromiseArray.prototype.promise = function () {
        return this._promise;
    };
    
    PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
        var values = tryConvertToPromise(this._values, this._promise);
        if (values instanceof Promise) {
            values = values._target();
            this._values = values;
            if (values._isFulfilled()) {
                values = values._value();
                if (!isArray(values)) {
                    var err = new Promise.TypeError("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
                    this.__hardReject__(err);
                    return;
                }
            } else if (values._isPending()) {
                values._then(
                    init,
                    this._reject,
                    undefined,
                    this,
                    resolveValueIfEmpty
               );
                return;
            } else {
                this._reject(values._reason());
                return;
            }
        } else if (!isArray(values)) {
            this._promise._reject(apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a")._reason());
            return;
        }
    
        if (values.length === 0) {
            if (resolveValueIfEmpty === -5) {
                this._resolveEmptyArray();
            }
            else {
                this._resolve(toResolutionValue(resolveValueIfEmpty));
            }
            return;
        }
        var len = this.getActualLength(values.length);
        this._length = len;
        this._values = this.shouldCopyValues() ? new Array(len) : this._values;
        var promise = this._promise;
        for (var i = 0; i < len; ++i) {
            var isResolved = this._isResolved();
            var maybePromise = tryConvertToPromise(values[i], promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                if (isResolved) {
                    maybePromise._ignoreRejections();
                } else if (maybePromise._isPending()) {
                    maybePromise._proxyPromiseArray(this, i);
                } else if (maybePromise._isFulfilled()) {
                    this._promiseFulfilled(maybePromise._value(), i);
                } else {
                    this._promiseRejected(maybePromise._reason(), i);
                }
            } else if (!isResolved) {
                this._promiseFulfilled(maybePromise, i);
            }
        }
    };
    
    PromiseArray.prototype._isResolved = function () {
        return this._values === null;
    };
    
    PromiseArray.prototype._resolve = function (value) {
        this._values = null;
        this._promise._fulfill(value);
    };
    
    PromiseArray.prototype.__hardReject__ =
    PromiseArray.prototype._reject = function (reason) {
        this._values = null;
        this._promise._rejectCallback(reason, false, true);
    };
    
    PromiseArray.prototype._promiseProgressed = function (progressValue, index) {
        this._promise._progress({
            index: index,
            value: progressValue
        });
    };
    
    
    PromiseArray.prototype._promiseFulfilled = function (value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            this._resolve(this._values);
        }
    };
    
    PromiseArray.prototype._promiseRejected = function (reason, index) {
        this._totalResolved++;
        this._reject(reason);
    };
    
    PromiseArray.prototype.shouldCopyValues = function () {
        return true;
    };
    
    PromiseArray.prototype.getActualLength = function (len) {
        return len;
    };
    
    return PromiseArray;
    };
    
  provide("bluebird/js/main/promise_array.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/captured_trace.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function() {
    var async =  require('bluebird/js/main/async.js');
    var util =  require('bluebird/js/main/util.js');
    var bluebirdFramePattern =
        /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
    var stackFramePattern = null;
    var formatStack = null;
    var indentStackFrames = false;
    var warn;
    
    function CapturedTrace(parent) {
        this._parent = parent;
        var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
        captureStackTrace(this, CapturedTrace);
        if (length > 32) this.uncycle();
    }
    util.inherits(CapturedTrace, Error);
    
    CapturedTrace.prototype.uncycle = function() {
        var length = this._length;
        if (length < 2) return;
        var nodes = [];
        var stackToIndex = {};
    
        for (var i = 0, node = this; node !== undefined; ++i) {
            nodes.push(node);
            node = node._parent;
        }
        length = this._length = i;
        for (var i = length - 1; i >= 0; --i) {
            var stack = nodes[i].stack;
            if (stackToIndex[stack] === undefined) {
                stackToIndex[stack] = i;
            }
        }
        for (var i = 0; i < length; ++i) {
            var currentStack = nodes[i].stack;
            var index = stackToIndex[currentStack];
            if (index !== undefined && index !== i) {
                if (index > 0) {
                    nodes[index - 1]._parent = undefined;
                    nodes[index - 1]._length = 1;
                }
                nodes[i]._parent = undefined;
                nodes[i]._length = 1;
                var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
    
                if (index < length - 1) {
                    cycleEdgeNode._parent = nodes[index + 1];
                    cycleEdgeNode._parent.uncycle();
                    cycleEdgeNode._length =
                        cycleEdgeNode._parent._length + 1;
                } else {
                    cycleEdgeNode._parent = undefined;
                    cycleEdgeNode._length = 1;
                }
                var currentChildLength = cycleEdgeNode._length + 1;
                for (var j = i - 2; j >= 0; --j) {
                    nodes[j]._length = currentChildLength;
                    currentChildLength++;
                }
                return;
            }
        }
    };
    
    CapturedTrace.prototype.parent = function() {
        return this._parent;
    };
    
    CapturedTrace.prototype.hasParent = function() {
        return this._parent !== undefined;
    };
    
    CapturedTrace.prototype.attachExtraTrace = function(error) {
        if (error.__stackCleaned__) return;
        this.uncycle();
        var parsed = CapturedTrace.parseStackAndMessage(error);
        var message = parsed.message;
        var stacks = [parsed.stack];
    
        var trace = this;
        while (trace !== undefined) {
            stacks.push(cleanStack(trace.stack.split("\n")));
            trace = trace._parent;
        }
        removeCommonRoots(stacks);
        removeDuplicateOrEmptyJumps(stacks);
        util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
        util.notEnumerableProp(error, "__stackCleaned__", true);
    };
    
    function reconstructStack(message, stacks) {
        for (var i = 0; i < stacks.length - 1; ++i) {
            stacks[i].push("From previous event:");
            stacks[i] = stacks[i].join("\n");
        }
        if (i < stacks.length) {
            stacks[i] = stacks[i].join("\n");
        }
        return message + "\n" + stacks.join("\n");
    }
    
    function removeDuplicateOrEmptyJumps(stacks) {
        for (var i = 0; i < stacks.length; ++i) {
            if (stacks[i].length === 0 ||
                ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
                stacks.splice(i, 1);
                i--;
            }
        }
    }
    
    function removeCommonRoots(stacks) {
        var current = stacks[0];
        for (var i = 1; i < stacks.length; ++i) {
            var prev = stacks[i];
            var currentLastIndex = current.length - 1;
            var currentLastLine = current[currentLastIndex];
            var commonRootMeetPoint = -1;
    
            for (var j = prev.length - 1; j >= 0; --j) {
                if (prev[j] === currentLastLine) {
                    commonRootMeetPoint = j;
                    break;
                }
            }
    
            for (var j = commonRootMeetPoint; j >= 0; --j) {
                var line = prev[j];
                if (current[currentLastIndex] === line) {
                    current.pop();
                    currentLastIndex--;
                } else {
                    break;
                }
            }
            current = prev;
        }
    }
    
    function cleanStack(stack) {
        var ret = [];
        for (var i = 0; i < stack.length; ++i) {
            var line = stack[i];
            var isTraceLine = stackFramePattern.test(line) ||
                "    (No stack trace)" === line;
            var isInternalFrame = isTraceLine && shouldIgnore(line);
            if (isTraceLine && !isInternalFrame) {
                if (indentStackFrames && line.charAt(0) !== " ") {
                    line = "    " + line;
                }
                ret.push(line);
            }
        }
        return ret;
    }
    
    function stackFramesAsArray(error) {
        var stack = error.stack.replace(/\s+$/g, "").split("\n");
        for (var i = 0; i < stack.length; ++i) {
            var line = stack[i];
            if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
                break;
            }
        }
        if (i > 0) {
            stack = stack.slice(i);
        }
        return stack;
    }
    
    CapturedTrace.parseStackAndMessage = function(error) {
        var stack = error.stack;
        var message = error.toString();
        stack = typeof stack === "string" && stack.length > 0
                    ? stackFramesAsArray(error) : ["    (No stack trace)"];
        return {
            message: message,
            stack: cleanStack(stack)
        };
    };
    
    CapturedTrace.formatAndLogError = function(error, title) {
        if (typeof console !== "undefined") {
            var message;
            if (typeof error === "object" || typeof error === "function") {
                var stack = error.stack;
                message = title + formatStack(stack, error);
            } else {
                message = title + String(error);
            }
            if (typeof warn === "function") {
                warn(message);
            } else if (typeof console.log === "function" ||
                typeof console.log === "object") {
                console.log(message);
            }
        }
    };
    
    CapturedTrace.unhandledRejection = function (reason) {
        CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
    };
    
    CapturedTrace.isSupported = function () {
        return typeof captureStackTrace === "function";
    };
    
    CapturedTrace.fireRejectionEvent =
    function(name, localHandler, reason, promise) {
        var localEventFired = false;
        try {
            if (typeof localHandler === "function") {
                localEventFired = true;
                if (name === "rejectionHandled") {
                    localHandler(promise);
                } else {
                    localHandler(reason, promise);
                }
            }
        } catch (e) {
            async.throwLater(e);
        }
    
        var globalEventFired = false;
        try {
            globalEventFired = fireGlobalEvent(name, reason, promise);
        } catch (e) {
            globalEventFired = true;
            async.throwLater(e);
        }
    
        var domEventFired = false;
        if (fireDomEvent) {
            try {
                domEventFired = fireDomEvent(name.toLowerCase(), {
                    reason: reason,
                    promise: promise
                });
            } catch (e) {
                domEventFired = true;
                async.throwLater(e);
            }
        }
    
        if (!globalEventFired && !localEventFired && !domEventFired &&
            name === "unhandledRejection") {
            CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
        }
    };
    
    function formatNonError(obj) {
        var str;
        if (typeof obj === "function") {
            str = "[function " +
                (obj.name || "anonymous") +
                "]";
        } else {
            str = obj.toString();
            var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
            if (ruselessToString.test(str)) {
                try {
                    var newStr = JSON.stringify(obj);
                    str = newStr;
                }
                catch(e) {
    
                }
            }
            if (str.length === 0) {
                str = "(empty array)";
            }
        }
        return ("(<" + snip(str) + ">, no stack trace)");
    }
    
    function snip(str) {
        var maxChars = 41;
        if (str.length < maxChars) {
            return str;
        }
        return str.substr(0, maxChars - 3) + "...";
    }
    
    var shouldIgnore = function() { return false; };
    var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function parseLineInfo(line) {
        var matches = line.match(parseLineInfoRegex);
        if (matches) {
            return {
                fileName: matches[1],
                line: parseInt(matches[2], 10)
            };
        }
    }
    CapturedTrace.setBounds = function(firstLineError, lastLineError) {
        if (!CapturedTrace.isSupported()) return;
        var firstStackLines = firstLineError.stack.split("\n");
        var lastStackLines = lastLineError.stack.split("\n");
        var firstIndex = -1;
        var lastIndex = -1;
        var firstFileName;
        var lastFileName;
        for (var i = 0; i < firstStackLines.length; ++i) {
            var result = parseLineInfo(firstStackLines[i]);
            if (result) {
                firstFileName = result.fileName;
                firstIndex = result.line;
                break;
            }
        }
        for (var i = 0; i < lastStackLines.length; ++i) {
            var result = parseLineInfo(lastStackLines[i]);
            if (result) {
                lastFileName = result.fileName;
                lastIndex = result.line;
                break;
            }
        }
        if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
            firstFileName !== lastFileName || firstIndex >= lastIndex) {
            return;
        }
    
        shouldIgnore = function(line) {
            if (bluebirdFramePattern.test(line)) return true;
            var info = parseLineInfo(line);
            if (info) {
                if (info.fileName === firstFileName &&
                    (firstIndex <= info.line && info.line <= lastIndex)) {
                    return true;
                }
            }
            return false;
        };
    };
    
    var captureStackTrace = (function stackDetection() {
        var v8stackFramePattern = /^\s*at\s*/;
        var v8stackFormatter = function(stack, error) {
            if (typeof stack === "string") return stack;
    
            if (error.name !== undefined &&
                error.message !== undefined) {
                return error.toString();
            }
            return formatNonError(error);
        };
    
        if (typeof Error.stackTraceLimit === "number" &&
            typeof Error.captureStackTrace === "function") {
            Error.stackTraceLimit = Error.stackTraceLimit + 6;
            stackFramePattern = v8stackFramePattern;
            formatStack = v8stackFormatter;
            var captureStackTrace = Error.captureStackTrace;
    
            shouldIgnore = function(line) {
                return bluebirdFramePattern.test(line);
            };
            return function(receiver, ignoreUntil) {
                Error.stackTraceLimit = Error.stackTraceLimit + 6;
                captureStackTrace(receiver, ignoreUntil);
                Error.stackTraceLimit = Error.stackTraceLimit - 6;
            };
        }
        var err = new Error();
    
        if (typeof err.stack === "string" &&
            err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
            stackFramePattern = /@/;
            formatStack = v8stackFormatter;
            indentStackFrames = true;
            return function captureStackTrace(o) {
                o.stack = new Error().stack;
            };
        }
    
        var hasStackAfterThrow;
        try { throw new Error(); }
        catch(e) {
            hasStackAfterThrow = ("stack" in e);
        }
        if (!("stack" in err) && hasStackAfterThrow &&
            typeof Error.stackTraceLimit === "number") {
            stackFramePattern = v8stackFramePattern;
            formatStack = v8stackFormatter;
            return function captureStackTrace(o) {
                Error.stackTraceLimit = Error.stackTraceLimit + 6;
                try { throw new Error(); }
                catch(e) { o.stack = e.stack; }
                Error.stackTraceLimit = Error.stackTraceLimit - 6;
            };
        }
    
        formatStack = function(stack, error) {
            if (typeof stack === "string") return stack;
    
            if ((typeof error === "object" ||
                typeof error === "function") &&
                error.name !== undefined &&
                error.message !== undefined) {
                return error.toString();
            }
            return formatNonError(error);
        };
    
        return null;
    
    })([]);
    
    var fireDomEvent;
    var fireGlobalEvent = (function() {
        if (util.isNode) {
            return function(name, reason, promise) {
                if (name === "rejectionHandled") {
                    return process.emit(name, promise);
                } else {
                    return process.emit(name, reason, promise);
                }
            };
        } else {
            var customEventWorks = false;
            var anyEventWorks = true;
            try {
                var ev = new self.CustomEvent("test");
                customEventWorks = ev instanceof CustomEvent;
            } catch (e) {}
            if (!customEventWorks) {
                try {
                    var event = document.createEvent("CustomEvent");
                    event.initCustomEvent("testingtheevent", false, true, {});
                    self.dispatchEvent(event);
                } catch (e) {
                    anyEventWorks = false;
                }
            }
            if (anyEventWorks) {
                fireDomEvent = function(type, detail) {
                    var event;
                    if (customEventWorks) {
                        event = new self.CustomEvent(type, {
                            detail: detail,
                            bubbles: false,
                            cancelable: true
                        });
                    } else if (self.dispatchEvent) {
                        event = document.createEvent("CustomEvent");
                        event.initCustomEvent(type, false, true, detail);
                    }
    
                    return event ? !self.dispatchEvent(event) : false;
                };
            }
    
            var toWindowMethodNameMap = {};
            toWindowMethodNameMap["unhandledRejection"] = ("on" +
                "unhandledRejection").toLowerCase();
            toWindowMethodNameMap["rejectionHandled"] = ("on" +
                "rejectionHandled").toLowerCase();
    
            return function(name, reason, promise) {
                var methodName = toWindowMethodNameMap[name];
                var method = self[methodName];
                if (!method) return false;
                if (name === "rejectionHandled") {
                    method.call(self, promise);
                } else {
                    method.call(self, reason, promise);
                }
                return true;
            };
        }
    })();
    
    if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
        warn = function (message) {
            console.warn(message);
        };
        if (util.isNode && process.stderr.isTTY) {
            warn = function(message) {
                process.stderr.write("\u001b[31m" + message + "\u001b[39m\n");
            };
        } else if (!util.isNode && typeof (new Error().stack) === "string") {
            warn = function(message) {
                console.warn("%c" + message, "color: red");
            };
        }
    }
    
    return CapturedTrace;
    };
    
  provide("bluebird/js/main/captured_trace.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/debuggability.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, CapturedTrace) {
    var getDomain = Promise._getDomain;
    var async =  require('bluebird/js/main/async.js');
    var Warning =  require('bluebird/js/main/errors.js').Warning;
    var util =  require('bluebird/js/main/util.js');
    var canAttachTrace = util.canAttachTrace;
    var unhandledRejectionHandled;
    var possiblyUnhandledRejection;
    var debugging = false || (util.isNode &&
                        (!!process.env["BLUEBIRD_DEBUG"] ||
                         process.env["NODE_ENV"] === "development"));
    
    if (debugging) {
        async.disableTrampolineIfNecessary();
    }
    
    Promise.prototype._ignoreRejections = function() {
        this._unsetRejectionIsUnhandled();
        this._bitField = this._bitField | 16777216;
    };
    
    Promise.prototype._ensurePossibleRejectionHandled = function () {
        if ((this._bitField & 16777216) !== 0) return;
        this._setRejectionIsUnhandled();
        async.invokeLater(this._notifyUnhandledRejection, this, undefined);
    };
    
    Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
        CapturedTrace.fireRejectionEvent("rejectionHandled",
                                      unhandledRejectionHandled, undefined, this);
    };
    
    Promise.prototype._notifyUnhandledRejection = function () {
        if (this._isRejectionUnhandled()) {
            var reason = this._getCarriedStackTrace() || this._settledValue;
            this._setUnhandledRejectionIsNotified();
            CapturedTrace.fireRejectionEvent("unhandledRejection",
                                          possiblyUnhandledRejection, reason, this);
        }
    };
    
    Promise.prototype._setUnhandledRejectionIsNotified = function () {
        this._bitField = this._bitField | 524288;
    };
    
    Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
        this._bitField = this._bitField & (~524288);
    };
    
    Promise.prototype._isUnhandledRejectionNotified = function () {
        return (this._bitField & 524288) > 0;
    };
    
    Promise.prototype._setRejectionIsUnhandled = function () {
        this._bitField = this._bitField | 2097152;
    };
    
    Promise.prototype._unsetRejectionIsUnhandled = function () {
        this._bitField = this._bitField & (~2097152);
        if (this._isUnhandledRejectionNotified()) {
            this._unsetUnhandledRejectionIsNotified();
            this._notifyUnhandledRejectionIsHandled();
        }
    };
    
    Promise.prototype._isRejectionUnhandled = function () {
        return (this._bitField & 2097152) > 0;
    };
    
    Promise.prototype._setCarriedStackTrace = function (capturedTrace) {
        this._bitField = this._bitField | 1048576;
        this._fulfillmentHandler0 = capturedTrace;
    };
    
    Promise.prototype._isCarryingStackTrace = function () {
        return (this._bitField & 1048576) > 0;
    };
    
    Promise.prototype._getCarriedStackTrace = function () {
        return this._isCarryingStackTrace()
            ? this._fulfillmentHandler0
            : undefined;
    };
    
    Promise.prototype._captureStackTrace = function () {
        if (debugging) {
            this._trace = new CapturedTrace(this._peekContext());
        }
        return this;
    };
    
    Promise.prototype._attachExtraTrace = function (error, ignoreSelf) {
        if (debugging && canAttachTrace(error)) {
            var trace = this._trace;
            if (trace !== undefined) {
                if (ignoreSelf) trace = trace._parent;
            }
            if (trace !== undefined) {
                trace.attachExtraTrace(error);
            } else if (!error.__stackCleaned__) {
                var parsed = CapturedTrace.parseStackAndMessage(error);
                util.notEnumerableProp(error, "stack",
                    parsed.message + "\n" + parsed.stack.join("\n"));
                util.notEnumerableProp(error, "__stackCleaned__", true);
            }
        }
    };
    
    Promise.prototype._warn = function(message) {
        var warning = new Warning(message);
        var ctx = this._peekContext();
        if (ctx) {
            ctx.attachExtraTrace(warning);
        } else {
            var parsed = CapturedTrace.parseStackAndMessage(warning);
            warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
        }
        CapturedTrace.formatAndLogError(warning, "");
    };
    
    Promise.onPossiblyUnhandledRejection = function (fn) {
        var domain = getDomain();
        possiblyUnhandledRejection =
            typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
                                     : undefined;
    };
    
    Promise.onUnhandledRejectionHandled = function (fn) {
        var domain = getDomain();
        unhandledRejectionHandled =
            typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
                                     : undefined;
    };
    
    Promise.longStackTraces = function () {
        if (async.haveItemsQueued() &&
            debugging === false
       ) {
            throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/DT1qyG\u000a");
        }
        debugging = CapturedTrace.isSupported();
        if (debugging) {
            async.disableTrampolineIfNecessary();
        }
    };
    
    Promise.hasLongStackTraces = function () {
        return debugging && CapturedTrace.isSupported();
    };
    
    if (!CapturedTrace.isSupported()) {
        Promise.longStackTraces = function(){};
        debugging = false;
    }
    
    return function() {
        return debugging;
    };
    };
    
  provide("bluebird/js/main/debuggability.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/context.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, CapturedTrace, isDebugging) {
    var contextStack = [];
    function Context() {
        this._trace = new CapturedTrace(peekContext());
    }
    Context.prototype._pushContext = function () {
        if (!isDebugging()) return;
        if (this._trace !== undefined) {
            contextStack.push(this._trace);
        }
    };
    
    Context.prototype._popContext = function () {
        if (!isDebugging()) return;
        if (this._trace !== undefined) {
            contextStack.pop();
        }
    };
    
    function createContext() {
        if (isDebugging()) return new Context();
    }
    
    function peekContext() {
        var lastIndex = contextStack.length - 1;
        if (lastIndex >= 0) {
            return contextStack[lastIndex];
        }
        return undefined;
    }
    
    Promise.prototype._peekContext = peekContext;
    Promise.prototype._pushContext = Context.prototype._pushContext;
    Promise.prototype._popContext = Context.prototype._popContext;
    
    return createContext;
    };
    
  provide("bluebird/js/main/context.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/catch_filter.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(NEXT_FILTER) {
    var util =  require('bluebird/js/main/util.js');
    var errors =  require('bluebird/js/main/errors.js');
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var keys =  require('bluebird/js/main/es5.js').keys;
    var TypeError = errors.TypeError;
    
    function CatchFilter(instances, callback, promise) {
        this._instances = instances;
        this._callback = callback;
        this._promise = promise;
    }
    
    function safePredicate(predicate, e) {
        var safeObject = {};
        var retfilter = tryCatch(predicate).call(safeObject, e);
    
        if (retfilter === errorObj) return retfilter;
    
        var safeKeys = keys(safeObject);
        if (safeKeys.length) {
            errorObj.e = new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a");
            return errorObj;
        }
        return retfilter;
    }
    
    CatchFilter.prototype.doFilter = function (e) {
        var cb = this._callback;
        var promise = this._promise;
        var boundTo = promise._boundTo;
        for (var i = 0, len = this._instances.length; i < len; ++i) {
            var item = this._instances[i];
            var itemIsErrorType = item === Error ||
                (item != null && item.prototype instanceof Error);
    
            if (itemIsErrorType && e instanceof item) {
                var ret = tryCatch(cb).call(boundTo, e);
                if (ret === errorObj) {
                    NEXT_FILTER.e = ret.e;
                    return NEXT_FILTER;
                }
                return ret;
            } else if (typeof item === "function" && !itemIsErrorType) {
                var shouldHandle = safePredicate(item, e);
                if (shouldHandle === errorObj) {
                    e = errorObj.e;
                    break;
                } else if (shouldHandle) {
                    var ret = tryCatch(cb).call(boundTo, e);
                    if (ret === errorObj) {
                        NEXT_FILTER.e = ret.e;
                        return NEXT_FILTER;
                    }
                    return ret;
                }
            }
        }
        NEXT_FILTER.e = e;
        return NEXT_FILTER;
    };
    
    return CatchFilter;
    };
    
  provide("bluebird/js/main/catch_filter.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/progress.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, PromiseArray) {
    var util =  require('bluebird/js/main/util.js');
    var async =  require('bluebird/js/main/async.js');
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    
    Promise.prototype.progressed = function (handler) {
        return this._then(undefined, undefined, handler, undefined, undefined);
    };
    
    Promise.prototype._progress = function (progressValue) {
        if (this._isFollowingOrFulfilledOrRejected()) return;
        this._target()._progressUnchecked(progressValue);
    
    };
    
    Promise.prototype._progressHandlerAt = function (index) {
        return index === 0
            ? this._progressHandler0
            : this[(index << 2) + index - 5 + 2];
    };
    
    Promise.prototype._doProgressWith = function (progression) {
        var progressValue = progression.value;
        var handler = progression.handler;
        var promise = progression.promise;
        var receiver = progression.receiver;
    
        var ret = tryCatch(handler).call(receiver, progressValue);
        if (ret === errorObj) {
            if (ret.e != null &&
                ret.e.name !== "StopProgressPropagation") {
                var trace = util.canAttachTrace(ret.e)
                    ? ret.e : new Error(util.toString(ret.e));
                promise._attachExtraTrace(trace);
                promise._progress(ret.e);
            }
        } else if (ret instanceof Promise) {
            ret._then(promise._progress, null, null, promise, undefined);
        } else {
            promise._progress(ret);
        }
    };
    
    
    Promise.prototype._progressUnchecked = function (progressValue) {
        var len = this._length();
        var progress = this._progress;
        for (var i = 0; i < len; i++) {
            var handler = this._progressHandlerAt(i);
            var promise = this._promiseAt(i);
            if (!(promise instanceof Promise)) {
                var receiver = this._receiverAt(i);
                if (typeof handler === "function") {
                    handler.call(receiver, progressValue, promise);
                } else if (receiver instanceof PromiseArray &&
                           !receiver._isResolved()) {
                    receiver._promiseProgressed(progressValue, promise);
                }
                continue;
            }
    
            if (typeof handler === "function") {
                async.invoke(this._doProgressWith, this, {
                    handler: handler,
                    promise: promise,
                    receiver: this._receiverAt(i),
                    value: progressValue
                });
            } else {
                async.invoke(progress, promise, progressValue);
            }
        }
    };
    };
    
  provide("bluebird/js/main/progress.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/method.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports =
    function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
    var util =  require('bluebird/js/main/util.js');
    var tryCatch = util.tryCatch;
    
    Promise.method = function (fn) {
        if (typeof fn !== "function") {
            throw new Promise.TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        }
        return function () {
            var ret = new Promise(INTERNAL);
            ret._captureStackTrace();
            ret._pushContext();
            var value = tryCatch(fn).apply(this, arguments);
            ret._popContext();
            ret._resolveFromSyncValue(value);
            return ret;
        };
    };
    
    Promise.attempt = Promise["try"] = function (fn, args, ctx) {
        if (typeof fn !== "function") {
            return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        }
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = util.isArray(args)
            ? tryCatch(fn).apply(ctx, args)
            : tryCatch(fn).call(ctx, args);
        ret._popContext();
        ret._resolveFromSyncValue(value);
        return ret;
    };
    
    Promise.prototype._resolveFromSyncValue = function (value) {
        if (value === util.errorObj) {
            this._rejectCallback(value.e, false, true);
        } else {
            this._resolveCallback(value, true);
        }
    };
    };
    
  provide("bluebird/js/main/method.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/bind.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL, tryConvertToPromise) {
    var rejectThis = function(_, e) {
        this._reject(e);
    };
    
    var targetRejected = function(e, context) {
        context.promiseRejectionQueued = true;
        context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
    };
    
    var bindingResolved = function(thisArg, context) {
        this._setBoundTo(thisArg);
        if (this._isPending()) {
            this._resolveCallback(context.target);
        }
    };
    
    var bindingRejected = function(e, context) {
        if (!context.promiseRejectionQueued) this._reject(e);
    };
    
    Promise.prototype.bind = function (thisArg) {
        var maybePromise = tryConvertToPromise(thisArg);
        var ret = new Promise(INTERNAL);
        ret._propagateFrom(this, 1);
        var target = this._target();
        if (maybePromise instanceof Promise) {
            var context = {
                promiseRejectionQueued: false,
                promise: ret,
                target: target,
                bindingPromise: maybePromise
            };
            target._then(INTERNAL, targetRejected, ret._progress, ret, context);
            maybePromise._then(
                bindingResolved, bindingRejected, ret._progress, ret, context);
        } else {
            ret._setBoundTo(thisArg);
            ret._resolveCallback(target);
        }
        return ret;
    };
    
    Promise.prototype._setBoundTo = function (obj) {
        if (obj !== undefined) {
            this._bitField = this._bitField | 131072;
            this._boundTo = obj;
        } else {
            this._bitField = this._bitField & (~131072);
        }
    };
    
    Promise.prototype._isBound = function () {
        return (this._bitField & 131072) === 131072;
    };
    
    Promise.bind = function (thisArg, value) {
        var maybePromise = tryConvertToPromise(thisArg);
        var ret = new Promise(INTERNAL);
    
        if (maybePromise instanceof Promise) {
            maybePromise._then(function(thisArg) {
                ret._setBoundTo(thisArg);
                ret._resolveCallback(value);
            }, ret._reject, ret._progress, ret, null);
        } else {
            ret._setBoundTo(thisArg);
            ret._resolveCallback(value);
        }
        return ret;
    };
    };
    
  provide("bluebird/js/main/bind.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/finally.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {
    var util =  require('bluebird/js/main/util.js');
    var isPrimitive = util.isPrimitive;
    var thrower = util.thrower;
    
    function returnThis() {
        return this;
    }
    function throwThis() {
        throw this;
    }
    function return$(r) {
        return function() {
            return r;
        };
    }
    function throw$(r) {
        return function() {
            throw r;
        };
    }
    function promisedFinally(ret, reasonOrValue, isFulfilled) {
        var then;
        if (isPrimitive(reasonOrValue)) {
            then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
        } else {
            then = isFulfilled ? returnThis : throwThis;
        }
        return ret._then(then, thrower, undefined, reasonOrValue, undefined);
    }
    
    function finallyHandler(reasonOrValue) {
        var promise = this.promise;
        var handler = this.handler;
    
        var ret = promise._isBound()
                        ? handler.call(promise._boundTo)
                        : handler();
    
        if (ret !== undefined) {
            var maybePromise = tryConvertToPromise(ret, promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                return promisedFinally(maybePromise, reasonOrValue,
                                        promise.isFulfilled());
            }
        }
    
        if (promise.isRejected()) {
            NEXT_FILTER.e = reasonOrValue;
            return NEXT_FILTER;
        } else {
            return reasonOrValue;
        }
    }
    
    function tapHandler(value) {
        var promise = this.promise;
        var handler = this.handler;
    
        var ret = promise._isBound()
                        ? handler.call(promise._boundTo, value)
                        : handler(value);
    
        if (ret !== undefined) {
            var maybePromise = tryConvertToPromise(ret, promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                return promisedFinally(maybePromise, value, true);
            }
        }
        return value;
    }
    
    Promise.prototype._passThroughHandler = function (handler, isFinally) {
        if (typeof handler !== "function") return this.then();
    
        var promiseAndHandler = {
            promise: this,
            handler: handler
        };
    
        return this._then(
                isFinally ? finallyHandler : tapHandler,
                isFinally ? finallyHandler : undefined, undefined,
                promiseAndHandler, undefined);
    };
    
    Promise.prototype.lastly =
    Promise.prototype["finally"] = function (handler) {
        return this._passThroughHandler(handler, true);
    };
    
    Promise.prototype.tap = function (handler) {
        return this._passThroughHandler(handler, false);
    };
    };
    
  provide("bluebird/js/main/finally.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/direct_resolve.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var util =  require('bluebird/js/main/util.js');
    var isPrimitive = util.isPrimitive;
    
    module.exports = function(Promise) {
    var returner = function () {
        return this;
    };
    var thrower = function () {
        throw this;
    };
    var returnUndefined = function() {};
    var throwUndefined = function() {
        throw undefined;
    };
    
    var wrapper = function (value, action) {
        if (action === 1) {
            return function () {
                throw value;
            };
        } else if (action === 2) {
            return function () {
                return value;
            };
        }
    };
    
    
    Promise.prototype["return"] =
    Promise.prototype.thenReturn = function (value) {
        if (value === undefined) return this.then(returnUndefined);
    
        if (isPrimitive(value)) {
            return this._then(
                wrapper(value, 2),
                undefined,
                undefined,
                undefined,
                undefined
           );
        }
        return this._then(returner, undefined, undefined, value, undefined);
    };
    
    Promise.prototype["throw"] =
    Promise.prototype.thenThrow = function (reason) {
        if (reason === undefined) return this.then(throwUndefined);
    
        if (isPrimitive(reason)) {
            return this._then(
                wrapper(reason, 1),
                undefined,
                undefined,
                undefined,
                undefined
           );
        }
        return this._then(thrower, undefined, undefined, reason, undefined);
    };
    };
    
  provide("bluebird/js/main/direct_resolve.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/synchronous_inspection.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise) {
    function PromiseInspection(promise) {
        if (promise !== undefined) {
            promise = promise._target();
            this._bitField = promise._bitField;
            this._settledValue = promise._settledValue;
        }
        else {
            this._bitField = 0;
            this._settledValue = undefined;
        }
    }
    
    PromiseInspection.prototype.value = function () {
        if (!this.isFulfilled()) {
            throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
        }
        return this._settledValue;
    };
    
    PromiseInspection.prototype.error =
    PromiseInspection.prototype.reason = function () {
        if (!this.isRejected()) {
            throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
        }
        return this._settledValue;
    };
    
    PromiseInspection.prototype.isFulfilled =
    Promise.prototype._isFulfilled = function () {
        return (this._bitField & 268435456) > 0;
    };
    
    PromiseInspection.prototype.isRejected =
    Promise.prototype._isRejected = function () {
        return (this._bitField & 134217728) > 0;
    };
    
    PromiseInspection.prototype.isPending =
    Promise.prototype._isPending = function () {
        return (this._bitField & 402653184) === 0;
    };
    
    PromiseInspection.prototype.isResolved =
    Promise.prototype._isResolved = function () {
        return (this._bitField & 402653184) > 0;
    };
    
    Promise.prototype.isPending = function() {
        return this._target()._isPending();
    };
    
    Promise.prototype.isRejected = function() {
        return this._target()._isRejected();
    };
    
    Promise.prototype.isFulfilled = function() {
        return this._target()._isFulfilled();
    };
    
    Promise.prototype.isResolved = function() {
        return this._target()._isResolved();
    };
    
    Promise.prototype._value = function() {
        return this._settledValue;
    };
    
    Promise.prototype._reason = function() {
        this._unsetRejectionIsUnhandled();
        return this._settledValue;
    };
    
    Promise.prototype.value = function() {
        var target = this._target();
        if (!target.isFulfilled()) {
            throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
        }
        return target._settledValue;
    };
    
    Promise.prototype.reason = function() {
        var target = this._target();
        if (!target.isRejected()) {
            throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
        }
        target._unsetRejectionIsUnhandled();
        return target._settledValue;
    };
    
    
    Promise.PromiseInspection = PromiseInspection;
    };
    
  provide("bluebird/js/main/synchronous_inspection.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/join.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports =
    function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
    var util =  require('bluebird/js/main/util.js');
    var canEvaluate = util.canEvaluate;
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var reject;
    
    if (!false) {
    if (canEvaluate) {
        var thenCallback = function(i) {
            return new Function("value", "holder", "                             \n\
                'use strict';                                                    \n\
                holder.pIndex = value;                                           \n\
                holder.checkFulfillment(this);                                   \n\
                ".replace(/Index/g, i));
        };
    
        var caller = function(count) {
            var values = [];
            for (var i = 1; i <= count; ++i) values.push("holder.p" + i);
            return new Function("holder", "                                      \n\
                'use strict';                                                    \n\
                var callback = holder.fn;                                        \n\
                return callback(values);                                         \n\
                ".replace(/values/g, values.join(", ")));
        };
        var thenCallbacks = [];
        var callers = [undefined];
        for (var i = 1; i <= 5; ++i) {
            thenCallbacks.push(thenCallback(i));
            callers.push(caller(i));
        }
    
        var Holder = function(total, fn) {
            this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
            this.fn = fn;
            this.total = total;
            this.now = 0;
        };
    
        Holder.prototype.callers = callers;
        Holder.prototype.checkFulfillment = function(promise) {
            var now = this.now;
            now++;
            var total = this.total;
            if (now >= total) {
                var handler = this.callers[total];
                promise._pushContext();
                var ret = tryCatch(handler)(this);
                promise._popContext();
                if (ret === errorObj) {
                    promise._rejectCallback(ret.e, false, true);
                } else {
                    promise._resolveCallback(ret);
                }
            } else {
                this.now = now;
            }
        };
    
        var reject = function (reason) {
            this._reject(reason);
        };
    }
    }
    
    Promise.join = function () {
        var last = arguments.length - 1;
        var fn;
        if (last > 0 && typeof arguments[last] === "function") {
            fn = arguments[last];
            if (!false) {
                if (last < 6 && canEvaluate) {
                    var ret = new Promise(INTERNAL);
                    ret._captureStackTrace();
                    var holder = new Holder(last, fn);
                    var callbacks = thenCallbacks;
                    for (var i = 0; i < last; ++i) {
                        var maybePromise = tryConvertToPromise(arguments[i], ret);
                        if (maybePromise instanceof Promise) {
                            maybePromise = maybePromise._target();
                            if (maybePromise._isPending()) {
                                maybePromise._then(callbacks[i], reject,
                                                   undefined, ret, holder);
                            } else if (maybePromise._isFulfilled()) {
                                callbacks[i].call(ret,
                                                  maybePromise._value(), holder);
                            } else {
                                ret._reject(maybePromise._reason());
                            }
                        } else {
                            callbacks[i].call(ret, maybePromise, holder);
                        }
                    }
                    return ret;
                }
            }
        }
        var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
        if (fn) args.pop();
        var ret = new PromiseArray(args).promise();
        return fn !== undefined ? ret.spread(fn) : ret;
    };
    
    };
    
  provide("bluebird/js/main/join.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/map.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise,
                              PromiseArray,
                              apiRejection,
                              tryConvertToPromise,
                              INTERNAL) {
    var async =  require('bluebird/js/main/async.js');
    var util =  require('bluebird/js/main/util.js');
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var PENDING = {};
    var EMPTY_ARRAY = [];
    
    function MappingPromiseArray(promises, fn, limit, _filter) {
        this.constructor$(promises);
        this._promise._captureStackTrace();
        this._callback = fn;
        this._preservedValues = _filter === INTERNAL
            ? new Array(this.length())
            : null;
        this._limit = limit;
        this._inFlight = 0;
        this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
        async.invoke(init, this, undefined);
    }
    util.inherits(MappingPromiseArray, PromiseArray);
    function init() {this._init$(undefined, -2);}
    
    MappingPromiseArray.prototype._init = function () {};
    
    MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
        var values = this._values;
        var length = this.length();
        var preservedValues = this._preservedValues;
        var limit = this._limit;
        if (values[index] === PENDING) {
            values[index] = value;
            if (limit >= 1) {
                this._inFlight--;
                this._drainQueue();
                if (this._isResolved()) return;
            }
        } else {
            if (limit >= 1 && this._inFlight >= limit) {
                values[index] = value;
                this._queue.push(index);
                return;
            }
            if (preservedValues !== null) preservedValues[index] = value;
    
            var callback = this._callback;
            var receiver = this._promise._boundTo;
            this._promise._pushContext();
            var ret = tryCatch(callback).call(receiver, value, index, length);
            this._promise._popContext();
            if (ret === errorObj) return this._reject(ret.e);
    
            var maybePromise = tryConvertToPromise(ret, this._promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                if (maybePromise._isPending()) {
                    if (limit >= 1) this._inFlight++;
                    values[index] = PENDING;
                    return maybePromise._proxyPromiseArray(this, index);
                } else if (maybePromise._isFulfilled()) {
                    ret = maybePromise._value();
                } else {
                    return this._reject(maybePromise._reason());
                }
            }
            values[index] = ret;
        }
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= length) {
            if (preservedValues !== null) {
                this._filter(values, preservedValues);
            } else {
                this._resolve(values);
            }
    
        }
    };
    
    MappingPromiseArray.prototype._drainQueue = function () {
        var queue = this._queue;
        var limit = this._limit;
        var values = this._values;
        while (queue.length > 0 && this._inFlight < limit) {
            if (this._isResolved()) return;
            var index = queue.pop();
            this._promiseFulfilled(values[index], index);
        }
    };
    
    MappingPromiseArray.prototype._filter = function (booleans, values) {
        var len = values.length;
        var ret = new Array(len);
        var j = 0;
        for (var i = 0; i < len; ++i) {
            if (booleans[i]) ret[j++] = values[i];
        }
        ret.length = j;
        this._resolve(ret);
    };
    
    MappingPromiseArray.prototype.preservedValues = function () {
        return this._preservedValues;
    };
    
    function map(promises, fn, options, _filter) {
        var limit = typeof options === "object" && options !== null
            ? options.concurrency
            : 0;
        limit = typeof limit === "number" &&
            isFinite(limit) && limit >= 1 ? limit : 0;
        return new MappingPromiseArray(promises, fn, limit, _filter);
    }
    
    Promise.prototype.map = function (fn, options) {
        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    
        return map(this, fn, options, null).promise();
    };
    
    Promise.map = function (promises, fn, options, _filter) {
        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        return map(promises, fn, options, _filter).promise();
    };
    
    
    };
    
  provide("bluebird/js/main/map.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/cancel.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise) {
    var errors =  require('bluebird/js/main/errors.js');
    var async =  require('bluebird/js/main/async.js');
    var CancellationError = errors.CancellationError;
    
    Promise.prototype._cancel = function (reason) {
        if (!this.isCancellable()) return this;
        var parent;
        var promiseToReject = this;
        while ((parent = promiseToReject._cancellationParent) !== undefined &&
            parent.isCancellable()) {
            promiseToReject = parent;
        }
        this._unsetCancellable();
        promiseToReject._target()._rejectCallback(reason, false, true);
    };
    
    Promise.prototype.cancel = function (reason) {
        if (!this.isCancellable()) return this;
        if (reason === undefined) reason = new CancellationError();
        async.invokeLater(this._cancel, this, reason);
        return this;
    };
    
    Promise.prototype.cancellable = function () {
        if (this._cancellable()) return this;
        async.enableTrampoline();
        this._setCancellable();
        this._cancellationParent = undefined;
        return this;
    };
    
    Promise.prototype.uncancellable = function () {
        var ret = this.then();
        ret._unsetCancellable();
        return ret;
    };
    
    Promise.prototype.fork = function (didFulfill, didReject, didProgress) {
        var ret = this._then(didFulfill, didReject, didProgress,
                             undefined, undefined);
    
        ret._setCancellable();
        ret._cancellationParent = undefined;
        return ret;
    };
    };
    
  provide("bluebird/js/main/cancel.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/using.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function (Promise, apiRejection, tryConvertToPromise,
        createContext) {
        var TypeError =  require('bluebird/js/main/errors.js').TypeError;
        var inherits =  require('bluebird/js/main/util.js').inherits;
        var PromiseInspection = Promise.PromiseInspection;
    
        function inspectionMapper(inspections) {
            var len = inspections.length;
            for (var i = 0; i < len; ++i) {
                var inspection = inspections[i];
                if (inspection.isRejected()) {
                    return Promise.reject(inspection.error());
                }
                inspections[i] = inspection._settledValue;
            }
            return inspections;
        }
    
        function thrower(e) {
            setTimeout(function(){throw e;}, 0);
        }
    
        function castPreservingDisposable(thenable) {
            var maybePromise = tryConvertToPromise(thenable);
            if (maybePromise !== thenable &&
                typeof thenable._isDisposable === "function" &&
                typeof thenable._getDisposer === "function" &&
                thenable._isDisposable()) {
                maybePromise._setDisposable(thenable._getDisposer());
            }
            return maybePromise;
        }
        function dispose(resources, inspection) {
            var i = 0;
            var len = resources.length;
            var ret = Promise.defer();
            function iterator() {
                if (i >= len) return ret.resolve();
                var maybePromise = castPreservingDisposable(resources[i++]);
                if (maybePromise instanceof Promise &&
                    maybePromise._isDisposable()) {
                    try {
                        maybePromise = tryConvertToPromise(
                            maybePromise._getDisposer().tryDispose(inspection),
                            resources.promise);
                    } catch (e) {
                        return thrower(e);
                    }
                    if (maybePromise instanceof Promise) {
                        return maybePromise._then(iterator, thrower,
                                                  null, null, null);
                    }
                }
                iterator();
            }
            iterator();
            return ret.promise;
        }
    
        function disposerSuccess(value) {
            var inspection = new PromiseInspection();
            inspection._settledValue = value;
            inspection._bitField = 268435456;
            return dispose(this, inspection).thenReturn(value);
        }
    
        function disposerFail(reason) {
            var inspection = new PromiseInspection();
            inspection._settledValue = reason;
            inspection._bitField = 134217728;
            return dispose(this, inspection).thenThrow(reason);
        }
    
        function Disposer(data, promise, context) {
            this._data = data;
            this._promise = promise;
            this._context = context;
        }
    
        Disposer.prototype.data = function () {
            return this._data;
        };
    
        Disposer.prototype.promise = function () {
            return this._promise;
        };
    
        Disposer.prototype.resource = function () {
            if (this.promise().isFulfilled()) {
                return this.promise().value();
            }
            return null;
        };
    
        Disposer.prototype.tryDispose = function(inspection) {
            var resource = this.resource();
            var context = this._context;
            if (context !== undefined) context._pushContext();
            var ret = resource !== null
                ? this.doDispose(resource, inspection) : null;
            if (context !== undefined) context._popContext();
            this._promise._unsetDisposable();
            this._data = null;
            return ret;
        };
    
        Disposer.isDisposer = function (d) {
            return (d != null &&
                    typeof d.resource === "function" &&
                    typeof d.tryDispose === "function");
        };
    
        function FunctionDisposer(fn, promise, context) {
            this.constructor$(fn, promise, context);
        }
        inherits(FunctionDisposer, Disposer);
    
        FunctionDisposer.prototype.doDispose = function (resource, inspection) {
            var fn = this.data();
            return fn.call(resource, resource, inspection);
        };
    
        function maybeUnwrapDisposer(value) {
            if (Disposer.isDisposer(value)) {
                this.resources[this.index]._setDisposable(value);
                return value.promise();
            }
            return value;
        }
    
        Promise.using = function () {
            var len = arguments.length;
            if (len < 2) return apiRejection(
                            "you must pass at least 2 arguments to Promise.using");
            var fn = arguments[len - 1];
            if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
            len--;
            var resources = new Array(len);
            for (var i = 0; i < len; ++i) {
                var resource = arguments[i];
                if (Disposer.isDisposer(resource)) {
                    var disposer = resource;
                    resource = resource.promise();
                    resource._setDisposable(disposer);
                } else {
                    var maybePromise = tryConvertToPromise(resource);
                    if (maybePromise instanceof Promise) {
                        resource =
                            maybePromise._then(maybeUnwrapDisposer, null, null, {
                                resources: resources,
                                index: i
                        }, undefined);
                    }
                }
                resources[i] = resource;
            }
    
            var promise = Promise.settle(resources)
                .then(inspectionMapper)
                .then(function(vals) {
                    promise._pushContext();
                    var ret;
                    try {
                        ret = fn.apply(undefined, vals);
                    } finally {
                        promise._popContext();
                    }
                    return ret;
                })
                ._then(
                    disposerSuccess, disposerFail, undefined, resources, undefined);
            resources.promise = promise;
            return promise;
        };
    
        Promise.prototype._setDisposable = function (disposer) {
            this._bitField = this._bitField | 262144;
            this._disposer = disposer;
        };
    
        Promise.prototype._isDisposable = function () {
            return (this._bitField & 262144) > 0;
        };
    
        Promise.prototype._getDisposer = function () {
            return this._disposer;
        };
    
        Promise.prototype._unsetDisposable = function () {
            this._bitField = this._bitField & (~262144);
            this._disposer = undefined;
        };
    
        Promise.prototype.disposer = function (fn) {
            if (typeof fn === "function") {
                return new FunctionDisposer(fn, this, createContext());
            }
            throw new TypeError();
        };
    
    };
    
  provide("bluebird/js/main/using.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/generators.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise,
                              apiRejection,
                              INTERNAL,
                              tryConvertToPromise) {
    var errors =  require('bluebird/js/main/errors.js');
    var TypeError = errors.TypeError;
    var util =  require('bluebird/js/main/util.js');
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    var yieldHandlers = [];
    
    function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
        for (var i = 0; i < yieldHandlers.length; ++i) {
            traceParent._pushContext();
            var result = tryCatch(yieldHandlers[i])(value);
            traceParent._popContext();
            if (result === errorObj) {
                traceParent._pushContext();
                var ret = Promise.reject(errorObj.e);
                traceParent._popContext();
                return ret;
            }
            var maybePromise = tryConvertToPromise(result, traceParent);
            if (maybePromise instanceof Promise) return maybePromise;
        }
        return null;
    }
    
    function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
        var promise = this._promise = new Promise(INTERNAL);
        promise._captureStackTrace();
        this._stack = stack;
        this._generatorFunction = generatorFunction;
        this._receiver = receiver;
        this._generator = undefined;
        this._yieldHandlers = typeof yieldHandler === "function"
            ? [yieldHandler].concat(yieldHandlers)
            : yieldHandlers;
    }
    
    PromiseSpawn.prototype.promise = function () {
        return this._promise;
    };
    
    PromiseSpawn.prototype._run = function () {
        this._generator = this._generatorFunction.call(this._receiver);
        this._receiver =
            this._generatorFunction = undefined;
        this._next(undefined);
    };
    
    PromiseSpawn.prototype._continue = function (result) {
        if (result === errorObj) {
            return this._promise._rejectCallback(result.e, false, true);
        }
    
        var value = result.value;
        if (result.done === true) {
            this._promise._resolveCallback(value);
        } else {
            var maybePromise = tryConvertToPromise(value, this._promise);
            if (!(maybePromise instanceof Promise)) {
                maybePromise =
                    promiseFromYieldHandler(maybePromise,
                                            this._yieldHandlers,
                                            this._promise);
                if (maybePromise === null) {
                    this._throw(
                        new TypeError(
                            "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/4Y4pDk\u000a\u000a".replace("%s", value) +
                            "From coroutine:\u000a" +
                            this._stack.split("\n").slice(1, -7).join("\n")
                        )
                    );
                    return;
                }
            }
            maybePromise._then(
                this._next,
                this._throw,
                undefined,
                this,
                null
           );
        }
    };
    
    PromiseSpawn.prototype._throw = function (reason) {
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        var result = tryCatch(this._generator["throw"])
            .call(this._generator, reason);
        this._promise._popContext();
        this._continue(result);
    };
    
    PromiseSpawn.prototype._next = function (value) {
        this._promise._pushContext();
        var result = tryCatch(this._generator.next).call(this._generator, value);
        this._promise._popContext();
        this._continue(result);
    };
    
    Promise.coroutine = function (generatorFunction, options) {
        if (typeof generatorFunction !== "function") {
            throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
        }
        var yieldHandler = Object(options).yieldHandler;
        var PromiseSpawn$ = PromiseSpawn;
        var stack = new Error().stack;
        return function () {
            var generator = generatorFunction.apply(this, arguments);
            var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
                                          stack);
            spawn._generator = generator;
            spawn._next(undefined);
            return spawn.promise();
        };
    };
    
    Promise.coroutine.addYieldHandler = function(fn) {
        if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        yieldHandlers.push(fn);
    };
    
    Promise.spawn = function (generatorFunction) {
        if (typeof generatorFunction !== "function") {
            return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
        }
        var spawn = new PromiseSpawn(generatorFunction, this);
        var ret = spawn.promise();
        spawn._run(Promise.spawn);
        return ret;
    };
    };
    
  provide("bluebird/js/main/generators.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/nodeify.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise) {
    var util =  require('bluebird/js/main/util.js');
    var async =  require('bluebird/js/main/async.js');
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    
    function spreadAdapter(val, nodeback) {
        var promise = this;
        if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
        var ret = tryCatch(nodeback).apply(promise._boundTo, [null].concat(val));
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }
    
    function successAdapter(val, nodeback) {
        var promise = this;
        var receiver = promise._boundTo;
        var ret = val === undefined
            ? tryCatch(nodeback).call(receiver, null)
            : tryCatch(nodeback).call(receiver, null, val);
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }
    function errorAdapter(reason, nodeback) {
        var promise = this;
        if (!reason) {
            var target = promise._target();
            var newReason = target._getCarriedStackTrace();
            newReason.cause = reason;
            reason = newReason;
        }
        var ret = tryCatch(nodeback).call(promise._boundTo, reason);
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }
    
    Promise.prototype.asCallback = 
    Promise.prototype.nodeify = function (nodeback, options) {
        if (typeof nodeback == "function") {
            var adapter = successAdapter;
            if (options !== undefined && Object(options).spread) {
                adapter = spreadAdapter;
            }
            this._then(
                adapter,
                errorAdapter,
                undefined,
                this,
                nodeback
            );
        }
        return this;
    };
    };
    
  provide("bluebird/js/main/nodeify.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/call_get.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var cr = Object.create;
    if (cr) {
        var callerCache = cr(null);
        var getterCache = cr(null);
        callerCache[" size"] = getterCache[" size"] = 0;
    }
    
    module.exports = function(Promise) {
    var util =  require('bluebird/js/main/util.js');
    var canEvaluate = util.canEvaluate;
    var isIdentifier = util.isIdentifier;
    
    var getMethodCaller;
    var getGetter;
    if (!false) {
    var makeMethodCaller = function (methodName) {
        return new Function("ensureMethod", "                                    \n\
            return function(obj) {                                               \n\
                'use strict'                                                     \n\
                var len = this.length;                                           \n\
                ensureMethod(obj, 'methodName');                                 \n\
                switch(len) {                                                    \n\
                    case 1: return obj.methodName(this[0]);                      \n\
                    case 2: return obj.methodName(this[0], this[1]);             \n\
                    case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
                    case 0: return obj.methodName();                             \n\
                    default:                                                     \n\
                        return obj.methodName.apply(obj, this);                  \n\
                }                                                                \n\
            };                                                                   \n\
            ".replace(/methodName/g, methodName))(ensureMethod);
    };
    
    var makeGetter = function (propertyName) {
        return new Function("obj", "                                             \n\
            'use strict';                                                        \n\
            return obj.propertyName;                                             \n\
            ".replace("propertyName", propertyName));
    };
    
    var getCompiled = function(name, compiler, cache) {
        var ret = cache[name];
        if (typeof ret !== "function") {
            if (!isIdentifier(name)) {
                return null;
            }
            ret = compiler(name);
            cache[name] = ret;
            cache[" size"]++;
            if (cache[" size"] > 512) {
                var keys = Object.keys(cache);
                for (var i = 0; i < 256; ++i) delete cache[keys[i]];
                cache[" size"] = keys.length - 256;
            }
        }
        return ret;
    };
    
    getMethodCaller = function(name) {
        return getCompiled(name, makeMethodCaller, callerCache);
    };
    
    getGetter = function(name) {
        return getCompiled(name, makeGetter, getterCache);
    };
    }
    
    function ensureMethod(obj, methodName) {
        var fn;
        if (obj != null) fn = obj[methodName];
        if (typeof fn !== "function") {
            var message = "Object " + util.classString(obj) + " has no method '" +
                util.toString(methodName) + "'";
            throw new Promise.TypeError(message);
        }
        return fn;
    }
    
    function caller(obj) {
        var methodName = this.pop();
        var fn = ensureMethod(obj, methodName);
        return fn.apply(obj, this);
    }
    Promise.prototype.call = function (methodName) {
        var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
        if (!false) {
            if (canEvaluate) {
                var maybeCaller = getMethodCaller(methodName);
                if (maybeCaller !== null) {
                    return this._then(
                        maybeCaller, undefined, undefined, args, undefined);
                }
            }
        }
        args.push(methodName);
        return this._then(caller, undefined, undefined, args, undefined);
    };
    
    function namedGetter(obj) {
        return obj[this];
    }
    function indexedGetter(obj) {
        var index = +this;
        if (index < 0) index = Math.max(0, index + obj.length);
        return obj[index];
    }
    Promise.prototype.get = function (propertyName) {
        var isIndex = (typeof propertyName === "number");
        var getter;
        if (!isIndex) {
            if (canEvaluate) {
                var maybeGetter = getGetter(propertyName);
                getter = maybeGetter !== null ? maybeGetter : namedGetter;
            } else {
                getter = namedGetter;
            }
        } else {
            getter = indexedGetter;
        }
        return this._then(getter, undefined, undefined, propertyName, undefined);
    };
    };
    
  provide("bluebird/js/main/call_get.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/props.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(
        Promise, PromiseArray, tryConvertToPromise, apiRejection) {
    var util =  require('bluebird/js/main/util.js');
    var isObject = util.isObject;
    var es5 =  require('bluebird/js/main/es5.js');
    
    function PropertiesPromiseArray(obj) {
        var keys = es5.keys(obj);
        var len = keys.length;
        var values = new Array(len * 2);
        for (var i = 0; i < len; ++i) {
            var key = keys[i];
            values[i] = obj[key];
            values[i + len] = key;
        }
        this.constructor$(values);
    }
    util.inherits(PropertiesPromiseArray, PromiseArray);
    
    PropertiesPromiseArray.prototype._init = function () {
        this._init$(undefined, -3) ;
    };
    
    PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            var val = {};
            var keyOffset = this.length();
            for (var i = 0, len = this.length(); i < len; ++i) {
                val[this._values[i + keyOffset]] = this._values[i];
            }
            this._resolve(val);
        }
    };
    
    PropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {
        this._promise._progress({
            key: this._values[index + this.length()],
            value: value
        });
    };
    
    PropertiesPromiseArray.prototype.shouldCopyValues = function () {
        return false;
    };
    
    PropertiesPromiseArray.prototype.getActualLength = function (len) {
        return len >> 1;
    };
    
    function props(promises) {
        var ret;
        var castValue = tryConvertToPromise(promises);
    
        if (!isObject(castValue)) {
            return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/OsFKC8\u000a");
        } else if (castValue instanceof Promise) {
            ret = castValue._then(
                Promise.props, undefined, undefined, undefined, undefined);
        } else {
            ret = new PropertiesPromiseArray(castValue).promise();
        }
    
        if (castValue instanceof Promise) {
            ret._propagateFrom(castValue, 4);
        }
        return ret;
    }
    
    Promise.prototype.props = function () {
        return props(this);
    };
    
    Promise.props = function (promises) {
        return props(promises);
    };
    };
    
  provide("bluebird/js/main/props.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/race.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(
        Promise, INTERNAL, tryConvertToPromise, apiRejection) {
    var isArray =  require('bluebird/js/main/util.js').isArray;
    
    var raceLater = function (promise) {
        return promise.then(function(array) {
            return race(array, promise);
        });
    };
    
    function race(promises, parent) {
        var maybePromise = tryConvertToPromise(promises);
    
        if (maybePromise instanceof Promise) {
            return raceLater(maybePromise);
        } else if (!isArray(promises)) {
            return apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
        }
    
        var ret = new Promise(INTERNAL);
        if (parent !== undefined) {
            ret._propagateFrom(parent, 4 | 1);
        }
        var fulfill = ret._fulfill;
        var reject = ret._reject;
        for (var i = 0, len = promises.length; i < len; ++i) {
            var val = promises[i];
    
            if (val === undefined && !(i in promises)) {
                continue;
            }
    
            Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
        }
        return ret;
    }
    
    Promise.race = function (promises) {
        return race(promises, undefined);
    };
    
    Promise.prototype.race = function () {
        return race(this, undefined);
    };
    
    };
    
  provide("bluebird/js/main/race.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/reduce.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise,
                              PromiseArray,
                              apiRejection,
                              tryConvertToPromise,
                              INTERNAL) {
    var async =  require('bluebird/js/main/async.js');
    var util =  require('bluebird/js/main/util.js');
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    function ReductionPromiseArray(promises, fn, accum, _each) {
        this.constructor$(promises);
        this._promise._captureStackTrace();
        this._preservedValues = _each === INTERNAL ? [] : null;
        this._zerothIsAccum = (accum === undefined);
        this._gotAccum = false;
        this._reducingIndex = (this._zerothIsAccum ? 1 : 0);
        this._valuesPhase = undefined;
        var maybePromise = tryConvertToPromise(accum, this._promise);
        var rejected = false;
        var isPromise = maybePromise instanceof Promise;
        if (isPromise) {
            maybePromise = maybePromise._target();
            if (maybePromise._isPending()) {
                maybePromise._proxyPromiseArray(this, -1);
            } else if (maybePromise._isFulfilled()) {
                accum = maybePromise._value();
                this._gotAccum = true;
            } else {
                this._reject(maybePromise._reason());
                rejected = true;
            }
        }
        if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;
        this._callback = fn;
        this._accum = accum;
        if (!rejected) async.invoke(init, this, undefined);
    }
    function init() {
        this._init$(undefined, -5);
    }
    util.inherits(ReductionPromiseArray, PromiseArray);
    
    ReductionPromiseArray.prototype._init = function () {};
    
    ReductionPromiseArray.prototype._resolveEmptyArray = function () {
        if (this._gotAccum || this._zerothIsAccum) {
            this._resolve(this._preservedValues !== null
                            ? [] : this._accum);
        }
    };
    
    ReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {
        var values = this._values;
        values[index] = value;
        var length = this.length();
        var preservedValues = this._preservedValues;
        var isEach = preservedValues !== null;
        var gotAccum = this._gotAccum;
        var valuesPhase = this._valuesPhase;
        var valuesPhaseIndex;
        if (!valuesPhase) {
            valuesPhase = this._valuesPhase = new Array(length);
            for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {
                valuesPhase[valuesPhaseIndex] = 0;
            }
        }
        valuesPhaseIndex = valuesPhase[index];
    
        if (index === 0 && this._zerothIsAccum) {
            this._accum = value;
            this._gotAccum = gotAccum = true;
            valuesPhase[index] = ((valuesPhaseIndex === 0)
                ? 1 : 2);
        } else if (index === -1) {
            this._accum = value;
            this._gotAccum = gotAccum = true;
        } else {
            if (valuesPhaseIndex === 0) {
                valuesPhase[index] = 1;
            } else {
                valuesPhase[index] = 2;
                this._accum = value;
            }
        }
        if (!gotAccum) return;
    
        var callback = this._callback;
        var receiver = this._promise._boundTo;
        var ret;
    
        for (var i = this._reducingIndex; i < length; ++i) {
            valuesPhaseIndex = valuesPhase[i];
            if (valuesPhaseIndex === 2) {
                this._reducingIndex = i + 1;
                continue;
            }
            if (valuesPhaseIndex !== 1) return;
            value = values[i];
            this._promise._pushContext();
            if (isEach) {
                preservedValues.push(value);
                ret = tryCatch(callback).call(receiver, value, i, length);
            }
            else {
                ret = tryCatch(callback)
                    .call(receiver, this._accum, value, i, length);
            }
            this._promise._popContext();
    
            if (ret === errorObj) return this._reject(ret.e);
    
            var maybePromise = tryConvertToPromise(ret, this._promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                if (maybePromise._isPending()) {
                    valuesPhase[i] = 4;
                    return maybePromise._proxyPromiseArray(this, i);
                } else if (maybePromise._isFulfilled()) {
                    ret = maybePromise._value();
                } else {
                    return this._reject(maybePromise._reason());
                }
            }
    
            this._reducingIndex = i + 1;
            this._accum = ret;
        }
    
        this._resolve(isEach ? preservedValues : this._accum);
    };
    
    function reduce(promises, fn, initialValue, _each) {
        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
        return array.promise();
    }
    
    Promise.prototype.reduce = function (fn, initialValue) {
        return reduce(this, fn, initialValue, null);
    };
    
    Promise.reduce = function (promises, fn, initialValue, _each) {
        return reduce(promises, fn, initialValue, _each);
    };
    };
    
  provide("bluebird/js/main/reduce.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/settle.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports =
        function(Promise, PromiseArray) {
    var PromiseInspection = Promise.PromiseInspection;
    var util =  require('bluebird/js/main/util.js');
    
    function SettledPromiseArray(values) {
        this.constructor$(values);
    }
    util.inherits(SettledPromiseArray, PromiseArray);
    
    SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
        this._values[index] = inspection;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            this._resolve(this._values);
        }
    };
    
    SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
        var ret = new PromiseInspection();
        ret._bitField = 268435456;
        ret._settledValue = value;
        this._promiseResolved(index, ret);
    };
    SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
        var ret = new PromiseInspection();
        ret._bitField = 134217728;
        ret._settledValue = reason;
        this._promiseResolved(index, ret);
    };
    
    Promise.settle = function (promises) {
        return new SettledPromiseArray(promises).promise();
    };
    
    Promise.prototype.settle = function () {
        return new SettledPromiseArray(this).promise();
    };
    };
    
  provide("bluebird/js/main/settle.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/some.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports =
    function(Promise, PromiseArray, apiRejection) {
    var util =  require('bluebird/js/main/util.js');
    var RangeError =  require('bluebird/js/main/errors.js').RangeError;
    var AggregateError =  require('bluebird/js/main/errors.js').AggregateError;
    var isArray = util.isArray;
    
    
    function SomePromiseArray(values) {
        this.constructor$(values);
        this._howMany = 0;
        this._unwrap = false;
        this._initialized = false;
    }
    util.inherits(SomePromiseArray, PromiseArray);
    
    SomePromiseArray.prototype._init = function () {
        if (!this._initialized) {
            return;
        }
        if (this._howMany === 0) {
            this._resolve([]);
            return;
        }
        this._init$(undefined, -5);
        var isArrayResolved = isArray(this._values);
        if (!this._isResolved() &&
            isArrayResolved &&
            this._howMany > this._canPossiblyFulfill()) {
            this._reject(this._getRangeError(this.length()));
        }
    };
    
    SomePromiseArray.prototype.init = function () {
        this._initialized = true;
        this._init();
    };
    
    SomePromiseArray.prototype.setUnwrap = function () {
        this._unwrap = true;
    };
    
    SomePromiseArray.prototype.howMany = function () {
        return this._howMany;
    };
    
    SomePromiseArray.prototype.setHowMany = function (count) {
        this._howMany = count;
    };
    
    SomePromiseArray.prototype._promiseFulfilled = function (value) {
        this._addFulfilled(value);
        if (this._fulfilled() === this.howMany()) {
            this._values.length = this.howMany();
            if (this.howMany() === 1 && this._unwrap) {
                this._resolve(this._values[0]);
            } else {
                this._resolve(this._values);
            }
        }
    
    };
    SomePromiseArray.prototype._promiseRejected = function (reason) {
        this._addRejected(reason);
        if (this.howMany() > this._canPossiblyFulfill()) {
            var e = new AggregateError();
            for (var i = this.length(); i < this._values.length; ++i) {
                e.push(this._values[i]);
            }
            this._reject(e);
        }
    };
    
    SomePromiseArray.prototype._fulfilled = function () {
        return this._totalResolved;
    };
    
    SomePromiseArray.prototype._rejected = function () {
        return this._values.length - this.length();
    };
    
    SomePromiseArray.prototype._addRejected = function (reason) {
        this._values.push(reason);
    };
    
    SomePromiseArray.prototype._addFulfilled = function (value) {
        this._values[this._totalResolved++] = value;
    };
    
    SomePromiseArray.prototype._canPossiblyFulfill = function () {
        return this.length() - this._rejected();
    };
    
    SomePromiseArray.prototype._getRangeError = function (count) {
        var message = "Input array must contain at least " +
                this._howMany + " items but contains only " + count + " items";
        return new RangeError(message);
    };
    
    SomePromiseArray.prototype._resolveEmptyArray = function () {
        this._reject(this._getRangeError(0));
    };
    
    function some(promises, howMany) {
        if ((howMany | 0) !== howMany || howMany < 0) {
            return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/1wAmHx\u000a");
        }
        var ret = new SomePromiseArray(promises);
        var promise = ret.promise();
        ret.setHowMany(howMany);
        ret.init();
        return promise;
    }
    
    Promise.some = function (promises, howMany) {
        return some(promises, howMany);
    };
    
    Promise.prototype.some = function (howMany) {
        return some(this, howMany);
    };
    
    Promise._SomePromiseArray = SomePromiseArray;
    };
    
  provide("bluebird/js/main/some.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/promisify.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL) {
    var THIS = {};
    var util =  require('bluebird/js/main/util.js');
    var nodebackForPromise =  require('bluebird/js/main/promise_resolver.js')
        ._nodebackForPromise;
    var withAppended = util.withAppended;
    var maybeWrapAsError = util.maybeWrapAsError;
    var canEvaluate = util.canEvaluate;
    var TypeError =  require('bluebird/js/main/errors').TypeError;
    var defaultSuffix = "Async";
    var defaultPromisified = {__isPromisified__: true};
    var noCopyProps = [
        "arity",    "length",
        "name",
        "arguments",
        "caller",
        "callee",
        "prototype",
        "__isPromisified__"
    ];
    var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
    
    var defaultFilter = function(name) {
        return util.isIdentifier(name) &&
            name.charAt(0) !== "_" &&
            name !== "constructor";
    };
    
    function propsFilter(key) {
        return !noCopyPropsPattern.test(key);
    }
    
    function isPromisified(fn) {
        try {
            return fn.__isPromisified__ === true;
        }
        catch (e) {
            return false;
        }
    }
    
    function hasPromisified(obj, key, suffix) {
        var val = util.getDataPropertyOrDefault(obj, key + suffix,
                                                defaultPromisified);
        return val ? isPromisified(val) : false;
    }
    function checkValid(ret, suffix, suffixRegexp) {
        for (var i = 0; i < ret.length; i += 2) {
            var key = ret[i];
            if (suffixRegexp.test(key)) {
                var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
                for (var j = 0; j < ret.length; j += 2) {
                    if (ret[j] === keyWithoutAsyncSuffix) {
                        throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/iWrZbw\u000a"
                            .replace("%s", suffix));
                    }
                }
            }
        }
    }
    
    function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
        var keys = util.inheritedDataKeys(obj);
        var ret = [];
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var value = obj[key];
            var passesDefaultFilter = filter === defaultFilter
                ? true : defaultFilter(key, value, obj);
            if (typeof value === "function" &&
                !isPromisified(value) &&
                !hasPromisified(obj, key, suffix) &&
                filter(key, value, obj, passesDefaultFilter)) {
                ret.push(key, value);
            }
        }
        checkValid(ret, suffix, suffixRegexp);
        return ret;
    }
    
    var escapeIdentRegex = function(str) {
        return str.replace(/([$])/, "\\$");
    };
    
    var makeNodePromisifiedEval;
    if (!false) {
    var switchCaseArgumentOrder = function(likelyArgumentCount) {
        var ret = [likelyArgumentCount];
        var min = Math.max(0, likelyArgumentCount - 1 - 3);
        for(var i = likelyArgumentCount - 1; i >= min; --i) {
            ret.push(i);
        }
        for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
            ret.push(i);
        }
        return ret;
    };
    
    var argumentSequence = function(argumentCount) {
        return util.filledRange(argumentCount, "_arg", "");
    };
    
    var parameterDeclaration = function(parameterCount) {
        return util.filledRange(
            Math.max(parameterCount, 3), "_arg", "");
    };
    
    var parameterCount = function(fn) {
        if (typeof fn.length === "number") {
            return Math.max(Math.min(fn.length, 1023 + 1), 0);
        }
        return 0;
    };
    
    makeNodePromisifiedEval =
    function(callback, receiver, originalName, fn) {
        var newParameterCount = Math.max(0, parameterCount(fn) - 1);
        var argumentOrder = switchCaseArgumentOrder(newParameterCount);
        var shouldProxyThis = typeof callback === "string" || receiver === THIS;
    
        function generateCallForArgumentCount(count) {
            var args = argumentSequence(count).join(", ");
            var comma = count > 0 ? ", " : "";
            var ret;
            if (shouldProxyThis) {
                ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
            } else {
                ret = receiver === undefined
                    ? "ret = callback({{args}}, nodeback); break;\n"
                    : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
            }
            return ret.replace("{{args}}", args).replace(", ", comma);
        }
    
        function generateArgumentSwitchCase() {
            var ret = "";
            for (var i = 0; i < argumentOrder.length; ++i) {
                ret += "case " + argumentOrder[i] +":" +
                    generateCallForArgumentCount(argumentOrder[i]);
            }
    
            ret += "                                                             \n\
            default:                                                             \n\
                var args = new Array(len + 1);                                   \n\
                var i = 0;                                                       \n\
                for (var i = 0; i < len; ++i) {                                  \n\
                   args[i] = arguments[i];                                       \n\
                }                                                                \n\
                args[i] = nodeback;                                              \n\
                [CodeForCall]                                                    \n\
                break;                                                           \n\
            ".replace("[CodeForCall]", (shouldProxyThis
                                    ? "ret = callback.apply(this, args);\n"
                                    : "ret = callback.apply(receiver, args);\n"));
            return ret;
        }
    
        var getFunctionCode = typeof callback === "string"
                                    ? ("this != null ? this['"+callback+"'] : fn")
                                    : "fn";
    
        return new Function("Promise",
                            "fn",
                            "receiver",
                            "withAppended",
                            "maybeWrapAsError",
                            "nodebackForPromise",
                            "tryCatch",
                            "errorObj",
                            "notEnumerableProp",
                            "INTERNAL","'use strict';                            \n\
            var ret = function (Parameters) {                                    \n\
                'use strict';                                                    \n\
                var len = arguments.length;                                      \n\
                var promise = new Promise(INTERNAL);                             \n\
                promise._captureStackTrace();                                    \n\
                var nodeback = nodebackForPromise(promise);                      \n\
                var ret;                                                         \n\
                var callback = tryCatch([GetFunctionCode]);                      \n\
                switch(len) {                                                    \n\
                    [CodeForSwitchCase]                                          \n\
                }                                                                \n\
                if (ret === errorObj) {                                          \n\
                    promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
                }                                                                \n\
                return promise;                                                  \n\
            };                                                                   \n\
            notEnumerableProp(ret, '__isPromisified__', true);                   \n\
            return ret;                                                          \n\
            "
            .replace("Parameters", parameterDeclaration(newParameterCount))
            .replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
            .replace("[GetFunctionCode]", getFunctionCode))(
                Promise,
                fn,
                receiver,
                withAppended,
                maybeWrapAsError,
                nodebackForPromise,
                util.tryCatch,
                util.errorObj,
                util.notEnumerableProp,
                INTERNAL
            );
    };
    }
    
    function makeNodePromisifiedClosure(callback, receiver, _, fn) {
        var defaultThis = (function() {return this;})();
        var method = callback;
        if (typeof method === "string") {
            callback = fn;
        }
        function promisified() {
            var _receiver = receiver;
            if (receiver === THIS) _receiver = this;
            var promise = new Promise(INTERNAL);
            promise._captureStackTrace();
            var cb = typeof method === "string" && this !== defaultThis
                ? this[method] : callback;
            var fn = nodebackForPromise(promise);
            try {
                cb.apply(_receiver, withAppended(arguments, fn));
            } catch(e) {
                promise._rejectCallback(maybeWrapAsError(e), true, true);
            }
            return promise;
        }
        util.notEnumerableProp(promisified, "__isPromisified__", true);
        return promisified;
    }
    
    var makeNodePromisified = canEvaluate
        ? makeNodePromisifiedEval
        : makeNodePromisifiedClosure;
    
    function promisifyAll(obj, suffix, filter, promisifier) {
        var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
        var methods =
            promisifiableMethods(obj, suffix, suffixRegexp, filter);
    
        for (var i = 0, len = methods.length; i < len; i+= 2) {
            var key = methods[i];
            var fn = methods[i+1];
            var promisifiedKey = key + suffix;
            obj[promisifiedKey] = promisifier === makeNodePromisified
                    ? makeNodePromisified(key, THIS, key, fn, suffix)
                    : promisifier(fn, function() {
                        return makeNodePromisified(key, THIS, key, fn, suffix);
                    });
        }
        util.toFastProperties(obj);
        return obj;
    }
    
    function promisify(callback, receiver) {
        return makeNodePromisified(callback, receiver, undefined, callback);
    }
    
    Promise.promisify = function (fn, receiver) {
        if (typeof fn !== "function") {
            throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        }
        if (isPromisified(fn)) {
            return fn;
        }
        var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);
        util.copyDescriptors(fn, ret, propsFilter);
        return ret;
    };
    
    Promise.promisifyAll = function (target, options) {
        if (typeof target !== "function" && typeof target !== "object") {
            throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/9ITlV0\u000a");
        }
        options = Object(options);
        var suffix = options.suffix;
        if (typeof suffix !== "string") suffix = defaultSuffix;
        var filter = options.filter;
        if (typeof filter !== "function") filter = defaultFilter;
        var promisifier = options.promisifier;
        if (typeof promisifier !== "function") promisifier = makeNodePromisified;
    
        if (!util.isIdentifier(suffix)) {
            throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/8FZo5V\u000a");
        }
    
        var keys = util.inheritedDataKeys(target);
        for (var i = 0; i < keys.length; ++i) {
            var value = target[keys[i]];
            if (keys[i] !== "constructor" &&
                util.isClass(value)) {
                promisifyAll(value.prototype, suffix, filter, promisifier);
                promisifyAll(value, suffix, filter, promisifier);
            }
        }
    
        return promisifyAll(target, suffix, filter, promisifier);
    };
    };
    
    
  provide("bluebird/js/main/promisify.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/any.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise) {
    var SomePromiseArray = Promise._SomePromiseArray;
    function any(promises) {
        var ret = new SomePromiseArray(promises);
        var promise = ret.promise();
        ret.setHowMany(1);
        ret.setUnwrap();
        ret.init();
        return promise;
    }
    
    Promise.any = function (promises) {
        return any(promises);
    };
    
    Promise.prototype.any = function () {
        return any(this);
    };
    
    };
    
  provide("bluebird/js/main/any.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/each.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL) {
    var PromiseReduce = Promise.reduce;
    
    Promise.prototype.each = function (fn) {
        return PromiseReduce(this, fn, null, INTERNAL);
    };
    
    Promise.each = function (promises, fn) {
        return PromiseReduce(promises, fn, null, INTERNAL);
    };
    };
    
  provide("bluebird/js/main/each.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/timers.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL) {
    var util =  require('bluebird/js/main/util.js');
    var TimeoutError = Promise.TimeoutError;
    
    var afterTimeout = function (promise, message) {
        if (!promise.isPending()) return;
        if (typeof message !== "string") {
            message = "operation timed out";
        }
        var err = new TimeoutError(message);
        util.markAsOriginatingFromRejection(err);
        promise._attachExtraTrace(err);
        promise._cancel(err);
    };
    
    var afterValue = function(value) { return delay(+this).thenReturn(value); };
    var delay = Promise.delay = function (value, ms) {
        if (ms === undefined) {
            ms = value;
            value = undefined;
            var ret = new Promise(INTERNAL);
            setTimeout(function() { ret._fulfill(); }, ms);
            return ret;
        }
        ms = +ms;
        return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
    };
    
    Promise.prototype.delay = function (ms) {
        return delay(this, ms);
    };
    
    function successClear(value) {
        var handle = this;
        if (handle instanceof Number) handle = +handle;
        clearTimeout(handle);
        return value;
    }
    
    function failureClear(reason) {
        var handle = this;
        if (handle instanceof Number) handle = +handle;
        clearTimeout(handle);
        throw reason;
    }
    
    Promise.prototype.timeout = function (ms, message) {
        ms = +ms;
        var ret = this.then().cancellable();
        ret._cancellationParent = this;
        var handle = setTimeout(function timeoutTimeout() {
            afterTimeout(ret, message);
        }, ms);
        return ret._then(successClear, failureClear, undefined, handle, undefined);
    };
    
    };
    
  provide("bluebird/js/main/timers.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/filter.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL) {
    var PromiseMap = Promise.map;
    
    Promise.prototype.filter = function (fn, options) {
        return PromiseMap(this, fn, options, INTERNAL);
    };
    
    Promise.filter = function (promises, fn, options) {
        return PromiseMap(promises, fn, options, INTERNAL);
    };
    };
    
  provide("bluebird/js/main/filter.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/promise.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function() {
    var makeSelfResolutionError = function () {
        return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/LhFpo0\u000a");
    };
    var reflect = function() {
        return new Promise.PromiseInspection(this._target());
    };
    var apiRejection = function(msg) {
        return Promise.reject(new TypeError(msg));
    };
    
    var util =  require('bluebird/js/main/util.js');
    
    var getDomain;
    if (util.isNode) {
        getDomain = function() {
            var ret = process.domain;
            if (ret === undefined) ret = null;
            return ret;
        };
    } else {
        getDomain = function() {
            return null;
        };
    }
    util.notEnumerableProp(Promise, "_getDomain", getDomain);
    
    var async =  require('bluebird/js/main/async.js');
    var errors =  require('bluebird/js/main/errors.js');
    var TypeError = Promise.TypeError = errors.TypeError;
    Promise.RangeError = errors.RangeError;
    Promise.CancellationError = errors.CancellationError;
    Promise.TimeoutError = errors.TimeoutError;
    Promise.OperationalError = errors.OperationalError;
    Promise.RejectionError = errors.OperationalError;
    Promise.AggregateError = errors.AggregateError;
    var INTERNAL = function(){};
    var APPLY = {};
    var NEXT_FILTER = {e: null};
    var tryConvertToPromise =  require('bluebird/js/main/thenables.js')(Promise, INTERNAL);
    var PromiseArray =
         require('bluebird/js/main/promise_array.js')(Promise, INTERNAL,
                                        tryConvertToPromise, apiRejection);
    var CapturedTrace =  require('bluebird/js/main/captured_trace.js')();
    var isDebugging =  require('bluebird/js/main/debuggability.js')(Promise, CapturedTrace);
     /*jshint unused:false*/
    var createContext =
         require('bluebird/js/main/context.js')(Promise, CapturedTrace, isDebugging);
    var CatchFilter =  require('bluebird/js/main/catch_filter.js')(NEXT_FILTER);
    var PromiseResolver =  require('bluebird/js/main/promise_resolver.js');
    var nodebackForPromise = PromiseResolver._nodebackForPromise;
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    function Promise(resolver) {
        if (typeof resolver !== "function") {
            throw new TypeError("the promise constructor requires a resolver function\u000a\u000a    See http://goo.gl/EC22Yn\u000a");
        }
        if (this.constructor !== Promise) {
            throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/KsIlge\u000a");
        }
        this._bitField = 0;
        this._fulfillmentHandler0 = undefined;
        this._rejectionHandler0 = undefined;
        this._progressHandler0 = undefined;
        this._promise0 = undefined;
        this._receiver0 = undefined;
        this._settledValue = undefined;
        if (resolver !== INTERNAL) this._resolveFromResolver(resolver);
    }
    
    Promise.prototype.toString = function () {
        return "[object Promise]";
    };
    
    Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
        var len = arguments.length;
        if (len > 1) {
            var catchInstances = new Array(len - 1),
                j = 0, i;
            for (i = 0; i < len - 1; ++i) {
                var item = arguments[i];
                if (typeof item === "function") {
                    catchInstances[j++] = item;
                } else {
                    return Promise.reject(
                        new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a"));
                }
            }
            catchInstances.length = j;
            fn = arguments[i];
            var catchFilter = new CatchFilter(catchInstances, fn, this);
            return this._then(undefined, catchFilter.doFilter, undefined,
                catchFilter, undefined);
        }
        return this._then(undefined, fn, undefined, undefined, undefined);
    };
    
    Promise.prototype.reflect = function () {
        return this._then(reflect, reflect, undefined, this, undefined);
    };
    
    Promise.prototype.then = function (didFulfill, didReject, didProgress) {
        if (isDebugging() && arguments.length > 0 &&
            typeof didFulfill !== "function" &&
            typeof didReject !== "function") {
            var msg = ".then() only accepts functions but was passed: " +
                    util.classString(didFulfill);
            if (arguments.length > 1) {
                msg += ", " + util.classString(didReject);
            }
            this._warn(msg);
        }
        return this._then(didFulfill, didReject, didProgress,
            undefined, undefined);
    };
    
    Promise.prototype.done = function (didFulfill, didReject, didProgress) {
        var promise = this._then(didFulfill, didReject, didProgress,
            undefined, undefined);
        promise._setIsFinal();
    };
    
    Promise.prototype.spread = function (didFulfill, didReject) {
        return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);
    };
    
    Promise.prototype.isCancellable = function () {
        return !this.isResolved() &&
            this._cancellable();
    };
    
    Promise.prototype.toJSON = function () {
        var ret = {
            isFulfilled: false,
            isRejected: false,
            fulfillmentValue: undefined,
            rejectionReason: undefined
        };
        if (this.isFulfilled()) {
            ret.fulfillmentValue = this.value();
            ret.isFulfilled = true;
        } else if (this.isRejected()) {
            ret.rejectionReason = this.reason();
            ret.isRejected = true;
        }
        return ret;
    };
    
    Promise.prototype.all = function () {
        return new PromiseArray(this).promise();
    };
    
    Promise.prototype.error = function (fn) {
        return this.caught(util.originatesFromRejection, fn);
    };
    
    Promise.is = function (val) {
        return val instanceof Promise;
    };
    
    Promise.fromNode = function(fn) {
        var ret = new Promise(INTERNAL);
        var result = tryCatch(fn)(nodebackForPromise(ret));
        if (result === errorObj) {
            ret._rejectCallback(result.e, true, true);
        }
        return ret;
    };
    
    Promise.all = function (promises) {
        return new PromiseArray(promises).promise();
    };
    
    Promise.defer = Promise.pending = function () {
        var promise = new Promise(INTERNAL);
        return new PromiseResolver(promise);
    };
    
    Promise.cast = function (obj) {
        var ret = tryConvertToPromise(obj);
        if (!(ret instanceof Promise)) {
            var val = ret;
            ret = new Promise(INTERNAL);
            ret._fulfillUnchecked(val);
        }
        return ret;
    };
    
    Promise.resolve = Promise.fulfilled = Promise.cast;
    
    Promise.reject = Promise.rejected = function (reason) {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._rejectCallback(reason, true);
        return ret;
    };
    
    Promise.setScheduler = function(fn) {
        if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        var prev = async._schedule;
        async._schedule = fn;
        return prev;
    };
    
    Promise.prototype._then = function (
        didFulfill,
        didReject,
        didProgress,
        receiver,
        internalData
    ) {
        var haveInternalData = internalData !== undefined;
        var ret = haveInternalData ? internalData : new Promise(INTERNAL);
    
        if (!haveInternalData) {
            ret._propagateFrom(this, 4 | 1);
            ret._captureStackTrace();
        }
    
        var target = this._target();
        if (target !== this) {
            if (receiver === undefined) receiver = this._boundTo;
            if (!haveInternalData) ret._setIsMigrated();
        }
    
        var callbackIndex = target._addCallbacks(didFulfill,
                                                 didReject,
                                                 didProgress,
                                                 ret,
                                                 receiver,
                                                 getDomain());
    
        if (target._isResolved() && !target._isSettlePromisesQueued()) {
            async.invoke(
                target._settlePromiseAtPostResolution, target, callbackIndex);
        }
    
        return ret;
    };
    
    Promise.prototype._settlePromiseAtPostResolution = function (index) {
        if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();
        this._settlePromiseAt(index);
    };
    
    Promise.prototype._length = function () {
        return this._bitField & 131071;
    };
    
    Promise.prototype._isFollowingOrFulfilledOrRejected = function () {
        return (this._bitField & 939524096) > 0;
    };
    
    Promise.prototype._isFollowing = function () {
        return (this._bitField & 536870912) === 536870912;
    };
    
    Promise.prototype._setLength = function (len) {
        this._bitField = (this._bitField & -131072) |
            (len & 131071);
    };
    
    Promise.prototype._setFulfilled = function () {
        this._bitField = this._bitField | 268435456;
    };
    
    Promise.prototype._setRejected = function () {
        this._bitField = this._bitField | 134217728;
    };
    
    Promise.prototype._setFollowing = function () {
        this._bitField = this._bitField | 536870912;
    };
    
    Promise.prototype._setIsFinal = function () {
        this._bitField = this._bitField | 33554432;
    };
    
    Promise.prototype._isFinal = function () {
        return (this._bitField & 33554432) > 0;
    };
    
    Promise.prototype._cancellable = function () {
        return (this._bitField & 67108864) > 0;
    };
    
    Promise.prototype._setCancellable = function () {
        this._bitField = this._bitField | 67108864;
    };
    
    Promise.prototype._unsetCancellable = function () {
        this._bitField = this._bitField & (~67108864);
    };
    
    Promise.prototype._setIsMigrated = function () {
        this._bitField = this._bitField | 4194304;
    };
    
    Promise.prototype._unsetIsMigrated = function () {
        this._bitField = this._bitField & (~4194304);
    };
    
    Promise.prototype._isMigrated = function () {
        return (this._bitField & 4194304) > 0;
    };
    
    Promise.prototype._receiverAt = function (index) {
        var ret = index === 0
            ? this._receiver0
            : this[
                index * 5 - 5 + 4];
        if (ret === undefined && this._isBound()) {
            return this._boundTo;
        }
        return ret;
    };
    
    Promise.prototype._promiseAt = function (index) {
        return index === 0
            ? this._promise0
            : this[index * 5 - 5 + 3];
    };
    
    Promise.prototype._fulfillmentHandlerAt = function (index) {
        return index === 0
            ? this._fulfillmentHandler0
            : this[index * 5 - 5 + 0];
    };
    
    Promise.prototype._rejectionHandlerAt = function (index) {
        return index === 0
            ? this._rejectionHandler0
            : this[index * 5 - 5 + 1];
    };
    
    Promise.prototype._migrateCallbacks = function (follower, index) {
        var fulfill = follower._fulfillmentHandlerAt(index);
        var reject = follower._rejectionHandlerAt(index);
        var progress = follower._progressHandlerAt(index);
        var promise = follower._promiseAt(index);
        var receiver = follower._receiverAt(index);
        if (promise instanceof Promise) promise._setIsMigrated();
        this._addCallbacks(fulfill, reject, progress, promise, receiver, null);
    };
    
    Promise.prototype._addCallbacks = function (
        fulfill,
        reject,
        progress,
        promise,
        receiver,
        domain
    ) {
        var index = this._length();
    
        if (index >= 131071 - 5) {
            index = 0;
            this._setLength(0);
        }
    
        if (index === 0) {
            this._promise0 = promise;
            if (receiver !== undefined) this._receiver0 = receiver;
            if (typeof fulfill === "function" && !this._isCarryingStackTrace()) {
                this._fulfillmentHandler0 =
                    domain === null ? fulfill : domain.bind(fulfill);
            }
            if (typeof reject === "function") {
                this._rejectionHandler0 =
                    domain === null ? reject : domain.bind(reject);
            }
            if (typeof progress === "function") {
                this._progressHandler0 =
                    domain === null ? progress : domain.bind(progress);
            }
        } else {
            var base = index * 5 - 5;
            this[base + 3] = promise;
            this[base + 4] = receiver;
            if (typeof fulfill === "function") {
                this[base + 0] =
                    domain === null ? fulfill : domain.bind(fulfill);
            }
            if (typeof reject === "function") {
                this[base + 1] =
                    domain === null ? reject : domain.bind(reject);
            }
            if (typeof progress === "function") {
                this[base + 2] =
                    domain === null ? progress : domain.bind(progress);
            }
        }
        this._setLength(index + 1);
        return index;
    };
    
    Promise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {
        var index = this._length();
    
        if (index >= 131071 - 5) {
            index = 0;
            this._setLength(0);
        }
        if (index === 0) {
            this._promise0 = promiseSlotValue;
            this._receiver0 = receiver;
        } else {
            var base = index * 5 - 5;
            this[base + 3] = promiseSlotValue;
            this[base + 4] = receiver;
        }
        this._setLength(index + 1);
    };
    
    Promise.prototype._proxyPromiseArray = function (promiseArray, index) {
        this._setProxyHandlers(promiseArray, index);
    };
    
    Promise.prototype._resolveCallback = function(value, shouldBind) {
        if (this._isFollowingOrFulfilledOrRejected()) return;
        if (value === this)
            return this._rejectCallback(makeSelfResolutionError(), false, true);
        var maybePromise = tryConvertToPromise(value, this);
        if (!(maybePromise instanceof Promise)) return this._fulfill(value);
    
        var propagationFlags = 1 | (shouldBind ? 4 : 0);
        this._propagateFrom(maybePromise, propagationFlags);
        var promise = maybePromise._target();
        if (promise._isPending()) {
            var len = this._length();
            for (var i = 0; i < len; ++i) {
                promise._migrateCallbacks(this, i);
            }
            this._setFollowing();
            this._setLength(0);
            this._setFollowee(promise);
        } else if (promise._isFulfilled()) {
            this._fulfillUnchecked(promise._value());
        } else {
            this._rejectUnchecked(promise._reason(),
                promise._getCarriedStackTrace());
        }
    };
    
    Promise.prototype._rejectCallback =
    function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
        if (!shouldNotMarkOriginatingFromRejection) {
            util.markAsOriginatingFromRejection(reason);
        }
        var trace = util.ensureErrorObject(reason);
        var hasStack = trace === reason;
        this._attachExtraTrace(trace, synchronous ? hasStack : false);
        this._reject(reason, hasStack ? undefined : trace);
    };
    
    Promise.prototype._resolveFromResolver = function (resolver) {
        var promise = this;
        this._captureStackTrace();
        this._pushContext();
        var synchronous = true;
        var r = tryCatch(resolver)(function(value) {
            if (promise === null) return;
            promise._resolveCallback(value);
            promise = null;
        }, function (reason) {
            if (promise === null) return;
            promise._rejectCallback(reason, synchronous);
            promise = null;
        });
        synchronous = false;
        this._popContext();
    
        if (r !== undefined && r === errorObj && promise !== null) {
            promise._rejectCallback(r.e, true, true);
            promise = null;
        }
    };
    
    Promise.prototype._settlePromiseFromHandler = function (
        handler, receiver, value, promise
    ) {
        if (promise._isRejected()) return;
        promise._pushContext();
        var x;
        if (receiver === APPLY && !this._isRejected()) {
            x = tryCatch(handler).apply(this._boundTo, value);
        } else {
            x = tryCatch(handler).call(receiver, value);
        }
        promise._popContext();
    
        if (x === errorObj || x === promise || x === NEXT_FILTER) {
            var err = x === promise ? makeSelfResolutionError() : x.e;
            promise._rejectCallback(err, false, true);
        } else {
            promise._resolveCallback(x);
        }
    };
    
    Promise.prototype._target = function() {
        var ret = this;
        while (ret._isFollowing()) ret = ret._followee();
        return ret;
    };
    
    Promise.prototype._followee = function() {
        return this._rejectionHandler0;
    };
    
    Promise.prototype._setFollowee = function(promise) {
        this._rejectionHandler0 = promise;
    };
    
    Promise.prototype._cleanValues = function () {
        if (this._cancellable()) {
            this._cancellationParent = undefined;
        }
    };
    
    Promise.prototype._propagateFrom = function (parent, flags) {
        if ((flags & 1) > 0 && parent._cancellable()) {
            this._setCancellable();
            this._cancellationParent = parent;
        }
        if ((flags & 4) > 0 && parent._isBound()) {
            this._setBoundTo(parent._boundTo);
        }
    };
    
    Promise.prototype._fulfill = function (value) {
        if (this._isFollowingOrFulfilledOrRejected()) return;
        this._fulfillUnchecked(value);
    };
    
    Promise.prototype._reject = function (reason, carriedStackTrace) {
        if (this._isFollowingOrFulfilledOrRejected()) return;
        this._rejectUnchecked(reason, carriedStackTrace);
    };
    
    Promise.prototype._settlePromiseAt = function (index) {
        var promise = this._promiseAt(index);
        var isPromise = promise instanceof Promise;
    
        if (isPromise && promise._isMigrated()) {
            promise._unsetIsMigrated();
            return async.invoke(this._settlePromiseAt, this, index);
        }
        var handler = this._isFulfilled()
            ? this._fulfillmentHandlerAt(index)
            : this._rejectionHandlerAt(index);
    
        var carriedStackTrace =
            this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;
        var value = this._settledValue;
        var receiver = this._receiverAt(index);
    
    
        this._clearCallbackDataAtIndex(index);
    
        if (typeof handler === "function") {
            if (!isPromise) {
                handler.call(receiver, value, promise);
            } else {
                this._settlePromiseFromHandler(handler, receiver, value, promise);
            }
        } else if (receiver instanceof PromiseArray) {
            if (!receiver._isResolved()) {
                if (this._isFulfilled()) {
                    receiver._promiseFulfilled(value, promise);
                }
                else {
                    receiver._promiseRejected(value, promise);
                }
            }
        } else if (isPromise) {
            if (this._isFulfilled()) {
                promise._fulfill(value);
            } else {
                promise._reject(value, carriedStackTrace);
            }
        }
    
        if (index >= 4 && (index & 31) === 4)
            async.invokeLater(this._setLength, this, 0);
    };
    
    Promise.prototype._clearCallbackDataAtIndex = function(index) {
        if (index === 0) {
            if (!this._isCarryingStackTrace()) {
                this._fulfillmentHandler0 = undefined;
            }
            this._rejectionHandler0 =
            this._progressHandler0 =
            this._receiver0 =
            this._promise0 = undefined;
        } else {
            var base = index * 5 - 5;
            this[base + 3] =
            this[base + 4] =
            this[base + 0] =
            this[base + 1] =
            this[base + 2] = undefined;
        }
    };
    
    Promise.prototype._isSettlePromisesQueued = function () {
        return (this._bitField &
                -1073741824) === -1073741824;
    };
    
    Promise.prototype._setSettlePromisesQueued = function () {
        this._bitField = this._bitField | -1073741824;
    };
    
    Promise.prototype._unsetSettlePromisesQueued = function () {
        this._bitField = this._bitField & (~-1073741824);
    };
    
    Promise.prototype._queueSettlePromises = function() {
        async.settlePromises(this);
        this._setSettlePromisesQueued();
    };
    
    Promise.prototype._fulfillUnchecked = function (value) {
        if (value === this) {
            var err = makeSelfResolutionError();
            this._attachExtraTrace(err);
            return this._rejectUnchecked(err, undefined);
        }
        this._setFulfilled();
        this._settledValue = value;
        this._cleanValues();
    
        if (this._length() > 0) {
            this._queueSettlePromises();
        }
    };
    
    Promise.prototype._rejectUncheckedCheckError = function (reason) {
        var trace = util.ensureErrorObject(reason);
        this._rejectUnchecked(reason, trace === reason ? undefined : trace);
    };
    
    Promise.prototype._rejectUnchecked = function (reason, trace) {
        if (reason === this) {
            var err = makeSelfResolutionError();
            this._attachExtraTrace(err);
            return this._rejectUnchecked(err);
        }
        this._setRejected();
        this._settledValue = reason;
        this._cleanValues();
    
        if (this._isFinal()) {
            async.throwLater(function(e) {
                if ("stack" in e) {
                    async.invokeFirst(
                        CapturedTrace.unhandledRejection, undefined, e);
                }
                throw e;
            }, trace === undefined ? reason : trace);
            return;
        }
    
        if (trace !== undefined && trace !== reason) {
            this._setCarriedStackTrace(trace);
        }
    
        if (this._length() > 0) {
            this._queueSettlePromises();
        } else {
            this._ensurePossibleRejectionHandled();
        }
    };
    
    Promise.prototype._settlePromises = function () {
        this._unsetSettlePromisesQueued();
        var len = this._length();
        for (var i = 0; i < len; i++) {
            this._settlePromiseAt(i);
        }
    };
    
    util.notEnumerableProp(Promise,
                           "_makeSelfResolutionError",
                           makeSelfResolutionError);
    
     require('bluebird/js/main/progress.js')(Promise, PromiseArray);
     require('bluebird/js/main/method.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
     require('bluebird/js/main/bind.js')(Promise, INTERNAL, tryConvertToPromise);
     require('bluebird/js/main/finally.js')(Promise, NEXT_FILTER, tryConvertToPromise);
     require('bluebird/js/main/direct_resolve.js')(Promise);
     require('bluebird/js/main/synchronous_inspection.js')(Promise);
     require('bluebird/js/main/join.js')(Promise, PromiseArray, tryConvertToPromise, INTERNAL);
    Promise.Promise = Promise;
     require('bluebird/js/main/map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
     require('bluebird/js/main/cancel.js')(Promise);
     require('bluebird/js/main/using.js')(Promise, apiRejection, tryConvertToPromise, createContext);
     require('bluebird/js/main/generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);
     require('bluebird/js/main/nodeify.js')(Promise);
     require('bluebird/js/main/call_get.js')(Promise);
     require('bluebird/js/main/props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
     require('bluebird/js/main/race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
     require('bluebird/js/main/reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
     require('bluebird/js/main/settle.js')(Promise, PromiseArray);
     require('bluebird/js/main/some.js')(Promise, PromiseArray, apiRejection);
     require('bluebird/js/main/promisify.js')(Promise, INTERNAL);
     require('bluebird/js/main/any.js')(Promise);
     require('bluebird/js/main/each.js')(Promise, INTERNAL);
     require('bluebird/js/main/timers.js')(Promise, INTERNAL);
     require('bluebird/js/main/filter.js')(Promise, INTERNAL);
                                                             
        util.toFastProperties(Promise);                                          
        util.toFastProperties(Promise.prototype);                                
        function fillTypes(value) {                                              
            var p = new Promise(INTERNAL);                                       
            p._fulfillmentHandler0 = value;                                      
            p._rejectionHandler0 = value;                                        
            p._progressHandler0 = value;                                         
            p._promise0 = value;                                                 
            p._receiver0 = value;                                                
            p._settledValue = value;                                             
        }                                                                        
        // Complete slack tracking, opt out of field-type tracking and           
        // stabilize map                                                         
        fillTypes({a: 1});                                                       
        fillTypes({b: 2});                                                       
        fillTypes({c: 3});                                                       
        fillTypes(1);                                                            
        fillTypes(function(){});                                                 
        fillTypes(undefined);                                                    
        fillTypes(false);                                                        
        fillTypes(new Promise(INTERNAL));                                        
        CapturedTrace.setBounds(async.firstLineError, util.lastLineError);       
        return Promise;                                                          
    
    };
    
  provide("bluebird/js/main/promise.js", module.exports);
}(global));

// pakmanager:bluebird
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var old;
    if (typeof Promise !== "undefined") old = Promise;
    function noConflict() {
        try { if (Promise === bluebird) Promise = old; }
        catch (e) {}
        return bluebird;
    }
    var bluebird =  require('bluebird/js/main/promise.js')();
    bluebird.noConflict = noConflict;
    module.exports = bluebird;
    
  provide("bluebird", module.exports);
}(global));

// pakmanager:hapi/lib/schema
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Joi = require('joi');
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.assert = function (type, options, message) {
    
        var result = Joi.validate(options, internals[type]);
        Hoek.assert(!result.error, 'Invalid', type, 'options', message ? '(' + message + ')' : '', result.error && result.error.annotate());
        return result.value;
    };
    
    
    internals.cache = Joi.object({
        name: Joi.string().invalid('_default'),
        partition: Joi.string(),
        shared: Joi.boolean(),
        engine: Joi.alternatives([
            Joi.object(),
            Joi.func()
        ])
            .required()
    }).unknown();
    
    
    internals.auth = Joi.alternatives([
        Joi.string(),
        Joi.object({
            mode: Joi.string().valid('required', 'optional', 'try'),
            scope: Joi.alternatives([
                Joi.string(),
                Joi.array()
            ])
                .allow(false),
            entity: Joi.string().valid('user', 'app', 'any'),
            strategy: Joi.string(),
            strategies: Joi.array().min(1),
            payload: [
                Joi.string().valid('required', 'optional'),
                Joi.boolean()
            ]
        })
            .without('strategy', 'strategies')
    ]);
    
    
    internals.routeBase = Joi.object({
        app: Joi.object().allow(null),
        auth: internals.auth.allow(false),
        bind: Joi.object().allow(null),
        cache: Joi.object({
            expiresIn: Joi.number(),
            expiresAt: Joi.string(),
            privacy: Joi.string().valid('default', 'public', 'private'),
            statuses: Joi.array().items(Joi.number().integer().min(200)).min(1)
        }),
        cors: Joi.object({
            origin: Joi.array(),
            matchOrigin: Joi.boolean(),
            isOriginExposed: Joi.boolean(),
            maxAge: Joi.number(),
            headers: Joi.array(),
            additionalHeaders: Joi.array(),
            methods: Joi.array(),
            additionalMethods: Joi.array(),
            exposedHeaders: Joi.array(),
            additionalExposedHeaders: Joi.array(),
            credentials: Joi.boolean(),
            override: Joi.boolean()
        })
            .allow(null, false, true),
        files: Joi.object({
            relativeTo: Joi.string().regex(/^([\/\.])|([A-Za-z]:\\)|(\\\\)/).required()
        }),
        json: Joi.object({
            replacer: Joi.alternatives(Joi.func(), Joi.array()).allow(null),
            space: Joi.number().allow(null),
            suffix: Joi.string().allow(null)
        }),
        jsonp: Joi.string(),
        payload: Joi.object({
            output: Joi.string().valid('data', 'stream', 'file'),
            parse: Joi.boolean().allow('gunzip'),
            allow: [
                Joi.string(),
                Joi.array()
            ],
            override: Joi.string(),
            maxBytes: Joi.number(),
            uploads: Joi.string(),
            failAction: Joi.string().valid('error', 'log', 'ignore'),
            timeout: Joi.number().integer().positive().allow(false),
            qs: Joi.object()
        }),
        plugins: Joi.object(),
        response: Joi.object({
            schema: Joi.alternatives(Joi.object(), Joi.func()).allow(true, false),
            status: Joi.object().pattern(/\d\d\d/, Joi.alternatives(Joi.object(), Joi.func()).allow(true, false)),
            sample: Joi.number().min(0).max(100),
            failAction: Joi.string().valid('error', 'log'),
            modify: Joi.boolean(),
            options: Joi.object()
        })
            .without('modify', 'sample'),
        security: Joi.object({
            hsts: [
                Joi.object({
                    maxAge: Joi.number(),
                    includeSubdomains: Joi.boolean()
                }),
                Joi.boolean(),
                Joi.number()
            ],
            xframe: [
                Joi.boolean(),
                Joi.string().valid('sameorigin', 'deny'),
                Joi.object({
                    rule: Joi.string().valid('sameorigin', 'deny', 'allow-from'),
                    source: Joi.string()
                })
            ],
            xss: Joi.boolean(),
            noOpen: Joi.boolean(),
            noSniff: Joi.boolean()
        })
            .allow(null, false, true),
        state: Joi.object({
            parse: Joi.boolean(),
            failAction: Joi.string().valid('error', 'log', 'ignore')
        }),
        timeout: Joi.object({
            socket: Joi.number().integer().positive().allow(false),
            server: Joi.number().integer().positive().allow(false).required()
        }),
        validate: Joi.object({
            headers: Joi.alternatives(Joi.object(), Joi.func()).allow(null, false, true),
            params: Joi.alternatives(Joi.object(), Joi.func()).allow(null, false, true),
            query: Joi.alternatives(Joi.object(), Joi.func()).allow(null, false, true),
            payload: Joi.alternatives(Joi.object(), Joi.func()).allow(null, false, true),
            failAction: [
                Joi.string().valid('error', 'log', 'ignore'),
                Joi.func()
            ],
            errorFields: Joi.object(),
            options: Joi.object()
        })
    });
    
    
    internals.connectionBase = Joi.object({
        app: Joi.object().allow(null),
        load: Joi.object(),
        plugins: Joi.object(),
        query: Joi.object({
            qs: Joi.object()
        }),
        router: Joi.object({
            isCaseSensitive: Joi.boolean(),
            stripTrailingSlash: Joi.boolean()
        }),
        routes: internals.routeBase,
        state: Joi.object()                                     // Cookie defaults
    });
    
    
    internals.server = Joi.object({
        app: Joi.object().allow(null),
        cache: Joi.alternatives([
            Joi.func(),
            internals.cache,
            Joi.array().items(internals.cache).min(1)
        ]).allow(null),
        connections: internals.connectionBase,
        debug: Joi.object({
            request: Joi.array().allow(false),
            log: Joi.array().allow(false)
        }).allow(false),
        files: Joi.object({
            etagsCacheMaxSize: Joi.number().min(0)
        }),
        load: Joi.object(),
        mime: Joi.object(),
        minimal: Joi.boolean(),
        plugins: Joi.object()
    });
    
    
    internals.connection = internals.connectionBase.keys({
        autoListen: Joi.boolean(),
        host: Joi.string().hostname(),
        address: Joi.string().hostname(),
        labels: Joi.array().items(Joi.string()).single(),
        listener: Joi.any(),
        port: Joi.alternatives([
            Joi.number().integer().min(0),          // TCP port
            Joi.string().regex(/\//),               // Unix domain socket
            Joi.string().regex(/^\\\\\.\\pipe\\/)   // Windows named pipe
        ])
            .allow(null),
        tls: Joi.alternatives([
            Joi.object().allow(null),
            Joi.boolean()
        ]),
        uri: Joi.string().regex(/[^/]$/)
    });
    
    
    internals.vhost = Joi.alternatives([
        Joi.string().hostname(),
        Joi.array().items(Joi.string().hostname()).min(1)
    ]);
    
    
    internals.route = Joi.object({
        method: Joi.string().required(),
        path: Joi.string().required(),
        vhost: internals.vhost,
        handler: Joi.any(),                         // Validated in route.config
        config: Joi.object().allow(null)
    });
    
    
    internals.pre = [
        Joi.string(),
        Joi.func(),
        Joi.object({
            method: Joi.alternatives(Joi.string(), Joi.func()).required(),
            assign: Joi.string(),
            mode: Joi.string().valid('serial', 'parallel'),
            failAction: Joi.string().valid('error', 'log', 'ignore')
        })
    ];
    
    
    internals.routeConfig = internals.routeBase.keys({
        id: Joi.string(),
        pre: Joi.array().items(internals.pre.concat(Joi.array().items(internals.pre).min(1))),
        handler: [
            Joi.func(),
            Joi.string(),
            Joi.object().length(1)
        ],
        description: Joi.string(),
        notes: [
            Joi.string(),
            Joi.array().items(Joi.string())
        ],
        tags: [
            Joi.string(),
            Joi.array().items(Joi.string())
        ]
    });
    
    
    internals.cachePolicy = Joi.object({
        cache: Joi.string().allow(null).allow(''),
        segment: Joi.string(),
        shared: Joi.boolean()
    })
        .options({ allowUnknown: true });               // Catbox validates other keys
    
    
    internals.method = Joi.object({
        bind: Joi.object().allow(null),
        generateKey: Joi.func(),
        cache: internals.cachePolicy,
        callback: Joi.boolean()
    });
    
    
    internals.register = Joi.object({
        routes: Joi.object({
            prefix: Joi.string().regex(/^\/.+/),
            vhost: internals.vhost
        }),
        select: Joi.array().items(Joi.string()).single()
    });
    
    internals.dependencies = Joi.array().items(Joi.string()).single();
    
  provide("hapi/lib/schema", module.exports);
}(global));

// pakmanager:hapi/lib/methods
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Boom = require('boom');
    var Hoek = require('hoek');
    var Schema =  require('hapi/lib/schema');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports = module.exports = internals.Methods = function (server) {
    
        this.server = server;
        this.methods = {};
        this._normalized = {};
    };
    
    
    internals.Methods.prototype.add = function (name, method, options, realm) {
    
        if (typeof name !== 'object') {
            return this._add(name, method, options, realm);
        }
    
        // {} or [{}, {}]
    
        var items = [].concat(name);
        for (var i = 0, il = items.length; i < il; ++i) {
            var item = items[i];
            this._add(item.name, item.method, item.options, realm);
        }
    };
    
    
    exports.methodNameRx = /^[_$a-zA-Z][$\w]*(?:\.[_$a-zA-Z][$\w]*)*$/;
    
    
    internals.Methods.prototype._add = function (name, method, options, realm) {
    
        Hoek.assert(typeof method === 'function', 'method must be a function');
        Hoek.assert(typeof name === 'string', 'name must be a string');
        Hoek.assert(name.match(exports.methodNameRx), 'Invalid name:', name);
        Hoek.assert(!Hoek.reach(this.methods, name, { functions: false }), 'Server method function name already exists');
    
        options = options || {};
        Schema.assert('method', options, name);
    
        var settings = Hoek.cloneWithShallow(options, ['bind']);
        settings.generateKey = settings.generateKey || internals.generateKey;
        var bind = settings.bind || realm.settings.bind || null;
    
        var apply = function () {
    
            return method.apply(bind, arguments);
        };
    
        var bound = bind ? apply : method;
    
        // Normalize methods
    
        var normalized = bound;
        if (settings.callback === false) {                                          // Defaults to true
            normalized = function (/* arg1, arg2, ..., argn, methodNext */) {
    
                var args = [];
                for (var i = 0, il = arguments.length; i < il - 1; ++i) {
                    args.push(arguments[i]);
                }
    
                var methodNext = arguments[il - 1];
    
                var result = null;
                var error = null;
    
                try {
                    result = method.apply(bind, args);
                }
                catch (err) {
                    error = err;
                }
    
                if (result instanceof Error) {
                    error = result;
                    result = null;
                }
    
                if (error ||
                    typeof result !== 'object' ||
                    typeof result.then !== 'function') {
    
                    return methodNext(error, result);
                }
    
                // Promise object
    
                var onFulfilled = function (outcome) {
    
                    return methodNext(null, outcome);
                };
    
                var onRejected = function (err) {
    
                    return methodNext(err);
                };
    
                result.then(onFulfilled, onRejected);
            };
        }
    
        // Not cached
    
        if (!settings.cache) {
            return this._assign(name, bound, normalized);
        }
    
        // Cached
    
        Hoek.assert(!settings.cache.generateFunc, 'Cannot set generateFunc with method caching');
    
        settings.cache.generateFunc = function (id, next) {
    
            id.args.push(next);                     // function (err, result, ttl)
            normalized.apply(bind, id.args);
        };
    
        var cache = this.server.cache(settings.cache, '#' + name);
    
        var func = function (/* arguments, methodNext */) {
    
            var args = [];
            for (var i = 0, il = arguments.length; i < il - 1; ++i) {
                args.push(arguments[i]);
            }
    
            var methodNext = arguments[il - 1];
    
            var key = settings.generateKey.apply(bind, args);
            if (key === null ||                                 // Value can be ''
                typeof key !== 'string') {                      // When using custom generateKey
    
                return Hoek.nextTick(methodNext)(Boom.badImplementation('Invalid method key when invoking: ' + name, { name: name, args: args }));
            }
    
            cache.get({ id: key, args: args }, methodNext);
        };
    
        func.cache = {
            drop: function (/* arguments, callback */) {
    
                var args = [];
                for (var i = 0, il = arguments.length; i < il - 1; ++i) {
                    args.push(arguments[i]);
                }
    
                var methodNext = arguments[il - 1];
    
                var key = settings.generateKey.apply(null, args);
                if (key === null) {                             // Value can be ''
                    return Hoek.nextTick(methodNext)(Boom.badImplementation('Invalid method key'));
                }
    
                return cache.drop(key, methodNext);
            }
        };
    
        this._assign(name, func, func);
    };
    
    
    internals.Methods.prototype._assign = function (name, method, normalized) {
    
        var path = name.split('.');
        var ref = this.methods;
        for (var i = 0, il = path.length; i < il; ++i) {
            if (!ref[path[i]]) {
                ref[path[i]] = (i + 1 === il ? method : {});
            }
    
            ref = ref[path[i]];
        }
    
        this._normalized[name] = normalized;
    };
    
    
    internals.generateKey = function () {
    
        var key = '';
        for (var i = 0, il = arguments.length; i < il; ++i) {
            var arg = arguments[i];
            if (typeof arg !== 'string' &&
                typeof arg !== 'number' &&
                typeof arg !== 'boolean') {
    
                return null;
            }
    
            key += (i ? ':' : '') + encodeURIComponent(arg.toString());
        }
    
        return key;
    };
    
  provide("hapi/lib/methods", module.exports);
}(global));

// pakmanager:hapi/lib/response
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Stream = require('stream');
    var Events = require('events');
    var Boom = require('boom');
    var Hoek = require('hoek');
    var Peekaboo = require('peekaboo');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports = module.exports = internals.Response = function (source, request, options) {
    
        Events.EventEmitter.call(this);
    
        options = options || {};
    
        this.request = request;
        this.statusCode = null;
        this.headers = {};                          // Incomplete as some headers are stored in flags
        this.variety = null;
        this.app = {};
        this.plugins = {};
        this.send = null;                           // Set by reply()
        this.hold = null;                           // Set by reply()
    
        this.settings = {
            encoding: 'utf8',
            charset: 'utf-8',                       // '-' required by IANA
            ttl: null,
            stringify: null,                        // JSON.stringify options
            passThrough: true,
            varyEtag: false
        };
    
        this._payload = null;                       // Readable stream
        this._takeover = false;
        this._contentEncoding = null;               // Set during transmit
        this._error = null;                         // The boom object when created from an error
    
        this._processors = {
            marshal: options.marshal,
            prepare: options.prepare,
            close: options.close
        };
    
        this._setSource(source, options.variety);
    };
    
    Hoek.inherits(internals.Response, Events.EventEmitter);
    
    
    internals.Response.wrap = function (result, request) {
    
        return (result instanceof Error ? Boom.wrap(result)
                                        : (result instanceof internals.Response ? result
                                                                                : new internals.Response(result, request)));
    };
    
    
    internals.Response.prototype._setSource = function (source, variety) {
    
        // Method must not set any headers or other properties as source can change later
    
        this.variety = variety || 'plain';
    
        if (source === null ||
            source === undefined ||
            source === '') {
    
            source = null;
        }
        else if (Buffer.isBuffer(source)) {
            this.variety = 'buffer';
        }
        else if (source instanceof Stream) {
            this.variety = 'stream';
        }
        else if (typeof source === 'object' &&
            typeof source.then === 'function') {                // Promise object
    
            this.variety = 'promise';
        }
    
        this.source = source;
    };
    
    
    internals.Response.prototype.code = function (statusCode) {
    
        Hoek.assert(Hoek.isInteger(statusCode), 'Status code must be an integer');
    
        this.statusCode = statusCode;
        return this;
    };
    
    
    internals.Response.prototype.header = function (key, value, options) {
    
        key = key.toLowerCase();
        if (key === 'vary') {
            return this.vary(value);
        }
    
        return this._header(key, value, options);
    };
    
    
    internals.Response.prototype._header = function (key, value, options) {
    
        options = options || {};
        options.append = options.append || false;
        options.separator = options.separator || ',';
        options.override = options.override !== false;
    
        if ((!options.append && options.override) ||
            !this.headers[key]) {
    
            this.headers[key] = value;
        }
        else if (options.override) {
            if (key === 'set-cookie') {
                this.headers[key] = [].concat(this.headers[key], value);
            }
            else {
                this.headers[key] = this.headers[key] + options.separator + value;
            }
        }
    
        return this;
    };
    
    
    internals.Response.prototype.vary = function (value) {
    
        if (value === '*') {
            this.headers.vary = '*';
        }
        else if (!this.headers.vary) {
            this.headers.vary = value;
        }
        else if (this.headers.vary !== '*') {
            this._header('vary', value, { append: true });
        }
    
        return this;
    };
    
    
    internals.Response.prototype.etag = function (tag, options) {
    
        Hoek.assert(tag !== '*', 'ETag cannot be *');
    
        options = options || {};
        this._header('etag', (options.weak ? 'W/' : '') + '"' + tag + '"');
        this.settings.varyEtag = options.vary !== false && !options.weak;       // vary defaults to true
        return this;
    };
    
    
    internals.Response.prototype.type = function (type) {
    
        this._header('content-type', type);
        return this;
    };
    
    
    internals.Response.prototype.bytes = function (bytes) {
    
        this._header('content-length', bytes);
        return this;
    };
    
    
    internals.Response.prototype.location = function (uri) {
    
        this._header('location', uri);
        return this;
    };
    
    
    internals.Response.prototype.created = function (location) {
    
        Hoek.assert(this.request.method === 'post' || this.request.method === 'put', 'Cannot create resource on GET');
    
        this.statusCode = 201;
        this.location(location);
        return this;
    };
    
    
    internals.Response.prototype.replacer = function (method) {
    
        this.settings.stringify = this.settings.stringify || {};
        this.settings.stringify.replacer = method;
        return this;
    };
    
    
    internals.Response.prototype.spaces = function (count) {
    
        this.settings.stringify = this.settings.stringify || {};
        this.settings.stringify.space = count;
        return this;
    };
    
    
    internals.Response.prototype.suffix = function (suffix) {
    
        this.settings.stringify = this.settings.stringify || {};
        this.settings.stringify.suffix = suffix;
        return this;
    };
    
    
    internals.Response.prototype.passThrough = function (enabled) {
    
        this.settings.passThrough = (enabled !== false);    // Defaults to true
        return this;
    };
    
    
    internals.Response.prototype.redirect = function (location) {
    
        this.statusCode = 302;
        this.location(location);
        this.temporary = this._temporary;
        this.permanent = this._permanent;
        this.rewritable = this._rewritable;
        return this;
    };
    
    
    internals.Response.prototype._temporary = function (isTemporary) {
    
        this._setTemporary(isTemporary !== false);           // Defaults to true
        return this;
    };
    
    
    internals.Response.prototype._permanent = function (isPermanent) {
    
        this._setTemporary(isPermanent === false);           // Defaults to true
        return this;
    };
    
    
    internals.Response.prototype._rewritable = function (isRewritable) {
    
        this._setRewritable(isRewritable !== false);         // Defaults to true
        return this;
    };
    
    
    internals.Response.prototype._isTemporary = function () {
    
        return this.statusCode === 302 || this.statusCode === 307;
    };
    
    
    internals.Response.prototype._isRewritable = function () {
    
        return this.statusCode === 301 || this.statusCode === 302;
    };
    
    
    internals.Response.prototype._setTemporary = function (isTemporary) {
    
        if (isTemporary) {
            if (this._isRewritable()) {
                this.statusCode = 302;
            }
            else {
                this.statusCode = 307;
            }
        }
        else {
            if (this._isRewritable()) {
                this.statusCode = 301;
            }
            else {
                this.statusCode = 308;
            }
        }
    };
    
    
    internals.Response.prototype._setRewritable = function (isRewritable) {
    
        if (isRewritable) {
            if (this._isTemporary()) {
                this.statusCode = 302;
            }
            else {
                this.statusCode = 301;
            }
        }
        else {
            if (this._isTemporary()) {
                this.statusCode = 307;
            }
            else {
                this.statusCode = 308;
            }
        }
    };
    
    
    internals.Response.prototype.encoding = function (encoding) {
    
        this.settings.encoding = encoding;
        return this;
    };
    
    
    internals.Response.prototype.charset = function (charset) {
    
        this.settings.charset = charset || null;
        return this;
    };
    
    
    internals.Response.prototype.ttl = function (ttl) {
    
        this.settings.ttl = ttl;
        return this;
    };
    
    
    internals.Response.prototype.state = function (name, value, options) {          // options: see Defaults.state
    
        this.request._setState(name, value, options);
        return this;
    };
    
    
    internals.Response.prototype.unstate = function (name, options) {
    
        this.request._clearState(name, options);
        return this;
    };
    
    
    internals.Response.prototype.takeover = function () {
    
        this._takeover = true;
        return this;
    };
    
    
    internals.Response.prototype._prepare = function (data, next) {
    
        var self = this;
    
        this._passThrough();
    
        if (this.variety !== 'promise') {
            return this._processPrepare(data, next);
        }
    
        var onDone = function (source) {
    
            if (source instanceof Error) {
                return next(Boom.wrap(source), data);
            }
    
            if (source instanceof internals.Response) {
                return source._processPrepare(data, next);
            }
    
            self._setSource(source);
            self._passThrough();
            self._processPrepare(data, next);
        };
    
        this.source.then(onDone, onDone);
    };
    
    
    internals.Response.prototype._passThrough = function () {
    
        if (this.variety === 'stream' &&
            this.settings.passThrough) {
    
            if (this.source.statusCode &&
                !this.statusCode) {
    
                this.statusCode = this.source.statusCode;                        // Stream is an HTTP response
            }
    
            if (this.source.headers) {
                var headerKeys = Object.keys(this.source.headers);
    
                if (headerKeys.length) {
                    var localHeaders = this.headers;
                    this.headers = {};
    
                    for (var i = 0, il = headerKeys.length; i < il; ++i) {
                        var key = headerKeys[i];
                        this.header(key.toLowerCase(), Hoek.clone(this.source.headers[key]));     // Clone arrays
                    }
    
                    headerKeys = Object.keys(localHeaders);
                    for (i = 0, il = headerKeys.length; i < il; ++i) {
                        key = headerKeys[i];
                        this.header(key, localHeaders[key], { append: key === 'set-cookie' });
                    }
                }
            }
        }
    
        this.statusCode = this.statusCode || 200;
    };
    
    
    internals.Response.prototype._processPrepare = function (data, next) {
    
        if (!this._processors.prepare) {
            return next(this, data);
        }
    
        this._processors.prepare(this, function (prepared) {
    
            return next(prepared, data);
        });
    };
    
    
    internals.Response.prototype._marshal = function (next) {
    
        var self = this;
    
        if (!this._processors.marshal) {
            return this._streamify(this.source, next);
        }
    
        this._processors.marshal(this, function (err, source) {
    
            if (err) {
                return next(err);
            }
    
            return self._streamify(source, next);
        });
    };
    
    
    internals.Response.prototype._streamify = function (source, next) {
    
        if (source instanceof Stream) {
            if (typeof source._read !== 'function' || typeof source._readableState !== 'object') {
                return next(Boom.badImplementation('Stream must have a streams2 readable interface'));
            }
    
            if (source._readableState.objectMode) {
                return next(Boom.badImplementation('Cannot reply with stream in object mode'));
            }
    
            this._payload = source;
            return next();
        }
    
        var payload = source;
        if (this.variety === 'plain' &&
            source !== null &&
            typeof source !== 'string') {
    
            var options = this.settings.stringify || {};
            var space = options.space || this.request.route.settings.json.space;
            var replacer = options.replacer || this.request.route.settings.json.replacer;
            var suffix = options.suffix || this.request.route.settings.json.suffix || '';
            try {
                payload = JSON.stringify(payload, replacer, space);
            }
            catch (err) {
                return next(err);
            }
    
            if (suffix) {
                payload += suffix;
            }
        }
        else if (this.settings.stringify) {
            return next(Boom.badImplementation('Cannot set formatting options on non object response'));
        }
    
        this._payload = new internals.Payload(payload, this.settings);
        return next();
    };
    
    
    internals.Response.prototype._tap = function () {
    
        return (this.listeners('finish').length || this.listeners('peek').length ? new Peekaboo(this) : null);
    };
    
    
    internals.Response.prototype._close = function () {
    
        if (this._processors.close) {
            this._processors.close(this);
        }
    
        var stream = this._payload || this.source;
        if (stream instanceof Stream) {
            if (stream.close) {
                stream.close();
            }
            else if (stream.destroy) {
                stream.destroy();
            }
            else {
                var read = function () {
    
                    stream.read();
                };
    
                var end = function () {
    
                    stream.removeListener('readable', read);
                    stream.removeListener('error', end);
                    stream.removeListener('end', end);
                };
    
                stream.on('readable', read);
                stream.once('error', end);
                stream.once('end', end);
            }
        }
    };
    
    
    internals.Response.prototype._isPayloadSupported = function () {
    
        return (this.request.method !== 'head' && this.statusCode !== 304 && this.statusCode !== 204);
    };
    
    
    internals.Response.Payload = internals.Payload = function (payload, options) {
    
        Stream.Readable.call(this);
        this._data = payload;
        this._prefix = null;
        this._suffix = null;
        this._sizeOffset = 0;
        this._encoding = options.encoding;
    };
    
    Hoek.inherits(internals.Payload, Stream.Readable);
    
    
    internals.Payload.prototype._read = function (/* size */) {
    
        if (this._prefix) {
            this.push(this._prefix, this._encoding);
        }
    
        if (this._data) {
            this.push(this._data, this._encoding);
        }
    
        if (this._suffix) {
            this.push(this._suffix, this._encoding);
        }
    
        this.push(null);
    };
    
    
    internals.Payload.prototype.size = function () {
    
        if (!this._data) {
            return this._sizeOffset;
        }
    
        return (Buffer.isBuffer(this._data) ? this._data.length : Buffer.byteLength(this._data, this._encoding)) + this._sizeOffset;
    };
    
    
    internals.Payload.prototype.jsonp = function (variable) {
    
        this._sizeOffset += variable.length + 7;
        this._prefix = '/**/' + variable + '(';                 // '/**/' prefix prevents CVE-2014-4671 security exploit
        this._data = Buffer.isBuffer(this._data) ? this._data : this._data.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
        this._suffix = ');';
    };
    
  provide("hapi/lib/response", module.exports);
}(global));

// pakmanager:hapi/lib/auth
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Boom = require('boom');
    var Hoek = require('hoek');
    var Schema =  require('hapi/lib/schema');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports = module.exports = internals.Auth = function (connection) {
    
        this.connection = connection;
        this._schemes = {};
        this._strategies = {};
        this.settings = {
            default: null           // Strategy used as default if route has no auth settings
        };
    };
    
    
    internals.Auth.prototype.scheme = function (name, scheme) {
    
        Hoek.assert(name, 'Authentication scheme must have a name');
        Hoek.assert(!this._schemes[name], 'Authentication scheme name already exists:', name);
        Hoek.assert(typeof scheme === 'function', 'scheme must be a function:', name);
    
        this._schemes[name] = scheme;
    };
    
    
    internals.Auth.prototype.strategy = function (name, scheme /*, mode, options */) {
    
        var hasMode = (typeof arguments[2] === 'string' || typeof arguments[2] === 'boolean');
        var mode = (hasMode ? arguments[2] : false);
        var options = (hasMode ? arguments[3] : arguments[2]) || null;
    
        Hoek.assert(name, 'Authentication strategy must have a name');
        Hoek.assert(name !== 'bypass', 'Cannot use reserved strategy name: bypass');
        Hoek.assert(!this._strategies[name], 'Authentication strategy name already exists');
        Hoek.assert(scheme, 'Authentication strategy', name, 'missing scheme');
        Hoek.assert(this._schemes[scheme], 'Authentication strategy', name, 'uses unknown scheme:', scheme);
    
        var server = this.connection.server._clone([this.connection], '');
        var strategy = this._schemes[scheme](server, options);
    
        Hoek.assert(strategy.authenticate, 'Invalid scheme:', name, 'missing authenticate() method');
        Hoek.assert(typeof strategy.authenticate === 'function', 'Invalid scheme:', name, 'invalid authenticate() method');
        Hoek.assert(!strategy.payload || typeof strategy.payload === 'function', 'Invalid scheme:', name, 'invalid payload() method');
        Hoek.assert(!strategy.response || typeof strategy.response === 'function', 'Invalid scheme:', name, 'invalid response() method');
        strategy.options = strategy.options || {};
        Hoek.assert(strategy.payload || !strategy.options.payload, 'Cannot require payload validation without a payload method');
    
        this._strategies[name] = {
            methods: strategy,
            realm: server.realm
        };
    
        if (mode) {
            this.default({ strategies: [name], mode: mode === true ? 'required' : mode });
        }
    };
    
    
    internals.Auth.prototype.default = function (options) {
    
        Schema.assert('auth', options, 'default strategy');
        Hoek.assert(!this.settings.default, 'Cannot set default strategy more than once');
    
        var settings = Hoek.clone(options);             // options can be reused
    
        if (typeof settings === 'string') {
            settings = {
                strategies: [settings],
                mode: 'required'
            };
        }
        else if (settings.strategy) {
            settings.strategies = [settings.strategy];
            delete settings.strategy;
        }
    
        Hoek.assert(settings.strategies && settings.strategies.length, 'Default authentication strategy missing strategy name');
    
        this.settings.default = settings;
    };
    
    
    internals.Auth.prototype.test = function (name, request, next) {
    
        Hoek.assert(name, 'Missing authentication strategy name');
        var strategy = this._strategies[name];
        Hoek.assert(strategy, 'Unknown authentication strategy:', name);
    
        var transfer = function (response, data) {
    
            return next(response, data && data.credentials);
        };
    
        var reply = request.server._replier.interface(request, strategy.realm, transfer);
        strategy.methods.authenticate(request, reply);
    };
    
    
    internals.Auth.prototype._setupRoute = function (options, path) {
    
        var self = this;
    
        if (!options) {
            return options;         // Preseve the difference between undefined and false
        }
    
        if (typeof options === 'string') {
            options = { strategies: [options] };
        }
        else if (options.strategy) {
            options.strategies = [options.strategy];
            delete options.strategy;
        }
    
        if (!options.strategies) {
            Hoek.assert(this.settings.default, 'Route missing authentication strategy and no default defined:', path);
            options = Hoek.applyToDefaults(this.settings.default, options);
        }
    
        if (options.scope) {
            if (typeof options.scope === 'string') {
                options.scope = [options.scope];
            }
    
            for (var i = 0, il = options.scope.length; i < il; ++i) {
                if (/{([^}]+)}/.test(options.scope[i])) {
                    options.hasScopeParameters = true;
                    break;
                }
            }
        }
    
        Hoek.assert(options.strategies.length, 'Route missing authentication strategy:', path);
    
        options.mode = options.mode || 'required';
        if (options.payload === true) {
            options.payload = 'required';
        }
    
        var hasAuthenticatePayload = false;
        options.strategies.forEach(function (name) {
    
            var strategy = self._strategies[name];
            Hoek.assert(strategy, 'Unknown authentication strategy:', name, 'in path:', path);
            Hoek.assert(strategy.methods.payload || options.payload !== 'required', 'Payload validation can only be required when all strategies support it in path:', path);
            hasAuthenticatePayload = hasAuthenticatePayload || strategy.methods.payload;
            Hoek.assert(!strategy.methods.options.payload || options.payload === undefined || options.payload === 'required', 'Cannot set authentication payload to', options.payload, 'when a strategy requires payload validation', path);
        });
    
        Hoek.assert(!options.payload || hasAuthenticatePayload, 'Payload authentication requires at least one strategy with payload support in path:', path);
    
        return options;
    };
    
    
    internals.Auth.prototype._routeConfig = function (request) {
    
        if (request.route.settings.auth === false) {
            return false;
        }
    
        return request.route.settings.auth || this.settings.default;
    };
    
    
    internals.Auth.authenticate = function (request, next) {
    
        var auth = request.connection.auth;
        return auth._authenticate(request, next);
    };
    
    
    internals.Auth.prototype._authenticate = function (request, next) {
    
        var self = this;
    
        var config = this._routeConfig(request);
        if (!config) {
            return next();
        }
    
        request.auth.mode = config.mode;
    
        var authErrors = [];
        var strategyPos = 0;
    
        var authenticate = function () {
    
            // Find next strategy
    
            if (strategyPos >= config.strategies.length) {
                var err = Boom.unauthorized('Missing authentication', authErrors);
    
                if (config.mode === 'optional' ||
                    config.mode === 'try') {
    
                    request.auth.isAuthenticated = false;
                    request.auth.credentials = null;
                    request.auth.error = err;
                    request._log(['auth', 'unauthenticated']);
                    return next();
                }
    
                return next(err);
            }
    
            var name = config.strategies[strategyPos];
            ++strategyPos;
    
            request._protect.run('auth:request:' + name, validate, function (exit) {
    
                var transfer = function (response, data) {
    
                    exit(response, name, data);
                };
    
                var strategy = self._strategies[name];
                var reply = request.server._replier.interface(request, strategy.realm, transfer);
                strategy.methods.authenticate(request, reply);
            });
        };
    
        var validate = function (err, name, result) {           // err can be Boom, Error, or a valid response object
    
            if (!name) {
                return next(err);
            }
    
            result = result || {};
    
            // Unauthenticated
    
            if (!err &&
                !result.credentials) {
    
                return next(Boom.badImplementation('Authentication response missing both error and credentials'));
            }
    
            if (err) {
                if (err instanceof Error === false) {
                    request._log(['auth', 'unauthenticated', 'response', name], err.statusCode);
                    return next(err);
                }
    
                if (err.isMissing) {
    
                    // Try next name
    
                    request._log(['auth', 'unauthenticated', 'missing', name], err);
                    authErrors.push(err.output.headers['WWW-Authenticate']);
                    return authenticate();
                }
    
                if (config.mode === 'try') {
                    request.auth.isAuthenticated = false;
                    request.auth.strategy = name;
                    request.auth.credentials = result.credentials;
                    request.auth.artifacts = result.artifacts;
                    request.auth.error = err;
                    request._log(['auth', 'unauthenticated', 'try', name], err);
                    return next();
                }
    
                request._log(['auth', 'unauthenticated', 'error', name], err);
                return next(err);
            }
    
            // Authenticated
    
            var credentials = result.credentials;
            request.auth.strategy = name;
            request.auth.credentials = credentials;
            request.auth.artifacts = result.artifacts;
    
            // Check scope
    
            if (config.scope) {
                var scopes = config.scope;
                if (config.hasScopeParameters) {
                    scopes = [];
                    var context = { params: request.params, query: request.query };
                    for (var i = 0, il = config.scope.length; i < il; ++i) {
                        scopes[i] = Hoek.reachTemplate(context, config.scope[i]);
                    }
                }
    
                if (!credentials.scope ||
                    (typeof credentials.scope === 'string' ? scopes.indexOf(credentials.scope) === -1 : !Hoek.intersect(scopes, credentials.scope).length)) {
    
                    request._log(['auth', 'scope', 'error', name], { got: credentials.scope, need: scopes });
                    return next(Boom.forbidden('Insufficient scope, expected any of: ' + scopes));
                }
            }
    
            // Check entity
    
            var entity = config.entity || 'any';
    
            // Entity: 'any'
    
            if (entity === 'any') {
                request._log(['auth', name]);
                request.auth.isAuthenticated = true;
                return next();
            }
    
            // Entity: 'user'
    
            if (entity === 'user') {
                if (!credentials.user) {
                    request._log(['auth', 'entity', 'user', 'error', name]);
                    return next(Boom.forbidden('Application credentials cannot be used on a user endpoint'));
                }
    
                request._log(['auth', name]);
                request.auth.isAuthenticated = true;
                return next();
            }
    
            // Entity: 'app'
    
            if (credentials.user) {
                request._log(['auth', 'entity', 'app', 'error', name]);
                return next(Boom.forbidden('User credentials cannot be used on an application endpoint'));
            }
    
            request._log(['auth', name]);
            request.auth.isAuthenticated = true;
            return next();
        };
    
        // Injection bypass
    
        if (request.auth.credentials) {
            return validate(null, 'bypass', { credentials: request.auth.credentials, artifacts: request.auth.artifacts });
        }
    
        // Authenticate
    
        authenticate();
    };
    
    
    internals.Auth.payload = function (request, next) {
    
        if (!request.auth.isAuthenticated ||
            request.auth.strategy === 'bypass') {
    
            return next();
        }
    
        var auth = request.connection.auth;
        var strategy = auth._strategies[request.auth.strategy];
    
        if (!strategy.methods.payload) {
            return next();
        }
    
        var config = auth._routeConfig(request);
        var setting = config.payload || (strategy.methods.options.payload ? 'required' : false);
        if (!setting) {
            return next();
        }
    
        var finalize = function (response) {
    
            if (response &&
                response.isBoom &&
                response.isMissing) {
    
                return next(setting === 'optional' ? null : Boom.unauthorized('Missing payload authentication'));
            }
    
            return next(response);
        };
    
        request._protect.run('auth:payload:' + request.auth.strategy, finalize, function (exit) {
    
            var reply = request.server._replier.interface(request, strategy.realm, exit);
            strategy.methods.payload(request, reply);
        });
    };
    
    
    internals.Auth.response = function (request, next) {
    
        var auth = request.connection.auth;
        var config = auth._routeConfig(request);
        if (!config ||
            !request.auth.isAuthenticated ||
            request.auth.strategy === 'bypass') {
    
            return next();
        }
    
        var strategy = auth._strategies[request.auth.strategy];
        if (!strategy.methods.response) {
            return next();
        }
    
        request._protect.run('auth:response:' + request.auth.strategy, next, function (exit) {
    
            var reply = request.server._replier.interface(request, strategy.realm, exit);
            strategy.methods.response(request, reply);
        });
    };
    
  provide("hapi/lib/auth", module.exports);
}(global));

// pakmanager:hapi/lib/defaults
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Os = require('os');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.server = {
        debug: {
            request: ['implementation'],
            log: ['implementation']
        },
        load: {
            sampleInterval: 0
        },
        mime: null,                                     // Mimos options
        minimal: false,
        files: {
            etagsCacheMaxSize: 10000                    // Maximum number of etags in the cache
        }
    };
    
    
    exports.connection = {
        router: {
            isCaseSensitive: true,                      // Case-sensitive paths
            stripTrailingSlash: false                   // Remove trailing slash from incoming paths
        },
        routes: {
            cache: {
                statuses: [200]                         // Array of HTTP status codes for which cache-control header is set
            },
            cors: false,                                // CORS headers
            files: {
                relativeTo: '.'                         // Determines what file and directory handlers use to base relative paths off
            },
            json: {
                replacer: null,
                space: null,
                suffix: null
            },
            payload: {
                failAction: 'error',
                maxBytes: 1024 * 1024,
                output: 'data',
                parse: true,
                timeout: 10 * 1000,                     // Determines how long to wait for receiving client payload. Defaults to 10 seconds
                uploads: Os.tmpDir()
            },
            response: {
                options: {}                             // Joi validation options
            },
            security: false,                            // Security headers on responses: false -> null, true -> defaults, {} -> override defaults
            state: {
                parse: true,                            // Parse content of req.headers.cookie
                failAction: 'error'                     // Action on bad cookie - 'error': return 400, 'log': log and continue, 'ignore': continue
            },
            timeout: {
                socket: undefined,                      // Determines how long before closing request socket. Defaults to node (2 minutes)
                server: false                           // Determines how long to wait for server request processing. Disabled by default
            },
            validate: {
                options: {}                             // Joi validation options
            }
        }
    };
    
    
    exports.security = {
        hsts: 15768000,
        xframe: 'deny',
        xss: true,
        noOpen: true,
        noSniff: true
    };
    
    
    exports.cors = {
        origin: ['*'],
        isOriginExposed: true,                          // Return the list of supported origins if incoming origin does not match
        matchOrigin: true,                              // Attempt to match incoming origin against allowed values and return narrow response
        maxAge: 86400,                                  // One day
        headers: [
            'Authorization',
            'Content-Type',
            'If-None-Match'
        ],
        additionalHeaders: [],
        methods: [
            'GET',
            'HEAD',
            'POST',
            'PUT',
            'PATCH',
            'DELETE',
            'OPTIONS'
        ],
        additionalMethods: [],
        exposedHeaders: [
            'WWW-Authenticate',
            'Server-Authorization'
        ],
        additionalExposedHeaders: [],
        credentials: false,
        override: true
    };
    
  provide("hapi/lib/defaults", module.exports);
}(global));

// pakmanager:hapi/lib/handler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Hoek = require('hoek');
    var Items = require('items');
    var Methods =  require('hapi/lib/methods');
    var Response =  require('hapi/lib/response');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.execute = function (request, next) {
    
        var finalize = function (err, result) {
    
            request._setResponse(err || result);
            return next();                              // Must not include an argument
        };
    
        request._protect.run('handler', finalize, function (exit) {
    
            if (request._route._prerequisites) {
                internals.prerequisites(request, Hoek.once(exit));
            }
            else {
                internals.handler(request, exit);
            }
        });
    };
    
    
    internals.prerequisites = function (request, callback) {
    
        Items.serial(request._route._prerequisites, function (set, nextSet) {
    
            Items.parallel(set, function (pre, next) {
    
                pre(request, function (err, result) {
    
                    if (err) {
                        return next(err);
                    }
    
                    if (!result._takeover) {
                        return next();
                    }
    
                    return callback(null, result);
                });
            }, nextSet);
        },
        function (err) {
    
            if (err) {
                callback(err);
            }
            else {
                return internals.handler(request, callback);
            }
        });
    };
    
    
    internals.handler = function (request, callback) {
    
        var timer = new Hoek.Bench();
        var finalize = function (response, data) {
    
            if (response === null) {                            // reply.continue()
                response = Response.wrap(null, request);
                return response._prepare(null, finalize);
            }
    
            // Check for Error result
    
            if (response.isBoom) {
                request._log(['handler', 'error'], { msec: timer.elapsed(), error: response.message, data: response });
                return callback(response);
            }
    
            request._log(['handler'], { msec: timer.elapsed() });
            return callback(null, response);
        };
    
        // Decorate request
    
        var reply = request.server._replier.interface(request, request.route.realm, finalize);
        var bind = request.route.settings.bind;
    
        // Execute handler
    
        request.route.settings.handler.call(bind, request, reply);
    };
    
    
    exports.defaults = function (method, handler, server) {
    
        var defaults = null;
    
        if (typeof handler === 'object') {
            var type = Object.keys(handler)[0];
            var serverHandler = server._handlers[type];
    
            Hoek.assert(serverHandler, 'Unknown handler:', type);
    
            if (serverHandler.defaults) {
                defaults = (typeof serverHandler.defaults === 'function' ? serverHandler.defaults(method) : serverHandler.defaults);
            }
        }
    
        return defaults || {};
    };
    
    
    exports.configure = function (handler, route) {
    
        if (typeof handler === 'object') {
            var type = Object.keys(handler)[0];
            var serverHandler = route.server._handlers[type];
    
            Hoek.assert(serverHandler, 'Unknown handler:', type);
    
            return serverHandler(route.public, handler[type]);
        }
    
        if (typeof handler === 'string') {
            var parsed = internals.fromString('handler', handler, route.server);
            return parsed.method;
        }
    
        return handler;
    };
    
    
    exports.prerequisites = function (config, server) {
    
        if (!config) {
            return null;
        }
    
        /*
            [
                [
                    function (request, reply) { },
                    {
                        method: function (request, reply) { }
                        assign: key1
                    },
                    {
                        method: function (request, reply) { },
                        assign: key2
                    }
                ],
                'user(params.id)'
            ]
        */
    
        var prerequisites = [];
    
        for (var i = 0, il = config.length; i < il; ++i) {
            var pres = [].concat(config[i]);
    
            var set = [];
            for (var p = 0, pl = pres.length; p < pl; ++p) {
                var pre = pres[p];
                if (typeof pre !== 'object') {
                    pre = { method: pre };
                }
    
                var item = {
                    method: pre.method,
                    assign: pre.assign,
                    failAction: pre.failAction || 'error'
                };
    
                if (typeof item.method === 'string') {
                    var parsed = internals.fromString('pre', item.method, server);
                    item.method = parsed.method;
                    item.assign = item.assign || parsed.name;
                }
    
                set.push(internals.pre(item));
            }
    
            prerequisites.push(set);
        }
    
        return prerequisites.length ? prerequisites : null;
    };
    
    
    internals.fromString = function (type, notation, server) {
    
        //                                  1:name            2:(        3:arguments
        var methodParts = notation.match(/^([\w\.]+)(?:\s*)(?:(\()(?:\s*)(\w+(?:\.\w+)*(?:\s*\,\s*\w+(?:\.\w+)*)*)?(?:\s*)\))?$/);
        Hoek.assert(methodParts, 'Invalid server method string notation:', notation);
    
        var name = methodParts[1];
        Hoek.assert(name.match(Methods.methodNameRx), 'Invalid server method name:', name);
    
        var method = server._methods._normalized[name];
        Hoek.assert(method, 'Unknown server method in string notation:', notation);
    
        var result = { name: name };
        var argsNotation = !!methodParts[2];
        var methodArgs = (argsNotation ? (methodParts[3] || '').split(/\s*\,\s*/) : null);
    
        result.method = function (request, reply) {
    
            if (!argsNotation) {
                return method(request, reply);                      // Method is already bound to context
            }
    
            var finalize = function (err, value, cached, report) {
    
                if (report) {
                    request._log([type, 'method', name], report);
                }
    
                return reply(err, value);
            };
    
            var args = [];
            for (var i = 0, il = methodArgs.length; i < il; ++i) {
                var arg = methodArgs[i];
                if (arg) {
                    args.push(Hoek.reach(request, arg));
                }
            }
    
            args.push(finalize);
            method.apply(null, args);
        };
    
        return result;
    };
    
    
    internals.pre = function (pre) {
    
        /*
            {
                method: function (request, next) { }
                assign:     'key'
                failAction: 'error'* | 'log' | 'ignore'
            }
        */
    
        return function (request, next) {
    
            var timer = new Hoek.Bench();
            var finalize = function (response, data) {
    
                if (response === null) {                            // reply.continue()
                    response = Response.wrap(null, request);
                    return response._prepare(null, finalize);
                }
    
                if (response instanceof Error) {
                    if (pre.failAction !== 'ignore') {
                        request._log(['pre', 'error'], { msec: timer.elapsed(), assign: pre.assign, error: response });
                    }
    
                    if (pre.failAction === 'error') {
                        return next(response);
                    }
                }
                else {
                    request._log(['pre'], { msec: timer.elapsed(), assign: pre.assign });
                }
    
                if (pre.assign) {
                    request.pre[pre.assign] = response.source;
                    request.preResponses[pre.assign] = response;
                }
    
                return next(null, response);
            };
    
            // Setup environment
    
            var reply = request.server._replier.interface(request, request.route.realm, finalize);
            var bind = request.route.settings.bind;
    
            // Execute handler
    
            pre.method.call(bind, request, reply);
        };
    };
    
    
    exports.invoke = function (request, event, callback) {
    
        var exts = request.connection._extensions[event];
        if (!exts) {
            return Hoek.nextTick(callback)();
        }
    
        if (event === 'onPreResponse') {
            request._protect.reset();
        }
    
        request._protect.run('ext:' + event, callback, function (exit) {
    
            Items.serial(exts.nodes, function (ext, next) {
    
                var reply = request.server._replier.interface(request, ext.realm, next);
                var bind = (ext.bind || ext.realm.settings.bind);
    
                ext.func.call(bind, request, reply);
            }, exit);
        });
    };
    
  provide("hapi/lib/handler", module.exports);
}(global));

// pakmanager:hapi/lib/validation
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Boom = require('boom');
    var Hoek = require('hoek');
    var Joi = require('joi');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.query = function (request, next) {
    
        return internals.input('query', request, next);
    };
    
    
    exports.payload = function (request, next) {
    
        if (request.method === 'get' ||
            request.method === 'head') {                // When route.method is '*'
    
            return next();
        }
    
        return internals.input('payload', request, next);
    };
    
    
    exports.params = function (request, next) {
    
        return internals.input('params', request, next);
    };
    
    
    exports.headers = function (request, next) {
    
        return internals.input('headers', request, next);
    };
    
    
    internals.input = function (source, request, next) {
    
        if (typeof request[source] !== 'object') {
            return next(Boom.unsupportedMediaType(source + ' must represent an object'));
        }
    
        var postValidate = function (err, value) {
    
            request.orig[source] = request[source];
            if (value !== undefined) {
                request[source] = value;
            }
    
            if (!err) {
                return next();
            }
    
            if (err.isDeveloperError) {
                return next(err);
            }
    
            // failAction: 'error', 'log', 'ignore', function (source, err, next)
    
            if (request.route.settings.validate.failAction === 'ignore') {
                return next();
            }
    
            // Prepare error
    
            var error = Boom.badRequest(err.message, err);
            error.output.payload.validation = { source: source, keys: [] };
            if (err.details) {
                for (var i = 0, il = err.details.length; i < il; ++i) {
                    error.output.payload.validation.keys.push(Hoek.escapeHtml(err.details[i].path));
                }
            }
    
            if (request.route.settings.validate.errorFields) {
                var fields = Object.keys(request.route.settings.validate.errorFields);
                for (var f = 0, fl = fields.length; f < fl; ++f) {
                    var field = fields[f];
                    error.output.payload[field] = request.route.settings.validate.errorFields[field];
                }
            }
    
            request._log(['validation', 'error', source], error);
    
            // Log only
    
            if (request.route.settings.validate.failAction === 'log') {
                return next();
            }
    
            // Return error
    
            if (typeof request.route.settings.validate.failAction !== 'function') {
                return next(error);
            }
    
            // Custom handler
    
            request._protect.run('validate:input:failAction', next, function (exit) {
    
                var reply = request.server._replier.interface(request, request.route.realm, exit);
                request.route.settings.validate.failAction(request, reply, source, error);
            });
        };
    
        var localOptions = {
            context: {
                headers: request.headers,
                params: request.params,
                query: request.query,
                payload: request.payload,
                auth: {
                    isAuthenticated: request.auth.isAuthenticated,
                    credentials: request.auth.credentials
                }
            }
        };
    
        delete localOptions.context[source];
        Hoek.merge(localOptions, request.route.settings.validate.options);
    
        var schema = request.route.settings.validate[source];
        if (typeof schema !== 'function') {
            return Joi.validate(request[source], schema, localOptions, postValidate);
        }
    
        request._protect.run('validate:input', postValidate, function (exit) {
    
            return schema(request[source], localOptions, exit);
        });
    };
    
    
    exports.response = function (request, next) {
    
        if (request.route.settings.response.sample) {
            var currentSample = Math.ceil((Math.random() * 100));
            if (currentSample > request.route.settings.response.sample) {
                return next();
            }
        }
    
        var response = request.response;
        var statusCode = response.isBoom ? response.output.statusCode : response.statusCode;
        var source = response.isBoom ? response.output.payload : response.source;
    
        var statusSchema = request.route.settings.response.status[statusCode];
        if (statusCode >= 400 &&
            !statusSchema) {
    
            return next();          // Do not validate errors by default
        }
    
        var schema = statusSchema || request.route.settings.response.schema;
        if (schema === null) {
            return next();          // No rules
        }
    
        if ((!response.isBoom && request.response.variety !== 'plain') ||
            typeof source !== 'object') {
    
            return next(Boom.badImplementation('Cannot validate non-object response'));
        }
    
        var postValidate = function (err, value) {
    
            if (!err) {
                if (value !== undefined &&
                    request.route.settings.response.modify) {
    
                    if (response.isBoom) {
                        response.output.payload = value;
                    }
                    else {
                        response.source = value;
                    }
                }
    
                return next();
            }
    
            // failAction: 'error', 'log'
    
            if (request.route.settings.response.failAction === 'log') {
                request._log(['validation', 'response', 'error'], err.message);
                return next();
            }
    
            return next(Boom.badImplementation(err.message));
        };
    
        var localOptions = {
            context: {
                headers: request.headers,
                params: request.params,
                query: request.query,
                payload: request.payload,
                auth: {
                    isAuthenticated: request.auth.isAuthenticated,
                    credentials: request.auth.credentials
                }
            }
        };
    
        Hoek.merge(localOptions, request.route.settings.response.options);
    
        if (typeof schema !== 'function') {
            return Joi.validate(source, schema, localOptions, postValidate);
        }
    
        request._protect.run('validate:response', postValidate, function (exit) {
    
            return schema(source, localOptions, exit);
        });
    };
    
  provide("hapi/lib/validation", module.exports);
}(global));

// pakmanager:hapi/lib/route
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Boom = require('boom');
    var Catbox = require('catbox');
    var Hoek = require('hoek');
    var Joi = require('joi');
    var Subtext = require('subtext');
    var Auth =  require('hapi/lib/auth');
    var Defaults =  require('hapi/lib/defaults');
    var Handler =  require('hapi/lib/handler');
    var Validation =  require('hapi/lib/validation');
    var Schema =  require('hapi/lib/schema');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports = module.exports = internals.Route = function (options, connection, realm) {
    
        // Apply plugin environment (before schema validation)
    
        if (realm.modifiers.route.vhost ||
            realm.modifiers.route.prefix) {
    
            options = Hoek.cloneWithShallow(options, ['config']);       // config is left unchanged
            options.path = (realm.modifiers.route.prefix ? realm.modifiers.route.prefix + (options.path !== '/' ? options.path : '') : options.path);
            options.vhost = realm.modifiers.route.vhost || options.vhost;
        }
    
        // Setup and validate route configuration
    
        Hoek.assert(options.path, 'Route missing path');
        Hoek.assert(options.handler || (options.config && options.config.handler), 'Missing or undefined handler:', options.method, options.path);
        Hoek.assert(!!options.handler ^ !!(options.config && options.config.handler), 'Handler must only appear once:', options.method, options.path);            // XOR
        Hoek.assert(options.path === '/' || options.path[options.path.length - 1] !== '/' || !connection.settings.router.stripTrailingSlash, 'Path cannot end with a trailing slash when connection configured to strip:', options.method, options.path);
        Hoek.assert(/^[a-zA-Z0-9!#\$%&'\*\+\-\.^_`\|~]+$/.test(options.method), 'Invalid method name:', options.method, options.path);
    
        Schema.assert('route', options, options.path);
    
        var handler = options.handler || options.config.handler;
        var method = options.method.toLowerCase();
        Hoek.assert(method !== 'head', 'Method name not allowed:', options.method, options.path);
    
        // Apply settings in order: {connection} <- {handler} <- {realm} <- {route}
    
        var handlerDefaults = Handler.defaults(method, handler, connection.server);
        var base = Hoek.applyToDefaultsWithShallow(connection.settings.routes, handlerDefaults, ['bind']);
        base = Hoek.applyToDefaultsWithShallow(base, realm.settings, ['bind']);
        this.settings = Hoek.applyToDefaultsWithShallow(base, options.config || {}, ['bind']);
        this.settings.handler = handler;
    
        Schema.assert('routeConfig', this.settings, options.path);
    
        var socketTimeout = (this.settings.timeout.socket === undefined ? 2 * 60 * 1000 : this.settings.timeout.socket);
        Hoek.assert(!this.settings.timeout.server || !socketTimeout || this.settings.timeout.server < socketTimeout, 'Server timeout must be shorter than socket timeout:', options.path);
        Hoek.assert(!this.settings.payload.timeout || !socketTimeout || this.settings.payload.timeout < socketTimeout, 'Payload timeout must be shorter than socket timeout:', options.path);
    
        this.connection = connection;
        this.server = connection.server;
        this.path = options.path;
        this.method = method;
    
        this.public = {
            method: this.method,
            path: this.path,
            vhost: this.vhost,
            realm: realm,
            settings: this.settings
        };
    
        this.settings.vhost = options.vhost;
        this.settings.plugins = this.settings.plugins || {};            // Route-specific plugins settings, namespaced using plugin name
        this.settings.app = this.settings.app || {};                    // Route-specific application settings
    
        // Path parsing
    
        this._analysis = this.connection._router.analyze(this.path);
        this.params = this._analysis.params;
        this.fingerprint = this._analysis.fingerprint;
    
        // Validation
    
        var validation = this.settings.validate;
        if (this.method === 'get') {
    
            // Assert on config, not on merged settings
    
            Hoek.assert(!options.config || !options.config.payload, 'Cannot set payload settings on HEAD or GET request:', options.path);
            Hoek.assert(!options.config || !options.config.validate || !options.config.validate.payload, 'Cannot validate HEAD or GET requests:', options.path);
    
            validation.payload = null;
        }
    
        ['headers', 'params', 'query', 'payload'].forEach(function (type) {
    
            validation[type] = internals.compileRule(validation[type]);
        });
    
        if (this.settings.response.schema !== undefined ||
            this.settings.response.status) {
    
            var rule = this.settings.response.schema;
            this.settings.response.status = this.settings.response.status || {};
            var statuses = Object.keys(this.settings.response.status);
    
            if ((rule === true && !statuses.length) ||
                this.settings.response.sample === 0) {
    
                this.settings.response = null;
            }
            else {
                this.settings.response.schema = internals.compileRule(rule);
                for (var i = 0, il = statuses.length; i < il; ++i) {
                    var code = statuses[i];
                    this.settings.response.status[code] = internals.compileRule(this.settings.response.status[code]);
                }
            }
        }
        else {
            this.settings.response = null;
        }
    
        // Payload parsing
    
        if (this.method === 'get') {
    
            this.settings.payload = null;
        }
        else {
            if (this.settings.payload.allow) {
                this.settings.payload.allow = [].concat(this.settings.payload.allow);
            }
        }
    
        Hoek.assert(!this.settings.validate.payload || this.settings.payload.parse, 'Route payload must be set to \'parse\' when payload validation enabled:', options.method, options.path);
        Hoek.assert(!this.settings.jsonp || typeof this.settings.jsonp === 'string', 'Bad route JSONP parameter name:', options.path);
    
        // Authentication configuration
    
        this.settings.auth = this.connection.auth._setupRoute(this.settings.auth, options.path);
    
        // Cache
    
        if (this.method === 'get' &&
            (this.settings.cache.expiresIn || this.settings.cache.expiresAt)) {
    
            this.settings.cache._statuses = Hoek.mapToObject(this.settings.cache.statuses);
            this._cache = new Catbox.Policy({ expiresIn: this.settings.cache.expiresIn, expiresAt: this.settings.cache.expiresAt });
        }
    
        // CORS
    
        if (this.settings.cors) {
            this.settings.cors = Hoek.applyToDefaults(Defaults.cors, this.settings.cors);
    
            var cors = this.settings.cors;
            cors._headers = cors.headers.concat(cors.additionalHeaders).join(', ');
            cors._methods = cors.methods.concat(cors.additionalMethods).join(', ');
            cors._exposedHeaders = cors.exposedHeaders.concat(cors.additionalExposedHeaders).join(', ');
    
            if (cors.origin.length) {
                cors._origin = {
                    any: false,
                    qualified: [],
                    qualifiedString: '',
                    wildcards: []
                };
    
                if (cors.origin.indexOf('*') !== -1) {
                    Hoek.assert(cors.origin.length === 1, 'Cannot specify cors.origin * together with other values');
                    cors._origin.any = true;
                }
                else {
                    for (var c = 0, cl = cors.origin.length; c < cl; ++c) {
                        var origin = cors.origin[c];
                        if (origin.indexOf('*') !== -1) {
                            cors._origin.wildcards.push(new RegExp('^' + Hoek.escapeRegex(origin).replace(/\\\*/g, '.*').replace(/\\\?/g, '.') + '$'));
                        }
                        else {
                            cors._origin.qualified.push(origin);
                        }
                    }
    
                    Hoek.assert(cors.matchOrigin || !cors._origin.wildcards.length, 'Cannot include wildcard origin values with matchOrigin disabled');
                    cors._origin.qualifiedString = cors._origin.qualified.join(' ');
                }
            }
        }
    
        // Security
    
        if (this.settings.security) {
            this.settings.security = Hoek.applyToDefaults(Defaults.security, this.settings.security);
    
            var security = this.settings.security;
            if (security.hsts) {
                if (security.hsts === true) {
                    security._hsts = 'max-age=15768000';
                }
                else if (typeof security.hsts === 'number') {
                    security._hsts = 'max-age=' + security.hsts;
                }
                else {
                    security._hsts = 'max-age=' + (security.hsts.maxAge || 15768000);
                    if (security.hsts.includeSubdomains) {
                        security._hsts += '; includeSubdomains';
                    }
                }
            }
    
            if (security.xframe) {
                if (security.xframe === true) {
                    security._xframe = 'DENY';
                }
                else if (typeof security.xframe === 'string') {
                    security._xframe = security.xframe.toUpperCase();
                }
                else if (security.xframe.rule === 'allow-from') {
                    if (!security.xframe.source) {
                        security._xframe = 'SAMEORIGIN';
                    }
                    else {
                        security._xframe = 'ALLOW-FROM ' + security.xframe.source;
                    }
                }
                else {
                    security._xframe = security.xframe.rule.toUpperCase();
                }
            }
        }
    
        // Handler
    
        this.settings.handler = Handler.configure(this.settings.handler, this);
        this._prerequisites = Handler.prerequisites(this.settings.pre, this.server);
    
        // Route lifecycle
    
        this._cycle = this.lifecycle();
    };
    
    
    internals.compileRule = function (rule) {
    
        // null, undefined, true - anything allowed
        // false - nothing allowed
        // {...} - ... allowed
    
        return (rule === false ? Joi.object({}).allow(null)
                               : typeof rule === 'function' ? rule
                                                            : !rule || rule === true ? null                     // false tested earlier
                                                                                     : Joi.compile(rule));
    };
    
    
    internals.Route.prototype.lifecycle = function () {
    
        var cycle = [];
    
        // 'onRequest'
    
        if (this.settings.jsonp) {
            cycle.push(internals.parseJSONP);
        }
    
        if (this.settings.state.parse) {
            cycle.push(internals.state);
        }
    
        cycle.push('onPreAuth');
    
        var authenticate = (this.settings.auth !== false);                          // Anything other than 'false' can still require authentication
        if (authenticate) {
            cycle.push(Auth.authenticate);
        }
    
        if (this.method !== 'get') {
    
            cycle.push(internals.payload);
    
            if (authenticate) {
                cycle.push(Auth.payload);
            }
        }
    
        cycle.push('onPostAuth');
    
        if (this.settings.validate.headers) {
            cycle.push(Validation.headers);
        }
    
        if (this.settings.validate.params) {
            cycle.push(Validation.params);
        }
    
        if (this.settings.jsonp) {
            cycle.push(internals.cleanupJSONP);
        }
    
        if (this.settings.validate.query) {
            cycle.push(Validation.query);
        }
    
        if (this.settings.validate.payload) {
            cycle.push(Validation.payload);
        }
    
        cycle.push('onPreHandler');
        cycle.push(Handler.execute);                                     // Must not call next() with an Error
        cycle.push('onPostHandler');                                     // An error from here on will override any result set in handler()
    
        if (this.settings.response) {
            cycle.push(Validation.response);
        }
    
        // 'onPreResponse'
    
        return cycle;
    };
    
    
    internals.state = function (request, next) {
    
        request.state = {};
    
        var req = request.raw.req;
        var cookies = req.headers.cookie;
        if (!cookies) {
            return next();
        }
    
        request.connection.states.parse(cookies, function (err, state, failed) {
    
            request.state = state;
    
            // Clear cookies
    
            for (var i = 0, il = failed.length; i < il; ++i) {
                var item = failed[i];
    
                if (item.settings.clearInvalid) {
                    request._clearState(item.name);
                }
            }
    
            // failAction: 'error', 'log', 'ignore'
    
            if (!err ||
                request.route.settings.state.failAction === 'ignore') {
    
                return next();
            }
    
            request._log(['state', 'error'], { header: cookies, errors: err.data });
            return next(request.route.settings.state.failAction === 'error' ? err : null);
        });
    };
    
    
    internals.payload = function (request, next) {
    
        if (request.method === 'get' ||
            request.method === 'head') {            // When route.method is '*'
    
            return next();
        }
    
        var onParsed = function (err, parsed) {
    
            request.mime = parsed.mime;
            request.payload = parsed.payload || null;
    
            if (!err) {
                return next();
            }
    
            var failAction = request.route.settings.payload.failAction;         // failAction: 'error', 'log', 'ignore'
            if (failAction !== 'ignore') {
                request._log(['payload', 'error'], err);
            }
    
            if (failAction === 'error') {
                return next(err);
            }
    
            return next();
        };
    
        Subtext.parse(request.raw.req, request._tap(), request.route.settings.payload, function (err, parsed) {
    
            if (!err ||
                !request._isPayloadPending) {
    
                request._isPayloadPending = false;
                return onParsed(err, parsed);
            }
    
            // Flush out any pending request payload not consumed due to errors
    
            var stream = request.raw.req;
    
            var read = function () {
    
                stream.read();
            };
    
            var end = function () {
    
                stream.removeListener('readable', read);
                stream.removeListener('error', end);
                stream.removeListener('end', end);
    
                request._isPayloadPending = false;
                return onParsed(err, parsed);
            };
    
            stream.on('readable', read);
            stream.once('error', end);
            stream.once('end', end);
        });
    };
    
    
    internals.parseJSONP = function (request, next) {
    
        var jsonp = request.query[request.route.settings.jsonp];
        if (jsonp) {
            if (/^[\w\$\[\]\.]+$/.test(jsonp) === false) {
                return next(Boom.badRequest('Invalid JSONP parameter value'));
            }
    
            request.jsonp = jsonp;
        }
    
        return next();
    };
    
    
    internals.cleanupJSONP = function (request, next) {
    
        if (request.jsonp) {
            delete request.query[request.route.settings.jsonp];
        }
    
        return next();
    };
    
  provide("hapi/lib/route", module.exports);
}(global));

// pakmanager:hapi/lib/connection
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Events = require('events');
    var Http = require('http');
    var Https = require('https');
    var Os = require('os');
    var Path = require('path');
    var Boom = require('boom');
    var Call = require('call');
    var Hoek = require('hoek');
    var Shot = require('shot');
    var Statehood = require('statehood');
    var Topo = require('topo');
    var Auth =  require('hapi/lib/auth');
    var Route =  require('hapi/lib/route');
    
    
    // Declare internals
    
    var internals = {
        counter: {
            min: 10000,
            max: 99999
        }
    };
    
    
    exports = module.exports = internals.Connection = function (server, options) {
    
        var now = Date.now();
    
        Events.EventEmitter.call(this);
    
        this.settings = options;                                                        // options cloned in server.connection()
        this.server = server;
    
        // Normalize settings
    
        this.settings.labels = Hoek.unique(this.settings.labels || []);                 // Remove duplicates
        if (this.settings.port === undefined) {
            this.settings.port = 0;
        }
    
        this.type = (typeof this.settings.port === 'string' ? 'socket' : 'tcp');
        if (this.type === 'socket') {
            this.settings.port = (this.settings.port.indexOf('/') !== -1 ? Path.resolve(this.settings.port) : this.settings.port.toLowerCase());
        }
    
        if (this.settings.autoListen === undefined) {
            this.settings.autoListen = true;
        }
    
        Hoek.assert(this.settings.autoListen || !this.settings.port, 'Cannot specify port when autoListen is false');
        Hoek.assert(this.settings.autoListen || !this.settings.address, 'Cannot specify address when autoListen is false');
    
        this.settings.query = this.settings.query || {};
    
        // Connection facilities
    
        this._started = false;
        this._connections = {};
        this._onConnection = null;          // Used to remove event listener on stop
        this._registrations = {};           // Tracks plugin for dependency validation
    
        this._extensions = {
            onRequest: null,            // New request, before handing over to the router (allows changes to the request method, url, etc.)
            onPreAuth: null,            // After cookie parse and before authentication (skipped if state error)
            onPostAuth: null,           // After authentication (and payload processing) and before validation (skipped if auth or payload error)
            onPreHandler: null,         // After validation and body parsing, before route handler (skipped if auth or validation error)
            onPostHandler: null,        // After route handler returns, before sending response (skipped if onPreHandler not called)
            onPreResponse: null         // Before response is sent (always called)
        };
    
        this._requestCounter = { value: internals.counter.min, min: internals.counter.min, max: internals.counter.max };
        this._load = server._heavy.policy(this.settings.load);
        this.states = new Statehood.Definitions(this.settings.state);
        this.auth = new Auth(this);
        this._router = new Call.Router(this.settings.router);
        this._defaultRoutes();
    
        this.plugins = {};                  // Registered plugin APIs by plugin name
        this.app = {};                      // Place for application-specific state without conflicts with hapi, should not be used by plugins
    
        // Create listener
    
        this.listener = this.settings.listener || (this.settings.tls ? Https.createServer(this.settings.tls) : Http.createServer());
        this.listener.on('request', this._dispatch());
        this._init();
    
        // Connection information
    
        this.info = {
            created: now,
            started: 0,
            host: this.settings.host || Os.hostname() || 'localhost',
            port: this.settings.port,
            protocol: this.type === 'tcp' ? (this.settings.tls ? 'https' : 'http') : this.type,
            id: Os.hostname() + ':' + process.pid + ':' + now.toString(36)
        };
    
        this.info.uri = (this.settings.uri || (this.info.protocol + ':' + (this.type === 'tcp' ? '//' + this.info.host + (this.info.port ? ':' + this.info.port : '') : this.info.port)));
    };
    
    Hoek.inherits(internals.Connection, Events.EventEmitter);
    
    
    internals.Connection.prototype._init = function () {
    
        var self = this;
    
        // Setup listener
    
        this.listener.once('listening', function () {
    
            // Update the address, port, and uri with active values
    
            if (self.type === 'tcp') {
                var address = self.listener.address();
                self.info.address = address.address;
                self.info.port = address.port;
                self.info.uri = (self.settings.uri || (self.info.protocol + '://' + self.info.host + ':' + self.info.port));
            }
    
            self._onConnection = function (connection) {
    
                var key = connection.remoteAddress + ':' + connection.remotePort;
                self._connections[key] = connection;
    
                connection.once('close', function () {
    
                    delete self._connections[key];
                });
            };
    
            self.listener.on('connection', self._onConnection);
        });
    };
    
    
    internals.Connection.prototype._start = function (callback) {
    
        var self = this;
    
        if (this._started) {
            return process.nextTick(callback);
        }
    
        this._started = true;
        this.info.started = Date.now();
    
        if (!this.settings.autoListen) {
            return process.nextTick(callback);
        }
    
        var onError = function (err) {
    
            self._started = false;
            return callback(err);
        };
    
        this.listener.once('error', onError);
    
        var finalize = function () {
    
            self.listener.removeListener('error', onError);
            callback();
        };
    
        if (this.type !== 'tcp') {
            this.listener.listen(this.settings.port, finalize);
        }
        else {
            var address = this.settings.address || this.settings.host || '0.0.0.0';
            this.listener.listen(this.settings.port, address, finalize);
        }
    };
    
    
    internals.Connection.prototype._stop = function (options, callback) {
    
        var self = this;
    
        options = options || {};
        options.timeout = options.timeout || 5000;                                              // Default timeout to 5 seconds
    
        if (!this._started) {
            return process.nextTick(callback);
        }
    
        this._started = false;
        this.info.started = 0;
    
        var timeoutId = setTimeout(function () {
    
            Object.keys(self._connections).forEach(function (key) {
    
                self._connections[key].destroy();
            });
    
    
            self._connections = {};
        }, options.timeout);
    
        this.listener.close(function () {
    
            self.listener.removeListener('connection', self._onConnection);
            clearTimeout(timeoutId);
    
            self._init();
            return callback();
        });
    };
    
    
    internals.Connection.prototype._dispatch = function (options) {
    
        var self = this;
    
        options = options || {};
    
        return function (req, res) {
    
            if (!self._started &&
                req.connection) {
    
                return req.connection.end();
            }
    
            // Create request
    
            var request = self.server._requestor.request(self, req, res, options);
    
            // Check load
    
            var overload = self._load.check();
            if (overload) {
                self.server._log(['load'], self.server.load);
                request._reply(overload);
            }
            else {
    
                // Execute request lifecycle
    
                request._protect.domain.run(function () {
    
                    request._execute();
                });
            }
        };
    };
    
    
    internals.Connection.prototype.inject = function (options, callback) {
    
        var settings = options;
        if (settings.credentials ||
            settings.artifacts) {
    
            settings = Hoek.shallow(options);               // options can be reused
            delete settings.credentials;
            delete settings.artifacts;
        }
    
        var needle = this._dispatch({
            credentials: options.credentials,
            artifacts: options.artifacts
        });
    
        Shot.inject(needle, settings, function (res) {
    
            if (res.raw.res._hapi) {
                res.result = res.raw.res._hapi.result;
                res.request = res.raw.res._hapi.request;
                delete res.raw.res._hapi;
            }
    
            if (res.result === undefined) {
                res.result = res.payload;
            }
    
            return callback(res);
        });
    };
    
    
    internals.Connection.prototype.table = function (host) {
    
        return this._router.table(host);
    };
    
    
    internals.Connection.prototype.lookup = function (id) {
    
        Hoek.assert(id && typeof id === 'string', 'Invalid route id:', id);
    
        var record = this._router.ids[id];
        if (!record) {
            return null;
        }
    
        return record.route.public;
    };
    
    
    internals.Connection.prototype.match = function (method, path, host) {
    
        Hoek.assert(method && typeof method === 'string', 'Invalid method:', method);
        Hoek.assert(path && typeof path === 'string' && path[0] === '/', 'Invalid path:', path);
        Hoek.assert(!host || typeof host === 'string', 'Invalid host:', host);
    
        var match = this._router.route(method.toLowerCase(), path, host);
        if (match.route.method === 'notfound') {
            return null;
        }
    
        Hoek.assert(match.route.method !== 'badrequest', 'Invalid path:', path);
    
        return match.route.public;
    };
    
    
    internals.Connection.prototype._ext = function (event, func, options, realm) {
    
        options = options || {};
    
        Hoek.assert(this._extensions[event] !== undefined, 'Unknown event type', event);
    
        var settings = {
            before: options.before,
            after: options.after,
            group: realm.plugin
        };
    
        var nodes = [];
        ([].concat(func)).forEach(function (fn, i) {
    
            var node = {
                func: fn,               // function (request, next) { next(); }
                realm: realm,
                bind: options.bind
            };
    
            nodes.push(node);
        });
    
        this._extensions[event] = this._extensions[event] || new Topo();
        this._extensions[event].add(nodes, settings);
    };
    
    
    internals.Connection.prototype._route = function (configs, realm) {
    
        configs = [].concat(configs);
        for (var i = 0, il = configs.length; i < il; ++i) {
            var config = configs[i];
    
            if (Array.isArray(config.method)) {
                for (var m = 0, ml = config.method.length; m < ml; ++m) {
                    var method = config.method[m];
    
                    var settings = Hoek.shallow(config);
                    settings.method = method;
                    this._addRoute(settings, realm);
                }
            }
            else {
                this._addRoute(config, realm);
            }
        }
    };
    
    
    internals.Connection.prototype._addRoute = function (config, realm) {
    
        var route = new Route(config, this, realm);                // Do no use config beyond this point, use route members
        var vhosts = [].concat(route.settings.vhost || '*');
    
        for (var i = 0, il = vhosts.length; i < il; ++i) {
            var vhost = vhosts[i];
            var record = this._router.add({ method: route.method, path: route.path, vhost: vhost, analysis: route._analysis, id: route.settings.id }, route);
            route.fingerprint = record.fingerprint;
            route.params = record.params;
        }
    };
    
    
    internals.Connection.prototype._defaultRoutes = function () {
    
        this._router.special('notFound', new Route({
            method: 'notFound',
            path: '/{p*}',
            config: {
                auth: false,                            // Override any defaults
                handler: function (request, reply) {
    
                    return reply(Boom.notFound());
                }
            }
        }, this, this.server.realm));
    
        this._router.special('badRequest', new Route({
            method: 'badRequest',
            path: '/{p*}',
            config: {
                auth: false,                            // Override any defaults
                handler: function (request, reply) {
    
                    return reply(Boom.badRequest());
                }
            }
        }, this, this.server.realm));
    
        if (this.settings.routes.cors) {
            this._router.special('options', new Route({
                path: '/{p*}',
                method: 'options',
                config: {
                    auth: false,                         // Override any defaults
                    cors: this.settings.routes.cors,
                    handler: function (request, reply) {
    
                        return reply();
                    }
                }
            }, this, this.server.realm));
        }
    };
    
  provide("hapi/lib/connection", module.exports);
}(global));

// pakmanager:hapi/lib/protect
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Domain = require('domain');
    var Boom = require('boom');
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports = module.exports = internals.Protect = function (request) {
    
        var self = this;
    
        this._error = null;
        this._at = '';
        this.logger = request;                          // Replaced with server when request completes
    
        this.domain = Domain.create();
        this.domain.on('error', function (err) {
    
            var handler = self._error;
            if (handler) {
                self._error = null;
                return handler(err);
            }
    
            self.logger._log(['internal', 'implementation', 'error'], err);
        });
    };
    
    
    internals.Protect.prototype.run = function (at, next, enter) {          // enter: function (exit)
    
        var self = this;
    
        Hoek.assert(!this._error, 'Invalid nested use of protect.run() during: ' + this._at + ' while trying: ' + at);
    
        var finish = function (arg0, arg1, arg2) {
    
            self._error = null;
            self._at = '';
            return next(arg0, arg1, arg2);
        };
    
        finish = Hoek.once(finish);
    
        this._at = at;
        this._error = function (err) {
    
            return finish(Boom.badImplementation('Uncaught error', err));
        };
    
        enter(finish);
    };
    
    
    internals.Protect.prototype.reset = function () {
    
        this._error = null;
        this._at = '';
    };
    
  provide("hapi/lib/protect", module.exports);
}(global));

// pakmanager:hapi/lib/transmit
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Http = require('http');
    var Stream = require('stream');
    var Zlib = require('zlib');
    var Ammo = require('ammo');
    var Boom = require('boom');
    var Hoek = require('hoek');
    var Items = require('items');
    var Shot = require('shot');
    var Auth =  require('hapi/lib/auth');
    var Response =  require('hapi/lib/response');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.send = function (request, callback) {
    
        var response = request.response;
        if (response.isBoom) {
            return internals.fail(request, response, callback);
        }
    
        internals.marshal(request, function (err) {
    
            if (err) {
                request._setResponse(err);
                return internals.fail(request, err, callback);
            }
    
            return internals.transmit(response, callback);
        });
    };
    
    
    internals.marshal = function (request, next) {
    
        var response = request.response;
    
        internals.cors(response);
        internals.content(response);
        internals.security(response);
    
        if (response.statusCode !== 304 &&
            (request.method === 'get' || request.method === 'head')) {
    
            if (response.headers.etag &&
                request.headers['if-none-match']) {
    
                // Strong verifier
    
                var ifNoneMatch = request.headers['if-none-match'].split(/\s*,\s*/);
                for (var i = 0, il = ifNoneMatch.length; i < il; ++i) {
                    var etag = ifNoneMatch[i];
                    if (etag === response.headers.etag) {
                        response.code(304);
                        break;
                    }
                    else if (response.settings.varyEtag) {
                        var etagBase = response.headers.etag.slice(0, -1);
                        if (etag === etagBase + '-gzip"' ||
                            etag === etagBase + '-deflate"') {
    
                            response.headers.etag = etag;
                            response.code(304);
                            break;
                        }
                    }
                }
            }
            else {
                var ifModifiedSinceHeader = request.headers['if-modified-since'];
                var lastModifiedHeader = response.headers['last-modified'];
    
                if (ifModifiedSinceHeader &&
                    lastModifiedHeader) {
    
                    // Weak verifier
    
                    var ifModifiedSince = Date.parse(ifModifiedSinceHeader);
                    var lastModified = Date.parse(lastModifiedHeader);
    
                    if (ifModifiedSince &&
                        lastModified &&
                        ifModifiedSince >= lastModified) {
    
                        response.code(304);
                    }
                }
            }
        }
    
        internals.state(response, function (err) {
    
            if (err) {
                request._log(['state', 'response', 'error'], err);
                request._states = {};                                           // Clear broken state
                return next(err);
            }
    
            internals.cache(response);
    
            if (!response._isPayloadSupported()) {
    
                // Close unused file streams
    
                response._close();
    
                // Set empty stream
    
                response._payload = new internals.Empty();
                if (request.method !== 'head') {
                    delete response.headers['content-length'];
                }
    
                return Auth.response(request, next);               // Must be last in case requires access to headers
            }
    
            response._marshal(function (err) {
    
                if (err) {
                    return next(Boom.wrap(err));
                }
    
                if (request.jsonp &&
                    response._payload.jsonp) {
    
                    response._header('content-type', 'text/javascript' + (response.settings.charset ? '; charset=' + response.settings.charset : ''));
                    response._header('x-content-type-options', 'nosniff');
                    response._payload.jsonp(request.jsonp);
                }
    
                if (response._payload.size &&
                    typeof response._payload.size === 'function') {
    
                    response._header('content-length', response._payload.size(), { override: false });
                }
    
                return Auth.response(request, next);               // Must be last in case requires access to headers
            });
        });
    };
    
    
    internals.fail = function (request, boom, callback) {
    
        var error = boom.output;
        var response = new Response(error.payload, request);
        response._error = boom;
        response.code(error.statusCode);
        response.headers = error.headers;
        request.response = response;                            // Not using request._setResponse() to avoid double log
    
        internals.marshal(request, function (err) {
    
            if (err) {
    
                // Failed to marshal an error - replace with minimal representation of original error
    
                var minimal = {
                    statusCode: error.statusCode,
                    error: Http.STATUS_CODES[error.statusCode],
                    message: boom.message
                };
    
                response._payload = new Response.Payload(JSON.stringify(minimal), {});
            }
    
            return internals.transmit(response, callback);
        });
    };
    
    
    internals.transmit = function (response, callback) {
    
        // Setup source
    
        var request = response.request;
        var source = response._payload;
        var length = response.headers['content-length'] ? parseInt(response.headers['content-length'], 10) : 0;      // In case value is a string
    
        // Compression
    
        var mime = request.server.mime.type(response.headers['content-type'] || 'application/octet-stream');
        var encoding = (mime.compressible && !response.headers['content-encoding'] ? request.info.acceptEncoding : null);
        encoding = (encoding === 'identity' ? null : encoding);
    
        // Range
    
        if (request.method === 'get' &&
            response.statusCode === 200 &&
            length &&
            !encoding) {
    
            if (request.headers.range) {
    
                // Check If-Range
    
                if (!request.headers['if-range'] ||
                    request.headers['if-range'] === response.headers.etag) {            // Ignoring last-modified date (weak)
    
                    // Parse header
    
                    var ranges = Ammo.header(request.headers.range, length);
                    if (!ranges) {
                        var error = Boom.rangeNotSatisfiable();
                        error.output.headers['content-range'] = 'bytes */' + length;
                        return internals.fail(request, error, callback);
                    }
    
                    // Prepare transform
    
                    if (ranges.length === 1) {                                          // Ignore requests for multiple ranges
                        var range = ranges[0];
                        var ranger = new Ammo.Stream(range);
                        response.code(206);
                        response.bytes(range.to - range.from + 1);
                        response._header('content-range', 'bytes ' + range.from + '-' + range.to + '/' + length);
                    }
                }
            }
    
            response._header('accept-ranges', 'bytes');
        }
    
        // Content-Encoding
    
        if (encoding &&
            length &&
            response._isPayloadSupported()) {
    
            delete response.headers['content-length'];
            response._header('content-encoding', encoding);
            response.vary('accept-encoding');
    
            var compressor = (encoding === 'gzip' ? Zlib.createGzip() : Zlib.createDeflate());
        }
    
        if (response.headers['content-encoding'] &&
            response.headers.etag &&
            response.settings.varyEtag) {
    
            response.headers.etag = response.headers.etag.slice(0, -1) + '-' + response.headers['content-encoding'] + '"';
        }
    
        // Write headers
    
        var headers = Object.keys(response.headers);
        for (var h = 0, hl = headers.length; h < hl; ++h) {
            var header = headers[h];
            request.raw.res.setHeader(header, response.headers[header]);
        }
    
        request.raw.res.writeHead(response.statusCode);
    
        // Generate tap stream
    
        var tap = response._tap();
    
        // Write payload
    
        var hasEnded = false;
        var end = function (err, event) {
    
            if (!hasEnded) {
                hasEnded = true;
    
                if (event !== 'aborted') {
                    request.raw.res.end();
                }
    
                source.removeListener('error', end);
    
                request.raw.req.removeListener('aborted', onAborted);
                request.raw.req.removeListener('close', onClose);
    
                request.raw.res.removeListener('close', onClose);
                request.raw.res.removeListener('error', end);
                request.raw.res.removeListener('finish', end);
    
                var tags = (err ? ['response', 'error']
                                : (event ? ['response', 'error', event]
                                         : ['response']));
    
                if (event || err) {
                    request.emit('disconnect');
                }
    
                request._log(tags, err);
                callback();
            }
        };
    
        source.once('error', end);
    
        var onAborted = function () {
    
            end(null, 'aborted');
        };
    
        var onClose = function () {
    
            end(null, 'close');
        };
    
        request.raw.req.once('aborted', onAborted);
        request.raw.req.once('close', onClose);
    
        request.raw.res.once('close', onClose);
        request.raw.res.once('error', end);
        request.raw.res.once('finish', end);
    
        var preview = (tap ? source.pipe(tap) : source);
        var compressed = (compressor ? preview.pipe(compressor) : preview);
        var ranged = (ranger ? compressed.pipe(ranger) : compressed);
        ranged.pipe(request.raw.res);
    
        // Injection
    
        if (Shot.isInjection(request.raw.req)) {
            request.raw.res._hapi = {
                request: request
            };
    
            if (response.variety === 'plain') {
                request.raw.res._hapi.result = response._isPayloadSupported() ? response.source : null;
            }
        }
    };
    
    
    internals.Empty = function () {
    
        Stream.Readable.call(this);
    };
    
    Hoek.inherits(internals.Empty, Stream.Readable);
    
    
    internals.Empty.prototype._read = function (/* size */) {
    
        this.push(null);
    };
    
    
    internals.cors = function (response) {
    
        var request = response.request;
        var cors = request.route.settings.cors;
        if (cors) {
            if (cors._origin &&
                (!response.headers['access-control-allow-origin'] || cors.override)) {
    
                if (cors.matchOrigin) {
                    response.vary('origin');
                    if (internals.matchOrigin(request.headers.origin, cors)) {
                        response._header('access-control-allow-origin', request.headers.origin);
                    }
                    else if (cors.isOriginExposed) {
                        response._header('access-control-allow-origin', cors._origin.any ? '*' : cors._origin.qualifiedString);
                    }
                }
                else if (cors._origin.any) {
                    response._header('access-control-allow-origin', '*');
                }
                else {
                    response._header('access-control-allow-origin', cors._origin.qualifiedString);
                }
            }
    
            response._header('access-control-max-age', cors.maxAge, { override: cors.override });
            response._header('access-control-allow-methods', cors._methods, { override: cors.override });
            response._header('access-control-allow-headers', cors._headers, { override: cors.override });
    
            if (cors._exposedHeaders.length !== 0) {
                response._header('access-control-expose-headers', cors._exposedHeaders, { override: cors.override });
            }
    
            if (cors.credentials) {
                response._header('access-control-allow-credentials', 'true', { override: cors.override });
            }
        }
    };
    
    
    internals.matchOrigin = function (origin, cors) {
    
        if (!origin) {
            return false;
        }
    
        if (cors._origin.any) {
            return true;
        }
    
        if (cors._origin.qualified.indexOf(origin) !== -1) {
            return true;
        }
    
        for (var i = 0, il = cors._origin.wildcards.length; i < il; ++i) {
            if (origin.match(cors._origin.wildcards[i])) {
                return true;
            }
        }
    
        return false;
    };
    
    
    internals.cache = function (response) {
    
        if (response.headers['cache-control']) {
            return;
        }
    
        var request = response.request;
        if ((request._route._cache && request.route.settings.cache._statuses[response.statusCode]) ||
            response.settings.ttl) {
    
            var ttl = (response.settings.ttl !== null ? response.settings.ttl : request._route._cache.ttl());
            var privacy = (request.auth.isAuthenticated || response.headers['set-cookie'] ? 'private' : request.route.settings.cache.privacy || 'default');
            response._header('cache-control', 'max-age=' + Math.floor(ttl / 1000) + ', must-revalidate' + (privacy !== 'default' ? ', ' + privacy : ''));
        }
        else {
            response._header('cache-control', 'no-cache');
        }
    };
    
    
    internals.security = function (response) {
    
        var request = response.request;
    
        var security = request.route.settings.security;
        if (security) {
            if (security._hsts) {
                response._header('strict-transport-security', security._hsts, { override: false });
            }
    
            if (security._xframe) {
                response._header('x-frame-options', security._xframe, { override: false });
            }
    
            if (security.xss) {
                response._header('x-xss-protection', '1; mode=block', { override: false });
            }
    
            if (security.noOpen) {
                response._header('x-download-options', 'noopen', { override: false });
            }
    
            if (security.noSniff) {
                response._header('x-content-type-options', 'nosniff', { override: false });
            }
        }
    };
    
    
    internals.content = function (response) {
    
        var type = response.headers['content-type'];
        if (!type) {
            var charset = (response.settings.charset ? '; charset=' + response.settings.charset : '');
    
            if (typeof response.source === 'string') {
                response.type('text/html' + charset);
            }
            else if (Buffer.isBuffer(response.source)) {
                response.type('application/octet-stream');
            }
            else if (response.variety === 'plain' &&
                response.source !== null) {
    
                response.type('application/json' + charset);
            }
        }
        else if (response.settings.charset &&
            type.match(/^(?:text\/)|(?:application\/(?:json)|(?:javascript))/)) {
    
            var hasParams = (type.indexOf(';') !== -1);
            if (!hasParams ||
                !type.match(/[; ]charset=/)) {
    
                response.type(type + (hasParams ? ', ' : '; ') + 'charset=' + (response.settings.charset));
            }
        }
    };
    
    
    internals.state = function (response, next) {
    
        var request = response.request;
    
        var names = {};
        var states = [];
    
        var keys = Object.keys(request._states);
        for (var i = 0, il = keys.length; i < il; ++i) {
            var keyName = keys[i];
            names[keyName] = true;
            states.push(request._states[keyName]);
        }
    
        keys = Object.keys(request.connection.states.cookies);
        Items.parallel(keys, function (name, nextKey) {
    
            var autoValue = request.connection.states.cookies[name].autoValue;
            if (!autoValue || names[name]) {
                return nextKey();
            }
    
            names[name] = true;
    
            if (typeof autoValue !== 'function') {
                states.push({ name: name, value: autoValue });
                return nextKey();
            }
    
            autoValue(request, function (err, value) {
    
                if (err) {
                    return nextKey(err);
                }
    
                states.push({ name: name, value: value });
                return nextKey();
            });
        },
        function (err) {
    
            if (err) {
                return next(Boom.wrap(err));
            }
    
            if (!states.length) {
                return next();
            }
    
            request.connection.states.format(states, function (err, header) {
    
                if (err) {
                    return next(Boom.wrap(err));
                }
    
                var existing = response.headers['set-cookie'];
                if (existing) {
                    header = (Array.isArray(existing) ? existing : [existing]).concat(header);
                }
    
                response._header('set-cookie', header);
                return next();
            });
        });
    };
    
  provide("hapi/lib/transmit", module.exports);
}(global));

// pakmanager:hapi/lib/plugin
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Catbox = require('catbox');
    var Hoek = require('hoek');
    var Items = require('items');
    var Kilt = require('kilt');
    var Topo = require('topo');
    var Connection =  require('hapi/lib/connection');
    var Package = require('../package.json');
    var Schema =  require('hapi/lib/schema');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports = module.exports = internals.Plugin = function (server, connections, env, options) {            // env can be a realm or plugin name
    
        var self = this;
    
        Kilt.call(this, connections, server._events);
    
        // Validate options
    
        options = options || {};
        Schema.assert('register', options);
    
        // Public interface
    
        this.root = server;
        this.app = this.root._app;
        this.connections = connections;
        this.load = this.root._heavy.load;
        this.methods = this.root._methods.methods;
        this.mime = this.root._mime;
        this.plugins = this.root._plugins;
        this.settings = this.root._settings;
        this.version = Package.version;
    
        this.realm = typeof env !== 'string' ? env : {
            modifiers: {
                route: {
                    prefix: options.routes && options.routes.prefix,
                    vhost: options.routes && options.routes.vhost
                }
            },
            plugin: env,
            plugins: {},
            settings: {
                files: {
                    relativeTo: undefined
                },
                bind: undefined
            }
        };
    
        this.auth = {
            default: function (opts) {
    
                self._applyChild('auth.default', 'auth', 'default', [opts]);
            },
            scheme: function (name, scheme) {
    
                self._applyChild('auth.scheme', 'auth', 'scheme', [name, scheme]);
            },
            strategy: function (name, scheme, mode, opts) {
    
                self._applyChild('auth.strategy', 'auth', 'strategy', [name, scheme, mode, opts]);
            },
            test: function (name, request, next) {
    
                return request.connection.auth.test(name, request, next);
            }
        };
    
        if (this.connections.length === 1) {
            this._single();
        }
        else {
            this.info = null;
            this.inject = null;
            this.listener = null;
            this.lookup = null;
            this.match = null;
        }
    
        // Decorations
    
        var methods = Object.keys(this.root._decorations);
        for (var i = 0, il = methods.length; i < il; ++i) {
            var method = methods[i];
            this[method] = this.root._decorations[method];
        }
    };
    
    Hoek.inherits(internals.Plugin, Kilt);
    
    
    internals.Plugin.prototype._single = function () {
    
        this.info = this.connections[0].info;
        this.inject = internals.inject;
        this.listener = this.connections[0].listener;
        this.lookup = internals.lookup;
        this.match = internals.match;
    };
    
    
    internals.Plugin.prototype.select = function (/* labels */) {
    
        var labels = [];
        for (var i = 0, il = arguments.length; i < il; ++i) {
            labels.push(arguments[i]);
        }
    
        labels = Hoek.flatten(labels);
        return this._select(labels);
    };
    
    
    internals.Plugin.prototype._select = function (labels, plugin, options) {
    
        var connections = this.connections;
    
        if (labels &&
            labels.length) {            // Captures both empty arrays and empty strings
    
            Hoek.assert(typeof labels === 'string' || Array.isArray(labels), 'Bad labels object type (undefined or array required)');
            labels = [].concat(labels);
    
            connections = [];
            for (var i = 0, il = this.connections.length; i < il; ++i) {
                var connection = this.connections[i];
                if (Hoek.intersect(connection.settings.labels, labels).length) {
                    connections.push(connection);
                }
            }
    
            if (!plugin &&
                connections.length === this.connections.length) {
    
                return this;
            }
        }
    
        var env = (plugin !== undefined ? plugin : this.realm);                     // Allow empty string
        return new internals.Plugin(this.root, connections, env, options);
    };
    
    
    internals.Plugin.prototype._clone = function (connections, plugin) {
    
        var env = (plugin !== undefined ? plugin : this.realm);                     // Allow empty string
        return new internals.Plugin(this.root, connections, env);
    };
    
    
    internals.Plugin.prototype.register = function (plugins /*, [options], callback */) {
    
        var self = this;
    
        var options = (typeof arguments[1] === 'object' ? arguments[1] : {});
        var callback = (typeof arguments[1] === 'object' ? arguments[2] : arguments[1]);
    
        Hoek.assert(typeof callback === 'function', 'A callback function is required to register a plugin');
    
        if (this.realm.modifiers.route.prefix ||
            this.realm.modifiers.route.vhost) {
    
            options = Hoek.clone(options);
            options.routes = options.routes || {};
    
            options.routes.prefix = (this.realm.modifiers.route.prefix || '') + (options.routes.prefix || '') || undefined;
            options.routes.vhost = this.realm.modifiers.route.vhost || options.routes.vhost;
        }
    
        /*
            var register = function (server, options, next) { return next(); };
            register.attributes = {
                pkg: require('../package.json'),
                name: 'plugin',
                version: '1.1.1',
                multiple: false
            };
    
            var item = {
                register: register,
                options: options        // -optional--
            };
    
            - OR -
    
            var item = function () {}
            item.register = register;
            item.options = options;
    
            var plugins = register, items, [register, item]
        */
    
        var registrations = [];
        plugins = [].concat(plugins);
        for (var i = 0, il = plugins.length; i < il; ++i) {
            var plugin = plugins[i];
            var hint = (plugins.length > 1 ? '(' + i + ')' : '');
    
            if (typeof plugin === 'function' &&
                !plugin.register) {
    
                plugin = { register: plugin };
            }
    
            if (plugin.register.register) {                             // Required plugin
                plugin.register = plugin.register.register;
            }
    
            Hoek.assert(typeof plugin.register === 'function', 'Invalid plugin object - invalid or missing register function ', hint);
            var attributes = plugin.register.attributes;
            Hoek.assert(typeof plugin.register.attributes === 'object', 'Invalid plugin object - invalid or missing register function attributes property', hint);
    
            var registration = {
                register: plugin.register,
                name: attributes.name || (attributes.pkg && attributes.pkg.name),
                version: attributes.version || (attributes.pkg && attributes.pkg.version) || '0.0.0',
                multiple: attributes.multiple || false,
                options: plugin.options,
                dependencies: attributes.dependencies
            };
    
            Hoek.assert(registration.name, 'Missing plugin name', hint);
            Schema.assert('dependencies', registration.dependencies, 'must be a string or an array of strings');
    
            registrations.push(registration);
        }
    
        Items.serial(registrations, function (item, next) {
    
            var selection = self._select(options.select, item.name, options);
    
            // Protect against multiple registrations
    
            for (var j = 0, jl = selection.connections.length; j < jl; ++j) {
                var connection = selection.connections[j];
                Hoek.assert(item.multiple || !connection._registrations[item.name], 'Plugin', item.name, 'already registered in:', connection.info.uri);
                connection._registrations[item.name] = item;
            }
    
            if (item.dependencies) {
                selection.dependency(item.dependencies);
            }
    
            // Register
    
            item.register(selection, item.options || {}, next);
        }, callback);
    };
    
    
    internals.Plugin.prototype.after = function (method, dependencies) {
    
        this.root._afters = this.root._afters || new Topo();
        this.root._afters.add({ func: method, plugin: this }, { after: dependencies, group: this.realm.plugin });
    };
    
    
    internals.Plugin.prototype.bind = function (context) {
    
        Hoek.assert(typeof context === 'object', 'bind must be an object');
        this.realm.settings.bind = context;
    };
    
    
    internals.Plugin.prototype.cache = function (options, _segment) {
    
        Schema.assert('cachePolicy', options);
    
        var segment = options.segment || _segment || (this.realm.plugin ? '!' + this.realm.plugin : '');
        Hoek.assert(segment, 'Missing cache segment name');
    
        var cacheName = options.cache || '_default';
        var cache = this.root._caches[cacheName];
        Hoek.assert(cache, 'Unknown cache', cacheName);
        Hoek.assert(!cache.segments[segment] || cache.shared || options.shared, 'Cannot provision the same cache segment more than once');
        cache.segments[segment] = true;
    
        return new Catbox.Policy(options, cache.client, segment);
    };
    
    
    internals.Plugin.prototype.decorate = function (type, property, method) {
    
        Hoek.assert(['reply', 'request', 'server'].indexOf(type) !== -1, 'Unknown decoration type:', type);
        Hoek.assert(property, 'Missing decoration property name');
        Hoek.assert(typeof property === 'string', 'Decoration property must be a string');
        Hoek.assert(property[0] !== '_', 'Property name cannot begin with an underscore:', property);
    
        // Request
    
        if (type === 'request') {
            return this.root._requestor.decorate(property, method);
        }
    
        // Reply
    
        if (type === 'reply') {
            return this.root._replier.decorate(property, method);
        }
    
        // Server
    
        Hoek.assert(!this.root._decorations[property], 'Server decoration already defined:', property);
        Hoek.assert(this[property] === undefined && this.root[property] === undefined, 'Cannot override the built-in server interface method:', property);
    
        this.root._decorations[property] = method;
    
        this.root[property] = method;
        this[property] = method;
    };
    
    
    internals.Plugin.prototype.dependency = function (dependencies, after) {
    
        Hoek.assert(this.realm.plugin, 'Cannot call dependency() outside of a plugin');
        Hoek.assert(!after || typeof after === 'function', 'Invalid after method');
    
        dependencies = [].concat(dependencies);
        this.root._dependencies.push({ plugin: this.realm.plugin, connections: this.connections, deps: dependencies });
    
        if (after) {
            this.after(after, dependencies);
        }
    };
    
    
    internals.Plugin.prototype.expose = function (key, value) {
    
        Hoek.assert(this.realm.plugin, 'Cannot call expose() outside of a plugin');
    
        var plugin = this.realm.plugin;
        this.root.plugins[plugin] = this.root.plugins[plugin] || {};
        if (typeof key === 'string') {
            this.root.plugins[plugin][key] = value;
        }
        else {
            Hoek.merge(this.root.plugins[plugin], key);
        }
    };
    
    
    internals.Plugin.prototype.ext = function (event, func, options) {
    
        this._apply('ext', Connection.prototype._ext, [event, func, options, this.realm]);
    };
    
    
    internals.Plugin.prototype.handler = function (name, method) {
    
        Hoek.assert(typeof name === 'string', 'Invalid handler name');
        Hoek.assert(!this.root._handlers[name], 'Handler name already exists:', name);
        Hoek.assert(typeof method === 'function', 'Handler must be a function:', name);
        Hoek.assert(!method.defaults || typeof method.defaults === 'object' || typeof method.defaults === 'function', 'Handler defaults property must be an object or function');
        this.root._handlers[name] = method;
    };
    
    
    internals.inject = function (options, callback) {
    
        return this.connections[0].inject(options, callback);
    };
    
    
    internals.Plugin.prototype.log = function (tags, data, timestamp, _internal) {
    
        tags = (Array.isArray(tags) ? tags : [tags]);
        var now = (timestamp ? (timestamp instanceof Date ? timestamp.getTime() : timestamp) : Date.now());
    
        var event = {
            timestamp: now,
            tags: tags,
            data: data,
            internal: !!_internal
        };
    
        var tagsMap = Hoek.mapToObject(event.tags);
        this.root._events.emit('log', event, tagsMap);
    
        if (this.root._settings.debug &&
            this.root._settings.debug.log &&
            Hoek.intersect(tagsMap, this.root._settings.debug.log, true)) {
    
            console.error('Debug:', event.tags.join(', '), (data ? '\n    ' + (data.stack || (typeof data === 'object' ? Hoek.stringify(data) : data)) : ''));
        }
    };
    
    
    internals.Plugin.prototype._log = function (tags, data) {
    
        return this.log(tags, data, null, true);
    };
    
    
    internals.lookup = function (id) {
    
        return this.connections[0].lookup(id);
    };
    
    
    internals.match = function (method, path, host) {
    
        return this.connections[0].match(method, path, host);
    };
    
    
    internals.Plugin.prototype.method = function (name, method, options) {
    
        return this.root._methods.add(name, method, options, this.realm);
    };
    
    
    internals.Plugin.prototype.path = function (relativeTo) {
    
        Hoek.assert(relativeTo && typeof relativeTo === 'string', 'relativeTo must be a non-empty string');
        this.realm.settings.files.relativeTo = relativeTo;
    };
    
    
    internals.Plugin.prototype.route = function (options) {
    
        Hoek.assert(arguments.length === 1, 'Method requires a single object argument or a single array of objects');
        Hoek.assert(typeof options === 'object', 'Invalid route options');
        Hoek.assert(this.connections.length, 'Cannot add a route without any connections');
    
        this._apply('route', Connection.prototype._route, [options, this.realm]);
    };
    
    
    internals.Plugin.prototype.state = function (name, options) {
    
        this._applyChild('state', 'states', 'add', [name, options]);
    };
    
    
    internals.Plugin.prototype.table = function (host) {
    
        var table = [];
        for (var i = 0, il = this.connections.length; i < il; ++i) {
            var connection = this.connections[i];
            table.push({ info: connection.info, labels: connection.settings.labels, table: connection.table(host) });
        }
    
        return table;
    };
    
    
    internals.Plugin.prototype._apply = function (type, func, args) {
    
        Hoek.assert(this.connections.length, 'Cannot add ' + type + ' without a connection');
    
        for (var i = 0, il = this.connections.length; i < il; ++i) {
            func.apply(this.connections[i], args);
        }
    };
    
    
    internals.Plugin.prototype._applyChild = function (type, child, func, args) {
    
        Hoek.assert(this.connections.length, 'Cannot add ' + type + ' without a connection');
    
        for (var i = 0, il = this.connections.length; i < il; ++i) {
            var obj = this.connections[i][child];
            obj[func].apply(obj, args);
        }
    };
    
  provide("hapi/lib/plugin", module.exports);
}(global));

// pakmanager:hapi/lib/reply
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Hoek = require('hoek');
    var Response =  require('hapi/lib/response');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports = module.exports = internals.Reply = function () {
    
        this._decorations = null;
    };
    
    
    internals.Reply.prototype.decorate = function (property, method) {
    
        Hoek.assert(!this._decorations || !this._decorations[property], 'Reply interface decoration already defined:', property);
        Hoek.assert(['request', 'response', 'close', 'state', 'unstate', 'redirect', 'continue'].indexOf(property) === -1, 'Cannot override built-in reply interface decoration:', property);
    
        this._decorations = this._decorations || {};
        this._decorations[property] = method;
    };
    
    
    /*
        var handler = function (request, reply) {
    
            reply(error, result, ignore);   -> error || result (continue)
            reply(...).takeover();          -> ... (continue)
    
            reply.continue(ignore);         -> null (continue)
        };
    
        var ext = function (request, reply) {
    
            reply(error, result, ignore);   -> error || result (respond)
            reply(...).takeover();          -> ... (respond)
    
            reply.continue(ignore);         -> (continue)
        };
    
        var pre = function (request, reply) {
    
            reply(error);                   -> error (respond)  // failAction override
            reply(null, result, ignore);    -> result (continue)
            reply(...).takeover();          -> ... (respond)
    
            reply.continue(ignore);         -> null (continue)
        };
    
        var auth = function (request, reply) {
    
            reply(error, result, data);     -> error || result (respond) + data
            reply(...).takeover();          -> ... (respond) + data
    
            reply.continue(data);           -> (continue) + data
        };
    */
    
    internals.Reply.prototype.interface = function (request, realm, next) {       // next(err || response, data);
    
        var reply = function (err, response, data) {
    
            reply._data = data;                 // Held for later
            return reply.response(err !== null && err !== undefined ? err : response);
        };
    
        reply._replied = false;
        reply._next = Hoek.once(next);
    
        reply.realm = realm;
        reply.request = request;
    
        reply.response = internals.response;
        reply.close = internals.close;
        reply.state = internals.state;
        reply.unstate = internals.unstate;
        reply.redirect = internals.redirect;
        reply.continue = internals.continue;
    
        if (this._decorations) {
            var methods = Object.keys(this._decorations);
            for (var i = 0, il = methods.length; i < il; ++i) {
                var method = methods[i];
                reply[method] = this._decorations[method];
            }
        }
    
        return reply;
    };
    
    
    internals.close = function (options) {
    
        options = options || {};
        this._next({ closed: true, end: options.end !== false });
    };
    
    
    internals.continue = function (data) {
    
        this._next(null, data);
        this._next = null;
    };
    
    
    internals.state = function (name, value, options) {
    
        this.request._setState(name, value, options);
    };
    
    
    internals.unstate = function (name) {
    
        this.request._clearState(name);
    };
    
    
    internals.redirect = function (location) {
    
        return this.response('').redirect(location);
    };
    
    
    internals.response = function (result) {
    
        var self = this;
    
        Hoek.assert(!this._replied, 'reply interface called twice');
        this._replied = true;
    
        var response = Response.wrap(result, this.request);
        if (response.isBoom) {
            this._next(response, this._data);
            this._next = null;
            return response;
        }
    
        response.hold = function () {
    
            this.hold = undefined;
            this.send = function () {
    
                this.send = undefined;
                this._prepare(self._data, self._next);
                this._next = null;
            };
    
            return this;
        };
    
        process.nextTick(function () {
    
            response.hold = undefined;
    
            if (!response.send &&
                self._next) {
    
                response._prepare(self._data, self._next);
                self._next = null;
            }
        });
    
        return response;
    };
    
  provide("hapi/lib/reply", module.exports);
}(global));

// pakmanager:hapi/lib/request
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Events = require('events');
    var Url = require('url');
    var Accept = require('accept');
    var Boom = require('boom');
    var Hoek = require('hoek');
    var Items = require('items');
    var Peekaboo = require('peekaboo');
    var Qs = require('qs');
    var Handler =  require('hapi/lib/handler');
    var Protect =  require('hapi/lib/protect');
    var Response =  require('hapi/lib/response');
    var Transmit =  require('hapi/lib/transmit');
    
    
    // Declare internals
    
    var internals = {
        properties: ['connection', 'server', 'url', 'query', 'path', 'method', 'mime', 'setUrl', 'setMethod', 'headers', 'id', 'app', 'plugins', 'route', 'auth', 'session', 'pre', 'preResponses', 'info', 'orig', 'params', 'paramsArray', 'payload', 'state', 'jsonp', 'response', 'raw', 'tail', 'addTail', 'domain', 'log', 'getLog', 'generateResponse']
    };
    
    
    exports = module.exports = internals.Generator = function () {
    
        this._decorations = null;
    };
    
    
    internals.Generator.prototype.request = function (connection, req, res, options) {
    
        var request = new internals.Request(connection, req, res, options);
    
        // Decorate
    
        if (this._decorations) {
            var methods = Object.keys(this._decorations);
            for (var i = 0, il = methods.length; i < il; ++i) {
                var method = methods[i];
                request[method] = this._decorations[method];
            }
        }
    
        return request;
    };
    
    
    internals.Generator.prototype.decorate = function (property, method) {
    
        Hoek.assert(!this._decorations || !this._decorations[property], 'Request interface decoration already defined:', property);
        Hoek.assert(internals.properties.indexOf(property) === -1, 'Cannot override built-in request interface decoration:', property);
    
        this._decorations = this._decorations || {};
        this._decorations[property] = method;
    };
    
    
    internals.Request = function (connection, req, res, options) {
    
        var self = this;
    
        Events.EventEmitter.call(this);
    
        // Take measurement as soon as possible
    
        this._bench = new Hoek.Bench();
        var now = Date.now();
    
        // Public members
    
        this.connection = connection;
        this.server = connection.server;
    
        this.url = null;
        this.query = null;
        this.path = null;
        this.method = null;
        this.mime = null;                       // Set if payload is parsed
    
        this.setUrl = this._setUrl;             // Decoration removed after 'onRequest'
        this.setMethod = this._setMethod;
    
        this._setUrl(req.url, this.connection.settings.router.stripTrailingSlash);      // Sets: this.url, this.path, this.query
        this._setMethod(req.method);                                                    // Sets: this.method
        this.headers = req.headers;
    
        this.id = now + ':' + connection.info.id + ':' + connection._requestCounter.value++;
        if (connection._requestCounter.value > connection._requestCounter.max) {
            connection._requestCounter.value = connection._requestCounter.min;
        }
    
        this.app = {};                          // Place for application-specific state without conflicts with hapi, should not be used by plugins
        this.plugins = {};                      // Place for plugins to store state without conflicts with hapi, should be namespaced using plugin name
    
        this._route = this.connection._router.specials.notFound.route;    // Used prior to routing (only settings are used, not the handler)
        this.route = this._route.public;
    
        this.auth = {
            isAuthenticated: false,
            credentials: null,                  // Special keys: 'app', 'user', 'scope'
            artifacts: null,                    // Scheme-specific artifacts
            session: null                       // Used by cookie auth { set(), clear() }
        };
    
        this.session = null;                    // Special key reserved for plugins implementing session support
    
        this.pre = {};                          // Pre raw values
        this.preResponses = {};                 // Pre response values
    
        this.info = {
            received: now,
            responded: 0,
            remoteAddress: req.connection ? req.connection.remoteAddress : '',
            remotePort: req.connection ? req.connection.remotePort : '',
            referrer: req.headers.referrer || req.headers.referer || '',
            host: req.headers.host ? req.headers.host.replace(/\s/g, '') : '',
            acceptEncoding: Accept.encoding(this.headers['accept-encoding'], ['identity', 'gzip', 'deflate'])
        };
    
        this.info.hostname = this.info.host.split(':')[0];
    
        // Apply options
    
        if (options.credentials) {
            this.auth.credentials = options.credentials;
        }
    
        if (options.artifacts) {
            this.auth.artifacts = options.artifacts;
        }
    
        // Assigned elsewhere:
    
        this.orig = {};
        this.params = {};
        this.paramsArray = [];              // Array of path parameters in path order
        this.payload = null;
        this.state = null;
        this.jsonp = null;
        this.response = null;
    
        // Semi-public members
    
        this.raw = {
            req: req,
            res: res
        };
    
        this.tail = this.addTail = this._addTail;       // Removed once wagging
    
        // Private members
    
        this._states = {};
        this._logger = [];
        this._isPayloadPending = true;      // false when incoming payload fully processed
        this._isBailed = false;             // true when lifecycle should end
        this._isReplied = false;            // true when response processing started
        this._isFinalized = false;          // true when request completed (may be waiting on tails to complete)
        this._tails = {};                   // tail id -> name (tracks pending tails)
        this._tailIds = 0;                  // Used to generate a unique tail id
        this._protect = new Protect(this);
        this.domain = this._protect.domain;
    
        // Listen to request state
    
        this._onEnd = function () {
    
            self._isPayloadPending = false;
        };
    
        this.raw.req.once('end', this._onEnd);
    
        this._onClose = function () {
    
            self._log(['request', 'closed', 'error']);
            self._isPayloadPending = false;
            self._isBailed = true;
        };
    
        this.raw.req.once('close', this._onClose);
    
        this._onError = function (err) {
    
            self._log(['request', 'error'], err);
            self._isPayloadPending = false;
        };
    
        this.raw.req.once('error', this._onError);
    
        // Log request
    
        var about = {
            id: this.id,
            method: this.method,
            url: this.url.href,
            agent: this.raw.req.headers['user-agent']
        };
    
        this._log(['received'], about, now);     // Must be last for object to be fully constructed
    };
    
    Hoek.inherits(internals.Request, Events.EventEmitter);
    
    
    internals.Request.prototype._setUrl = function (url, stripTrailingSlash, parserOptions) {
    
        this.url = Url.parse(url, false);
        this.url.query = Qs.parse(this.url.query, this.connection.settings.query.qs || parserOptions);      // Override parsed value
        this.query = this.url.query;
        this.path = this.url.pathname || '';                                                            // pathname excludes query
    
        if (stripTrailingSlash &&
            this.path.length > 1 &&
            this.path[this.path.length - 1] === '/') {
    
            this.path = this.path.slice(0, -1);
            this.url.pathname = this.path;
        }
    
        this.path = this.connection._router.normalize(this.path);
    };
    
    
    internals.Request.prototype._setMethod = function (method) {
    
        Hoek.assert(method && typeof method === 'string', 'Missing method');
        this.method = method.toLowerCase();
    };
    
    
    internals.Request.prototype.log = function (tags, data, timestamp, _internal) {
    
        tags = (Array.isArray(tags) ? tags : [tags]);
        var now = (timestamp ? (timestamp instanceof Date ? timestamp.getTime() : timestamp) : Date.now());
    
        var event = {
            request: this.id,
            timestamp: now,
            tags: tags,
            data: data,
            internal: !!_internal
        };
    
        var tagsMap = Hoek.mapToObject(event.tags);
    
        // Add to request array
    
        this._logger.push(event);
        this.connection.emit(_internal ? 'request-internal' : 'request', this, event, tagsMap);
    
        if (this.server._settings.debug &&
            this.server._settings.debug.request &&
            Hoek.intersect(tagsMap, this.server._settings.debug.request, true)) {
    
            console.error('Debug:', event.tags.join(', '), (data ? '\n    ' + (data.stack || (typeof data === 'object' ? Hoek.stringify(data) : data)) : ''));
        }
    };
    
    
    internals.Request.prototype._log = function (tags, data) {
    
        return this.log(tags, data, null, true);
    };
    
    
    internals.Request.prototype.getLog = function (tags, internal) {
    
        if (typeof tags === 'boolean') {
            internal = tags;
            tags = [];
        }
    
        tags = [].concat(tags || []);
        if (!tags.length &&
            internal === undefined) {
    
            return this._logger;
        }
    
        var filter = tags.length ? Hoek.mapToObject(tags) : null;
        var result = [];
    
        for (var i = 0, il = this._logger.length; i < il; ++i) {
            var event = this._logger[i];
            if (internal === undefined || event.internal === internal) {
                if (filter) {
                    for (var t = 0, tl = event.tags.length; t < tl; ++t) {
                        var tag = event.tags[t];
                        if (filter[tag]) {
                            result.push(event);
                            break;
                        }
                    }
                }
                else {
                    result.push(event);
                }
            }
        }
    
        return result;
    };
    
    
    internals.Request.prototype._execute = function () {
    
        var self = this;
    
        // Execute onRequest extensions (can change request method and url)
    
        Handler.invoke(this, 'onRequest', function (err) {
    
            // Undecorate request
    
            self.setUrl = undefined;
            self.setMethod = undefined;
    
            if (err) {
                return self._reply(err);
            }
    
            if (!self.path || self.path[0] !== '/') {
                return self._reply(Boom.badRequest('Invalid path'));
            }
    
            // Lookup route
    
            var match = self.connection._router.route(self.method, self.path, self.info.hostname);
            self._route = match.route;
            self.route = self._route.public;
            self.params = match.params;
            self.paramsArray = match.paramsArray;
    
            // Setup timeout
    
            if (self.raw.req.socket &&
                self.route.settings.timeout.socket !== undefined) {
    
                self.raw.req.socket.setTimeout(self.route.settings.timeout.socket || 0);     // Value can be false or positive
            }
    
            var serverTimeout = self.route.settings.timeout.server;
            if (serverTimeout) {
                serverTimeout = Math.floor(serverTimeout - self._bench.elapsed());      // Calculate the timeout from when the request was constructed
                var timeoutReply = function () {
    
                    self._log(['request', 'server', 'timeout', 'error'], { timeout: serverTimeout, elapsed: self._bench.elapsed() });
                    self._reply(Boom.serverTimeout());
                };
    
                if (serverTimeout <= 0) {
                    return timeoutReply();
                }
    
                self._serverTimeoutId = setTimeout(timeoutReply, serverTimeout);
            }
    
            Items.serial(self._route._cycle, function (func, next) {
    
                if (self._isReplied ||
                    self._isBailed) {
    
                    return next(Boom.internal('Already closed'));                       // Error is not used
                }
    
                if (typeof func === 'string') {                                         // Extension point
                    return Handler.invoke(self, func, next);
                }
    
                func(self, next);
            },
            function (err) {
    
                self._reply(err);
            });
        });
    };
    
    
    internals.Request.prototype._reply = function (exit) {
    
        var self = this;
    
        if (this._isReplied) {                                  // Prevent any future responses to this request
            return;
        }
    
        this._isReplied = true;
    
        clearTimeout(this._serverTimeoutId);
    
        if (this._isBailed) {
            return this._finalize();
        }
    
        if (this.response &&                                    // Can be null if response coming from exit
            this.response.closed) {
    
            if (this.response.end) {
                this.raw.res.end();                             // End the response in case it wasn't already closed
            }
    
            return this._finalize();
        }
    
        if (exit) {
            this._setResponse(Response.wrap(exit, this));
        }
    
        Handler.invoke(this, 'onPreResponse', function (err) {
    
            if (err) {                                          // err can be valid response or error
                self._setResponse(Response.wrap(err, self));
            }
    
            Transmit.send(self, function () {
    
                return self._finalize();
            });
        });
    };
    
    
    internals.Request.prototype._finalize = function () {
    
        this.info.responded = Date.now();
    
        if (this.response &&
            this.response.statusCode === 500 &&
            this.response._error) {
    
            this.connection.emit('request-error', this, this.response._error);
            this._log(this.response._error.isDeveloperError ? ['internal', 'implementation', 'error'] : ['internal', 'error'], this.response._error);
        }
    
        this.connection.emit('response', this);
    
        this._isFinalized = true;
        this.addTail = undefined;
        this.tail = undefined;
    
        if (Object.keys(this._tails).length === 0) {
            this.connection.emit('tail', this);
        }
    
        // Cleanup
    
        this.raw.req.removeListener('end', this._onEnd);
        this.raw.req.removeListener('close', this._onClose);
        this.raw.req.removeListener('error', this._onError);
    
        if (this.response &&
            this.response._close) {
    
            this.response._close();
        }
    
        this._protect.logger = this.server;
    };
    
    
    internals.Request.prototype._setResponse = function (response) {
    
        if (this.response &&
            !this.response.isBoom &&
            this.response !== response &&
            (response.isBoom || this.response.source !== response.source)) {
    
            this.response._close();
        }
    
        if (this._isFinalized) {
            if (response._close) {
                response._close();
            }
    
            return;
        }
    
        this.response = response;
    };
    
    
    internals.Request.prototype._addTail = function (name) {
    
        var self = this;
    
        name = name || 'unknown';
        var tailId = this._tailIds++;
        this._tails[tailId] = name;
        this._log(['tail', 'add'], { name: name, id: tailId });
    
        var drop = function () {
    
            if (!self._tails[tailId]) {
                self._log(['tail', 'remove', 'error'], { name: name, id: tailId });             // Already removed
                return;
            }
    
            delete self._tails[tailId];
    
            if (Object.keys(self._tails).length === 0 &&
                self._isFinalized) {
    
                self._log(['tail', 'remove', 'last'], { name: name, id: tailId });
                self.connection.emit('tail', self);
            }
            else {
                self._log(['tail', 'remove'], { name: name, id: tailId });
            }
        };
    
        return drop;
    };
    
    
    internals.Request.prototype._setState = function (name, value, options) {          // options: see Defaults.state
    
        var state = {
            name: name,
            value: value
        };
    
        if (options) {
            Hoek.assert(!options.autoValue, 'Cannot set autoValue directly in a response');
            state.options = Hoek.clone(options);
        }
    
        this._states[name] = state;
    };
    
    
    internals.Request.prototype._clearState = function (name, options) {
    
        var state = {
            name: name
        };
    
        state.options = Hoek.clone(options || {});
        state.options.ttl = 0;
    
        this._states[name] = state;
    };
    
    
    internals.Request.prototype._tap = function () {
    
        return (this.listeners('finish').length || this.listeners('peek').length ? new Peekaboo(this) : null);
    };
    
    
    internals.Request.prototype.generateResponse = function (source, options) {
    
        return new Response(source, this, options);
    };
    
  provide("hapi/lib/request", module.exports);
}(global));

// pakmanager:hapi/lib/server
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Events = require('events');
    var Catbox = require('catbox');
    var CatboxMemory = require('catbox-memory');
    var H2o2 = require('h2o2');
    var Heavy = require('heavy');
    var Hoek = require('hoek');
    var Inert = require('inert');
    var Items = require('items');
    var Mimos = require('mimos');
    var Vision = require('vision');
    var Connection =  require('hapi/lib/connection');
    var Defaults =  require('hapi/lib/defaults');
    var Methods =  require('hapi/lib/methods');
    var Plugin =  require('hapi/lib/plugin');
    var Reply =  require('hapi/lib/reply');
    var Request =  require('hapi/lib/request');
    var Schema =  require('hapi/lib/schema');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports = module.exports = internals.Server = function (options) {
    
        Hoek.assert(this.constructor === internals.Server, 'Server must be instantiated using new');
    
        options = Schema.assert('server', options || {});
    
        this._settings = Hoek.applyToDefaultsWithShallow(Defaults.server, options, ['connections.routes.bind']);
        this._settings.connections = Hoek.applyToDefaultsWithShallow(Defaults.connection, this._settings.connections || {}, ['routes.bind']);
        this._settings.connections.routes.cors = Hoek.applyToDefaults(Defaults.cors, this._settings.connections.routes.cors);
        this._settings.connections.routes.security = Hoek.applyToDefaults(Defaults.security, this._settings.connections.routes.security);
    
        this._caches = {};                                                  // Cache clients
        this._handlers = {};                                                // Registered handlers
        this._methods = new Methods(this);                                  // Server methods
    
        this._events = new Events.EventEmitter();                           // Server-only events
        this._dependencies = [];                                            // Plugin dependencies
        this._afters = null;                                                // Plugin after() dependencies
        this._heavy = new Heavy(this._settings.load);
        this._mime = new Mimos(this._settings.mime);
        this._replier = new Reply();
        this._requestor = new Request();
        this._decorations = {};
        this._plugins = {};                                                 // Exposed plugin properties by name
        this._app = {};
    
        if (options.cache) {
            var caches = [].concat(options.cache);
            for (var i = 0, il = caches.length; i < il; ++i) {
                this._createCache(caches[i]);
            }
        }
    
        if (!this._caches._default) {
            this._createCache({ engine: CatboxMemory });                    // Defaults to memory-based
        }
    
        Plugin.call(this, this, [], '');
    
        if (!this._settings.minimal) {
            this.register([Vision, Inert, H2o2], Hoek.ignore);              // Safe to ignore
        }
    };
    
    Hoek.inherits(internals.Server, Plugin);
    
    
    internals.Server.prototype._createCache = function (options) {
    
        if (typeof options === 'function') {
            options = { engine: options };
        }
    
        var name = options.name || '_default';
        Hoek.assert(!this._caches[name], 'Cannot configure the same cache more than once: ', name === '_default' ? 'default cache' : name);
    
        var client = null;
        if (typeof options.engine === 'object') {
            client = new Catbox.Client(options.engine);
        }
        else {
            var settings = Hoek.clone(options);
            settings.partition = settings.partition || 'hapi-cache';
            delete settings.name;
            delete settings.engine;
            delete settings.shared;
    
            client = new Catbox.Client(options.engine, settings);
        }
    
        this._caches[name] = {
            client: client,
            segments: {},
            shared: options.shared || false
        };
    };
    
    
    internals.Server.prototype.connection = function (options) {
    
        var settings = Hoek.applyToDefaultsWithShallow(this._settings.connections, options || {}, ['listener', 'routes.bind']);
        settings.routes.cors = Hoek.applyToDefaults(this._settings.connections.routes.cors || Defaults.cors, settings.routes.cors);
        settings.routes.security = Hoek.applyToDefaults(this._settings.connections.routes.security || Defaults.security, settings.routes.security);
    
        settings = Schema.assert('connection', settings);       // Applies validation changes (type cast)
    
        var connection = new Connection(this, settings);
        this.connections.push(connection);
        this.addEmitter(connection);
    
        if (this.connections.length === 1) {
            this._single();
        }
    
        return this._clone([connection]);
    };
    
    
    internals.Server.prototype.start = function (callback) {
    
        var self = this;
    
        callback = callback || Hoek.ignore;
    
        Hoek.assert(this.connections.length, 'No connections to start');
    
        // Assert dependencies
    
        for (var i = 0, il = this._dependencies.length; i < il; ++i) {
            var dependency = this._dependencies[i];
            for (var s = 0, sl = dependency.connections.length; s < sl; ++s) {
                var connection = dependency.connections[s];
                for (var d = 0, dl = dependency.deps.length; d < dl; ++d) {
                    var dep = dependency.deps[d];
                    Hoek.assert(connection._registrations[dep], 'Plugin', dependency.plugin, 'missing dependency', dep, 'in connection:', connection.info.uri);
                }
            }
        }
    
        // Start cache
    
        var caches = Object.keys(self._caches);
        Items.parallel(caches, function (cache, next) {
    
            self._caches[cache].client.start(next);
        },
        function (err) {
    
            if (err) {
                return callback(err);
            }
    
            // After hooks
    
            var finalize = function (err) {
    
                if (err) {
                    return callback(err);
                }
    
                // Load measurements
    
                self._heavy.start();
    
                // Start connections
    
                Items.serial(self.connections, function (connectionItem, next) {
    
                    connectionItem._start(next);
                },
                function (err) {
    
                    self._events.emit('start');
                    return callback(err);
                });
            };
    
            var exts = self._afters;
            if (!exts) {
                return process.nextTick(finalize);
            }
    
            Items.serial(exts.nodes, function (ext, next) {
    
                ext.func(ext.plugin, next);
            },
            function (err) {
    
                return finalize(err);
            });
        });
    };
    
    
    internals.Server.prototype.stop = function (/*[options], [callback]*/) {
    
        var self = this;
    
        var callback = (arguments.length === 1 ? (typeof arguments[0] === 'function' ? arguments[0] : null) : arguments[1]);
        var options = (arguments.length === 1 ? (typeof arguments[0] === 'function' ? null : arguments[0]) : arguments[0]);
    
        Items.serial(this.connections, function (connection, next) {
    
            connection._stop(options, next);
        },
        function (err) {
    
            var caches = Object.keys(self._caches);
            for (var i = 0, il = caches.length; i < il; ++i) {
                self._caches[caches[i]].client.stop();
            }
    
            self._events.emit('stop');
            self._heavy.stop();
    
            if (callback) {
                callback(err);
            }
        });
    };
    
  provide("hapi/lib/server", module.exports);
}(global));

// pakmanager:hapi
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Server =  require('hapi/lib/server');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.Server = Server;
    
  provide("hapi", module.exports);
}(global));

// pakmanager:hapi-swagger/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Hoek        = require('hoek'),
        Boom        = require('boom'),
        Joi         = require('joi'),
        Path        = require('path'),
        ShortId     = require('shortid');
    
    
    
    // Declare internals
    
    var internals = {
        defaults: {
            protocol: null, // If not specified, uses the same protocol as server info
            endpoint: '/docs',
            documentationPath: '/documentation',
            enableDocumentationPage: true,
            auth: false,
            basePath: '',
            pathPrefixSize: 1,
            payloadType: 'json',
            produces: ['application/json'],
            consumes: ['application/json'],
            ui: true,
            listing: true,
            index: false,
            customJSHandler: function(request, reply) {
              reply('').type('application/javascript');
            },
        }
    };
    
    
    internals.first = function first(array) {
        return array ? array[0] : undefined;
    };
    
    
    exports.register = function (server, options, next) {
    
        var settings = Hoek.applyToDefaults(internals.defaults, options || {});
    
        // append settings data in template context
        internals.appendReplyContext( server, settings );
    
    
        // add routing for documentation API endpoint ie /docs
        server.route({
            method: 'GET',
            path: settings.endpoint,
            config: internals.docs(settings)
        });
    
        if (settings.enableDocumentationPage) {
            server.route({
                method: 'GET',
                path: settings.documentationPath,            
                config: {
                  auth: settings.auth,
                },
                handler: function(request, reply) {
                    reply.view('swagger.html', {});
                }
            });
        }
    
        if (settings.ui) {
    
            server.views({
                engines: {
                    html: {
                        module: require('handlebars')
                    }
                },
                path: __dirname + '/../public/swaggerui'
            });
    
    
            server.route({
                method: 'GET',
                path: '/docs/swaggerui/images/throbber.gif',
                handler: function (request, reply) {
                    reply.file( __dirname + '/../public/swaggerui/images/throbber.gif');
                }
            })
    
    
            server.route({
                method: 'GET',
                path: settings.endpoint + '/custom.js',
                config: {
                    auth:settings.auth,
                },
                handler: settings.customJSHandler,
            });
    
    
            // add routing for swaggerui library directory ie /docs/swaggerui
            server.route({
                method: 'GET',
                path: settings.endpoint + '/swaggerui/{path*}',
                config: {
                    auth: settings.auth
                },
                handler: {
                    directory: {
                        path: __dirname + Path.sep + '..' + Path.sep + 'public' + Path.sep + 'swaggerui' + Path.sep,
                        listing: settings.listing,
                        index: settings.index
                    }
                }
            });
    
    
        }
        next();
    };
    
    
    exports.register.attributes = {
        pkg: require('../package.json')
    };
    
    
    internals.docs = function (settings) {
    
        return {
            auth: settings.auth,
            validate: {
                query: Joi.object().keys({
                    path: Joi.string(),
                    tags: Joi.string(),
                    api_key: Joi.string()
                })
            },
            handler: function (request, reply) {
    
    
                var requestSettings = Hoek.clone(settings);
                requestSettings.log = request.server.log.bind(request.server);
    
                // prepend full protocol, hostname and port onto endpoints for shred
                var protocol = requestSettings.protocol || request.server.info.protocol || 'http';
                var hostname = protocol + '://' + request.headers.host;
                if (!requestSettings.basePath.match(/^https?:\/\//)) {
                    requestSettings.basePath = hostname + settings.basePath;
                }
                if (!requestSettings.endpoint.match(/^https?:\/\//)) {
                    requestSettings.endpoint = requestSettings.basePath + settings.endpoint;
                }
    
                var routes = request.server.table()[0].table,
                    resourceName = request.query.path;
    
    
                // if we have a resource name filter routes
                if (resourceName) {
                    // remove routes that do not belong to the resource
                    routes = routes.filter(function (item) {
                        if (item.method !== 'options' && internals.isResourceRoute(item.path, resourceName)) {
                            return true;
                        }
                        return false;
                    });
                }
    
                // Remove routes without the specified tags allow for + and - tag prefixes
                // e.g.: ?path=vacations&tags=mountains,beach,horses
                //         will show routes WITH 'mountains' OR 'beach' OR 'horses'
                //
                // e.g.: ?path=vacations&tags=mountains,beach,+horses
                //         will show routes WITH ('mountains' OR 'beach')  AND 'horses'
                //
                //  e.g.: ?path=vacations&tags=mountains,+beach,-horses
                //         will show routes WITH 'mountains' AND 'beach' AND NO 'horses'
    
                if (request.query.tags) {
                    tags = request.query.tags.split(',');
                    routes = routes.filter(function(route) {
                        var exit;
    
                        for (var i = 0; i < tags.length; i++) {
                            switch(tags[i].substring(0,1)) {
                                case '-': // exclude tags that match this case
                                    var tag = tags[i].substring(1,tags[i].length);
                                    if (Hoek.intersect(route.settings.tags, [tag]).length > 0) {
                                        exit = true;
                                    }
                                    break;
                                case ' ': // (+) filter out tagged paths that do not have this tag!
                                    var tag = tags[i].substring(1,tags[i].length);
                                    if (Hoek.intersect(route.settings.tags, [tag]).length == 0) {
                                        exit = true;
                                    }
                                    break;
                            }
                        }
    
                        // if we have reason to exit, then do so!
                        if (exit == true) {
                            return false;
                        }
    
                        // default behavior for tags is additive
                        if (Hoek.intersect(route.settings.tags, tags).length > 0) {
                            return true;
                        }
    
                        // fallback or no tag defined
                        return false;
                    });
                }
    
                // return 404 if no routes are found
                if (!routes || !routes.length) {
                    reply(Boom.notFound());
                }else{
    
                    // sort routes a-z
                    routes.sort(function (route1, route2) {
                        if (route1.path < route2.path) return -1;
                        if (route1.path > route2.path) return 1;
                        return 0;
                    });
    
                    // build documentation API endpoint for each route group
                    if (request.query.path) {
                        var apiData = internals.getRoutesData(routes, settings);
                        apiData.path = routes[0] ? routes[0].path : '/';
                        return reply(internals.buildAPIInfo(requestSettings, apiData, request.query.path)).type('application/json; charset=utf-8');
                    }
    
                    // build documentation API discovery endpoint
                    return reply(internals.buildAPIDiscovery(requestSettings, routes, request.query.tags)).type('application/json; charset=utf-8');
    
                }
    
    
    
    
    
    
            },
            plugins: {
                "hapi-swagger": false
            }
        };
    };
    
    
    // is route path part of the resource
    // Based on pull request by David Waterston  - http://jsfiddle.net/davidwaterston/cC4v8/
    internals.isResourceRoute = function (routePath, resourceName) {
        if (routePath &&
            resourceName &&
            routePath.search('^/' + resourceName + '(/|$)') === 0) {
            return true;
        }
        return false;
    };
    
    
    // filters route objects into simpler more useful form
    internals.getRoutesData = function (routes, settings) {
        var routesData = [];
    
        routes.forEach(function (route) {
            // only include routes tagged with "api"
            if (!route.settings.tags || route.settings.tags.indexOf('api') < 0) return;
    
            var routeOptions = route.settings.plugins ? route.settings.plugins['hapi-swagger'] : {};
            var routeData = {
                path: route.path,
                method: route.method.toUpperCase(),
                description: route.settings.description,
                notes: route.settings.notes,
                authorizations: {},
                tags: route.settings.tags,
                queryParams: route.settings.validate && route.settings.validate.query,
                pathParams: route.settings.validate && route.settings.validate.params,
                payloadParams: route.settings.validate && route.settings.validate.payload,
                responseSchema: route.settings.response && route.settings.response.schema,
                headerParams: route.settings.validate && route.settings.validate.headers,
                responseMessages: routeOptions && routeOptions.responseMessages || [],
                nickname: routeOptions && routeOptions.nickname || null,
                payloadType: routeOptions && routeOptions.payloadType || null
            };
    
            if(route.settings.auth && settings.authorizations) {
                route.settings.auth.strategies.forEach(function(strategie) {
                    if(settings.authorizations[strategie] && settings.authorizations[strategie].type){
                       routeData.authorizations[settings.authorizations[strategie].type] = settings.authorizations[strategie]
                    }
                });
            }
    
            routesData.push(routeData);
        });
    
        return {
            routes: routesData
        };
    };
    
    
    // build documentation API discovery endpoint
    internals.buildAPIDiscovery = function (settings, routes, tags) {
        var i = routes.length,
            x = 0,
            parts,
            prefix,
            apis = [],
            swagger = {
                "apiVersion": "unknown",
                "swaggerVersion": "1.2",
                "basePath": settings.endpoint + '?path=',
                "apis": []
            };
    
        // pass through tags to restrict endpoint display
        if (tags) {
            swagger.basePath = settings.endpoint + '?tags=' + tags + '&path='
        }
    
        if (settings.apiVersion) {
            swagger.apiVersion = settings.apiVersion;
        }
    
        if (settings.info) {
            // schema for settings
            // https://github.com/swagger-api/swagger-spec/blob/master/versions/1.2.md#513-info-object
            var settingsSchema = Joi.object().keys({
                title: Joi.string().required(),
                description: Joi.string().required(),
                termsOfServiceUrl: Joi.string().optional(),
                contact: Joi.string().email().optional(),
                license: Joi.string().optional(),
                licenseUrl: Joi.string().optional()
            });
    
            Joi.validate(settings.info, settingsSchema, { stripUnknown: true }, function (err, value) {
                if(err && err.message){
                    settings.log(['error', 'hapi-swagger'], 'settings.info: ' + err.message);
                }else{
                    swagger.info = value;
                }
            }); 
        }
    
        while (x < i) {
            var route = routes[x];
            if (route.settings.tags && route.settings.tags.indexOf('api') > -1) {
                parts = route.path.split('/');
                prefix = internals._commonPrefix(settings, route.path);
                // only add a group once base on the starting path segment
                if (apis.indexOf(prefix) === -1) {
                    swagger.apis.push({
                        "path": prefix
                    });
                    apis.push(prefix);
                }
            }
            x++;
        }
    
        return swagger;
    };
    
    internals._commonPrefix = function (settings, path) {
        var i = 0,
            path_head = [],
            prefix,
            parts;
        parts = path.split('/');
        while (parts.length > 0) {
            var item = parts.shift();
            if (item !== '') {
                path_head.push(item);
                // only count when it's a path element (and not the initial /)
                i++;
            }
            if (i >= settings.pathPrefixSize) {
                break;
            }
        }
        prefix = path_head.join('/');
        return prefix;
    };
    
    internals._getClassName = function(schema) {
        if(schema && schema._meta && Array.isArray(schema._meta)){
            var i = schema._meta.length;
            while (i--) {
                if(schema._meta[i].className){
                    return schema._meta[i].className
                }
            }    
        }
        return undefined;
    }
    
    // build documentation API endpoint for each route group
    internals.buildAPIInfo = function (settings, apiData, slug) {
        var parts;
        var swagger = {
            "apiVersion": "unknown",
            "swaggerVersion": "1.2",
            "basePath": settings.basePath,
            "resourcePath": '/' + slug,
            "apis": [],
            "models": {}
        };
    
        if (settings.apiVersion) {
            swagger.apiVersion = settings.apiVersion;
        }
    
        apiData.routes.forEach(function (route, indexA) {
            var api = {
                "path": route.path,
                "description": route.description,
                "operations": [{
                        "method": route.method,
                        "authorizations": route.authorizations,
                        "summary": route.description,
                        "nickname": route.nickname || route.path.replace(/\//gi, '').replace(/\{/gi, '').replace(/\}/gi, ''),
                        "notes": route.notes,
                        "type": 'void',
                        "parameters": []
                }]
            };
    
            var op = api.operations[0];
    
            op.notes = Array.isArray(route.notes) ? route.notes.join('<br/><br/>') : route.notes;
            op.responseMessages = route.responseMessages;
    
            var pathParam = internals.getParams(route, 'pathParams')
            var queryParam = internals.getParams(route, 'queryParams')
            var headerParam = internals.getParams(route, 'headerParams')
    
            // build up swagger properties for route validation
            var pathProperties = internals.validatorsToProperties(pathParam, swagger.models);
            var queryProperties = internals.validatorsToProperties(queryParam, swagger.models);
            var headerProperties = internals.validatorsToProperties(headerParam, swagger.models);
            var payloadApiParams;
    
            // set globally or locally to route
            var payloadType = settings.payloadType
            if(route.payloadType){
                payloadType = route.payloadType;
            }
    
            if (payloadType.toLowerCase() === 'json') {
                // set as json
                var payloadProperty = internals.validatorToProperty(op.nickname, route.payloadParams, swagger.models);
                if (payloadProperty && payloadProperty.type !== 'void') {
                    payloadProperty.required = true;
                    op.consumes = settings.consumes || ['application/json'];
                }
                payloadApiParams = internals.propertiesToAPIParams({
                    body: payloadProperty
                }, 'body');
            } else {
                // set as form
                var payloadParam = internals.getParams(route, 'payloadParams')
                var payloadProperties = internals.validatorsToProperties(payloadParam, swagger.models);
                payloadApiParams = internals.propertiesToAPIParams(payloadProperties, 'form');
            }
    
    
            // add the path, query and body parameters
            op.parameters = op.parameters.concat(
                internals.propertiesToAPIParams(headerProperties, 'header'),
                internals.propertiesToAPIParams(pathProperties, 'path'),
                internals.propertiesToAPIParams(queryProperties, 'query'),
                payloadApiParams
            );
    
            // set response type and model
            // If the responseSchema is a joi object, response className can be set as an option:
            // Example: route.responseSchema = Joi.object({foo:Joi.string()}).options({className:"MyResponseClass"});
    
            var responseClassName = internals._getClassName(route.responseSchema),
                altClassName = op.nickname + '_' + route.method + '_response';
    
            responseClassName = responseClassName || altClassName;
    
            var responseProperty = internals.validatorToProperty(
                    responseClassName,
                    internals.getParams(route, 'responseSchema'), 
                    swagger.models, 
                    null
                );
    
            if (responseProperty) {
                op.type = responseProperty.type || 'void';
                if (op.type !== 'void') {
                    op.produces = settings.produces;
                }
                if(responseProperty.items) {
                    // add these to the api operations
                    op.items = responseProperty.items;
                }
            }
    
            swagger.apis.push(api);
        });
    
        return swagger;
    };
    
    
    // gets the pramas from route object
    internals.getParams = function (route, name) {
        var prama = route[name];
    
        if (route[name] && route[name].isJoi) {
            if (route[name]._inner.children) {
                prama = route[name]._inner.children;
            } else {
                // fix for responseObject array types
                if (route[name]._type = 'array') {
                    prama = route[name];
                }
            }
        }
    
        return prama;
    }
    
    
    // convert an object of properties to an api parameter array
    internals.propertiesToAPIParams = function (properties, type) {
        if (properties === null ||
            properties === undefined ||
            (typeof properties !== 'object')) {
            return [];
        }
    
        var params = [];
        var keys = Object.keys(properties);
        for (var i = 0, il = keys.length; i < il; ++i) {
            var key = keys[i];
            var param = properties[key];
            if (!param) {
                continue;
            }
            param.name = key;
            param.paramType = type;
            if (param.type === "array") {
                param.allowMultiple = true;
            }
            params.push(param);
        }
    
        return params;
    };
    
    
    // convert an object of Joi validators into an object of swagger schema properties
    internals.validatorsToProperties = function (params, models, requiredArray) {
        var i,
            x,
            key,
            param,
            properties = {};
    
        if (params === null ||
            params === undefined ||
            (typeof params !== 'object')) {
            return [];
        }
    
        if (params.isJoi && params._inner.children) {
            params = params._inner.children
        }
    
        if (Array.isArray(params)) {
            i = params.length,
                x = 0;
            while (x < i) {
                key = params[x].key;
                param = params[x].schema;
                properties[key] = internals.validatorToProperty(key, param, models, requiredArray);
                x++;
            }
        }
    
        return properties;
    };
    
    // decode a Joi validator into swagger schema property
    internals.validatorToProperty = function (name, param, models, requiredArray) {
        if (param === null ||
            param === undefined) {
            return undefined;
        }
    
        // removes forbidden properties
        if (param._flags 
            && param._flags.presence
            && param._flags.presence === 'forbidden'){
                return undefined;
        }
    
    
        var property = {
            type: 'void'
        };
    
        // if given a plain object, create a model and return that
        if (typeof param.validate !== 'function') {
            property.type = internals.validatorsToModelName(name, param, models);
            return property;
        }
    
        if (param.describe) {
            var describe = param.describe();
            property.type = param._type.toLowerCase();
            property.description = typeof param._description === 'string' ? param._description : undefined;
            property.notes = typeof param._notes !== 'function' && param._notes.length ? param._notes : undefined;
            property.tags = typeof param._tags !== 'function' && param._tags.length ? param._tags : undefined;
            property.defaultValue = (describe.flags) ? describe.flags.default : null;
    
            if (param._flags && param._flags.presence) {
                property.required = (param._flags.presence === 'required') ? true : false;
            }
    
            // add enum values if not only undefined or null
            if (Array.isArray(describe.valids) && describe.valids.length) {
                var enums = describe.valids.filter(function (v) {
                    return v !== undefined && v !== '';
                });
                if (enums.length) {
                    property["enum"] = enums;
                }
            }
    
            if (property.type === 'number') {
                property.minimum = internals.getArgByName(describe.rules, 'min');
                property.maximum = internals.getArgByName(describe.rules, 'max');
                if (internals.existsByName(describe.rules, 'integer')) {
                    property.type = 'integer';
                }
            }
    
            if (property.type === 'object' && param._inner) {
                var className = internals._getClassName(param);
                var param = (param._inner.children) ? param._inner.children : param._inner
                property.type = internals.validatorsToModelName(
                        className || name || property.description,
                    param,
                    models);
            }
    
            if (property.type === 'array') {
                property.minItems = internals.getArgByName(describe.rules, 'min');
                property.maxItems = internals.getArgByName(describe.rules, 'max');
    
                var arrayTypes = param._inner ? param._inner.inclusions : internals.getArgByName(describe.rules, 'includes');
                // swagger appears to only support one array type at a time, so lets grab the first one
                var firstInclusionType = internals.first(arrayTypes);
    
                if (firstInclusionType) {
                    // get className of embeded array
                    if(name === 'items' 
                        && Hoek.reach(param, '_inner.inclusions.0._meta')
                        && Array.isArray(param._inner.inclusions[0]._meta)){
    
                        var meta = param._inner.inclusions[0]._meta,
                            i = meta.length;
                        while (i--) {
                            if(meta[i].className){
                                name = meta[i].className
                            }
                        }    
                    }
    
    
                    var arrayProperty = internals.validatorToProperty(name, firstInclusionType, models);
    
                    if (arrayProperty['enum']) {
                        property.items = {
                            'type': arrayProperty.type,
                            'enum': arrayProperty['enum']
                        };
                    } else {
                        if(arrayProperty.type === 'string'){
                            property.items = {
                                'type': arrayProperty.type
                            };
                        }else{
                            property.items = {
                                '$ref': arrayProperty.type
                            };
                        }
    
                    }
                }
            }
    
            if (property.type === 'any') { 
                var i = param._meta.length;
                while (i--) {
                    if(param._meta[i].swaggerType
                        && param._meta[i].swaggerType === 'file'){
                        property.type = "file";  
                        property.paramType = "body"; 
                    }
                }    
            } 
    
        }
    
        // if a required array is present use that for required fields instead of a flag
        if (requiredArray) {
            if (property.required) {
                requiredArray.push(name);
            }
            delete property.required;
        }
    
        return property;
    };
    
    
    // create a model from an object of Joi validators. Return the model name
    internals.validatorsToModelName = function (name, params, models) {
    
        // if no name create a signature
        if (!name) {
            name = 'model_' + ShortId.generate();
        }
    
        // need to either create new object or comparision
        var model = internals.createModel(name, params, models);
    
        // find existing model by this name
        var foundModel = models[name];
        if (foundModel) {
            
            // deep compare object
            if(Hoek.deepEqual(foundModel, model)){
                // return existing id
                return foundModel.id; 
            }else{
                // create new model with alt name, to stop reuse of model
                model.id = 'model_' + ShortId.generate();
                models[model.id] = model;
            }
        }else{
            // create new model
            models[name] = model;
        }
    
        return model.id;
    };
    
    
    // creates a new model
    internals.createModel = function (name, params, models) {
        return model = {
            "id": name,
            "type": "object",
            "properties": internals.validatorsToProperties(params, models)
        };
    }
    
    
    // get existance of an item in array of structure [ { name: 'name' } ]
    internals.existsByName = function (array, name) {
        return array && array.some(function (v) {
            return v.name === name;
        });
    };
    
    
    // get arg value of an item in arrays of structure
    //   [ { name: 'name', arg: 'arg' } ]
    // or from two arrays
    //   ['name'] [ {'0': 'arg'} ]
    internals.getArgByName = function (array, name, args) {
        if (!Array.isArray(array)) {
            return;
        }
    
        if (args) {
            var location = names.lastIndexOf(name);
            if (~location && args[location]) {
                return args[location]['0'];
            }
            return;
        }
    
        for (var i = array.length - 1; i >= 0; i--) {
            if (array[i].name === name) {
                return array[i].arg;
            }
        }
    };
    
    
    // append settings data in template context
    internals.appendReplyContext = function ( server, settings ) {
        server.ext('onPostHandler', function (request, reply) {
            var response = request.response;
            if (response.variety === 'view') {
    
                if(!response.source.context){
                    response.source.context = {};
                }
    
                if(!response.source.context['hapiSwagger']){
                    response.source.context['hapiSwagger'] = {};
                }
                response.source.context['hapiSwagger'] = settings
            }
    
            return reply.continue();
        });
    };
    
    
    exports._internals = internals;
  provide("hapi-swagger/lib", module.exports);
}(global));

// pakmanager:hapi-swagger
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('hapi-swagger/lib');
  provide("hapi-swagger", module.exports);
}(global));

// pakmanager:require-env
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*jshint node:true globalstrict:true*/
    "use strict";
    var fs = require('fs'),
        url = require('url');
    
    module.exports = {
        contains: function(name) {
            return (process.env[name] !== undefined);
        },
        inherit: function(filename) {
            try {
                var env = fs.readFileSync(filename, "utf8");
    
                env.split("\n").forEach(function(line) {
                    var parts = line.split("=");
    
                    // override environment vars with test.env
                    if (parts.length == 2 &&
                        !parts[0].match(/^#/) &&
                        process.env[parts[0]] === undefined) {
                        process.env[parts[0]] = parts[1];
                    }
                });
            } catch (e) {
                console.warn(filename + " is absent; your environment may be incomplete.");
            }
        },
        require: function(name) {
            if (!this.contains(name)) {
                throw new Error("process.env." + name + " is undefined");
            }
    
            return process.env[name];
        },
        requireUrl: function(name) {
            var option = url.parse(this.require(name));
    
            option.port = parseInt(option.port, 10);
    
            if (option.auth) {
                var auth = option.auth.split(":", 2);
                option.user = auth[0];
                option.pass = auth[1];
            }
    
            return option;
        }
    };
    
  provide("require-env", module.exports);
}(global));

// pakmanager:vertigo/app/server.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    
    // TODO Try out Good for server logging - see https://github.com/hapijs/good
    
    var Hapi = require('hapi');
    var server = new Hapi.Server();
    var port = (process.env.PORT || 3000);
    var host = (process.env.host || '127.0.0.1');
    
    console.log('Server starting on: ' + host + ':' + port);
    
    // TODO More expressive logging here
    // var server = new Hapi.Server({ debug: { request: ['error'] } });
    
    server.connection({
      host: host,
      port: port,
      routes: {
        cors: {
          origin: ['*'],
          methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'HEAD'],
          headers: ['content-type', 'x-identity-token'],
          isOriginExposed: false
        }
      }
    });
    
    server.start(function (){
        console.log('Server running at:', server.info.uri);
    });
    
    module.exports = server;
  provide("vertigo/app/server.js", module.exports);
}(global));

// pakmanager:vertigo
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var server =  require('vertigo/app/server.js');
    
    server.route({
      method: 'POST',
      path: '/playbook',
      handler: function (request, reply) {
        console.log("IN PLAYBOOK!");
        console.log(request.payload);
        reply().code(200);
      }
    });
    
    // server.route({
    //   method: 'GET',
    //   path: '/playbook',
    //   handler: function (request, reply) {
    //   }
    // });
  provide("vertigo", module.exports);
}(global));